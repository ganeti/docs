-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | This is the internal documentation for the Haskell components of
--   Ganeti.
--   
--   The <tt>Ganeti.HTools</tt> subtree contain the htools-specific
--   component (rebalancing, allocation, capacity), while the
--   <tt>Ganeti</tt> tree contains basic functionality and core components.
@package ganeti


-- | Unittest helpers for TemplateHaskell components.
module Test.Ganeti.TestHelper
propPrefix :: String
casePrefix :: String
case2Pfx :: String
simplifyName :: String -> String -> String
runProp :: Testable prop => String -> prop -> Test
runCase :: String -> Assertion -> Test
run :: Name -> Q Exp
mapSlashes :: String -> String

-- | Builds a test suite.
testSuite :: String -> [Name] -> Q [Dec]
mkConsArbitrary :: (Name, [a]) -> Exp
conInfo :: Con -> (Name, [Type])
mkRegularArbitrary :: Name -> [Con] -> Q [Dec]

-- | Builds a default Arbitrary instance for a type. This requires that all
--   members are of types that already have Arbitrary instances, and that
--   the arbitrary instances are well behaved (w.r.t. recursive data
--   structures, or similar concerns). In that sense, this is not
--   appropriate for all data types, just those that are simple but very
--   repetitive or have many simple fields.
genArbitrary :: Name -> Q [Dec]


-- | Unittests for Attoparsec support for unicode
module Test.Ganeti.Attoparsec
part1 :: String
part2 :: String
simpleParser :: Parser (String, String)
case_unicodeParsing :: Assertion
testAttoparsec :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Jobs
testJobs :: Test


-- | Metadata daemon types.
module Ganeti.Metad.Types
type InstanceParams = Map String JSValue


-- | Provides a general functionality for workers that run on the
--   background and perform some task when triggered.
--   
--   Each task can process multiple triggers, if they're coming faster than
--   the tasks are being processed.
--   
--   Properties:
--   
--   <ul>
--   <li>If a worked is triggered, it will perform its action eventually.
--   (i.e. it won't miss a trigger).</li>
--   <li>If the worker is busy, the new action will start immediately when
--   it finishes the current one.</li>
--   <li>If the worker is idle, it'll start the action immediately.</li>
--   <li>If the caller uses <a>triggerAndWait</a>, the call will return
--   just after the earliest action following the trigger is finished.</li>
--   <li>If the caller uses <a>triggerWithResult</a>, it will recive an
--   <a>Async</a> value that can be used to wait for the result (which will
--   be available once the earliest action following the trigger
--   finishes).</li>
--   <li>If the worker finishes an action and there are no pending triggers
--   since the start of the last action, it becomes idle and waits for a
--   new trigger.</li>
--   </ul>
module Ganeti.Utils.AsyncWorker
data TriggerState i a
Idle :: TriggerState i a
Pending :: i -> [MVar a] -> TriggerState i a
addTrigger :: Monoid i => i -> Maybe (MVar a) -> TriggerState i a -> TriggerState i a

-- | Represent an asynchronous worker whose single action execution returns
--   a value of type <tt>a</tt>.
data AsyncWorker i a
AsyncWorker :: ThreadId -> (IORef (TriggerState i a)) -> (MVar ()) -> AsyncWorker i a

-- | Given an action, construct an <a>AsyncWorker</a>.
mkAsyncWorker :: (Monoid i, MonadBaseControl IO m) => (i -> m a) -> m (AsyncWorker i a)

-- | Given an action, construct an <a>AsyncWorker</a> with no input.
mkAsyncWorker_ :: MonadBaseControl IO m => m a -> m (AsyncWorker () a)

-- | An asynchronous result that will eventually yield a value.
newtype Async a
Async :: MVar a -> Async a
asyncResult :: Async a -> MVar a

-- | Waits for an asynchronous result to finish and yield a value.
wait :: MonadBase IO m => Async a -> m a

-- | Waits for all asynchronous results in a collection to finish and yield
--   a value.
waitMany :: (MonadBase IO m, Traversable t) => t (Async a) -> m (t a)
triggerInternal :: (MonadBase IO m, Monoid i) => i -> Maybe (MVar a) -> AsyncWorker i a -> m ()

-- | Trigger a worker, letting it run its action asynchronously, but do not
--   wait for the result.
trigger :: (MonadBase IO m, Monoid i) => i -> AsyncWorker i a -> m ()

-- | Trigger a worker with no input, letting it run its action
--   asynchronously, but do not wait for the result.
trigger_ :: MonadBase IO m => AsyncWorker () a -> m ()

-- | Trigger a worker and wait until the action following this trigger
--   finishes. The returned <a>Async</a> value can be used to wait for the
--   result of the action.
triggerWithResult :: (MonadBase IO m, Monoid i) => i -> AsyncWorker i a -> m (Async a)

-- | Trigger a worker and wait until the action following this trigger
--   finishes.
--   
--   See <a>triggerWithResult</a>.
triggerWithResult_ :: MonadBase IO m => AsyncWorker () a -> m (Async a)

-- | Trigger a list of workers and wait until all the actions following
--   these triggers finish. The returned collection of <a>Async</a> values
--   can be used to wait for the results of the actions.
triggerWithResultMany :: (Traversable t, MonadBase IO m, Monoid i) => i -> t (AsyncWorker i a) -> m (t (Async a))

-- | Trigger a list of workers with no inputs and wait until all the
--   actions following these triggers finish.
--   
--   See <a>triggerWithResultMany</a>.
triggerWithResultMany_ :: (Traversable t, MonadBase IO m) => t (AsyncWorker () a) -> m (t (Async a))

-- | Trigger a list of workers and wait until all the actions following
--   these triggers finish. Returns the results of the actions.
--   
--   Note that there is a significant difference between
--   <a>triggerAndWaitMany</a> and <tt>mapM triggerAndWait</tt>. The latter
--   runs all the actions of the workers sequentially, while the former
--   runs them in parallel.
triggerAndWaitMany :: (Traversable t, MonadBase IO m, Monoid i) => i -> t (AsyncWorker i a) -> m (t a)
triggerAndWaitMany_ :: (Traversable t, MonadBase IO m) => t (AsyncWorker () a) -> m (t a)

-- | Trigger a worker and wait until the action following this trigger
--   finishes. Return the result of the action.
triggerAndWait :: (MonadBase IO m, Monoid i) => i -> AsyncWorker i a -> m a

-- | Trigger a worker with no input and wait until the action following
--   this trigger finishes. Return the result of the action.
triggerAndWait_ :: MonadBase IO m => AsyncWorker () a -> m a


-- | Utilities related to randomized computations.
module Ganeti.Utils.Random

-- | Generates a random secret of a given length. The type is chosen so
--   that it can be easily wrapped into a state monad.
generateSecret :: RandomGen g => Int -> g -> (String, g)

-- | Given a prefix, randomly generates a full MAC address.
--   
--   See <tt>generateMAC</tt> for discussion about how this function uses
--   the random generator.
generateOneMAC :: RandomGen g => String -> g -> (String, g)

-- | Wait a time period randomly chosen within the given bounds (in
--   microseconds).
delayRandom :: (Int, Int) -> IO ()


-- | Utility functions for MonadPlus operations
module Ganeti.Utils.Monad

-- | Retries the given action up to <tt>n</tt> times. The action signals
--   failure by <a>mzero</a>.
mretryN :: MonadPlus m => Int -> (Int -> m a) -> m a

-- | Retries the given action up to <tt>n</tt> times. The action signals
--   failure by <a>mzero</a>.
retryMaybeN :: Monad m => Int -> (Int -> MaybeT m a) -> m (Maybe a)

-- | Retries the given action up to <tt>n</tt> times until it succeeds. If
--   all actions fail, the error of the last one is returned. The action is
--   always run at least once, even if <tt>n</tt> is less than 1.
retryErrorN :: MonadError e m => Int -> (Int -> m a) -> m a

-- | Short-circuit <a>any</a> with a monadic predicate.
anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Short-circuit <a>all</a> with a monadic predicate.
allM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Short-circuit <a>or</a> for values of type Monad m =&gt; m Bool
orM :: Monad m => [m Bool] -> m Bool

-- | See <a>unfoldr</a>. This is a monad-friendly version of that.
unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]

-- | See <a>unfoldr</a>. This is a monad-friendly version of that, with a
--   twist. Rather than returning a list, it returns any MonadPlus type of
--   your choice.
unfoldrM' :: (Monad m, MonadPlus f) => (a -> m (Maybe (b, a))) -> a -> m (f b)


-- | A validation monad and corresponding utilities
--   
--   The monad allows code to emit errors during checking.
module Ganeti.Utils.Validate

-- | Monad for running validation checks.
newtype ValidationMonadT m a
ValidationMonad :: WriterT (Seq String) m a -> ValidationMonadT m a
runValidationMonad :: ValidationMonadT m a -> WriterT (Seq String) m a
type ValidationMonad = ValidationMonadT Identity

-- | An utility function that emits a single message into a validation
--   monad.
report :: Monad m => String -> ValidationMonadT m ()

-- | An utility function that conditionally emits a message into a
--   validation monad. It's a combination of <a>when</a> and <a>report</a>.
reportIf :: Monad m => Bool -> String -> ValidationMonadT m ()

-- | An utility function that runs a monadic validation action and returns
--   the list of errors.
runValidateT :: Monad m => ValidationMonadT m a -> m (a, [String])

-- | An utility function that runs a monadic validation action and returns
--   the list of errors.
runValidate :: ValidationMonad a -> (a, [String])

-- | An utility function that runs a monadic validation action and returns
--   the list of errors.
execValidateT :: Monad m => ValidationMonadT m () -> m [String]

-- | An utility function that runs a validation action and returns the list
--   of errors.
execValidate :: ValidationMonad () -> [String]
throwIfErrors :: (MonadError e m, Error e) => (a, [String]) -> m a

-- | Runs a validation action and if there are errors, combine them into an
--   exception.
evalValidate :: (MonadError e m, Error e) => ValidationMonad a -> m a

-- | Runs a validation action and if there are errors, combine them into an
--   exception.
evalValidateT :: (MonadError e m, Error e) => ValidationMonadT m a -> m a

-- | A typeclass for objects that can be validated. That is, they can
--   perform an internal check and emit any errors encountered. Emiting no
--   errors means the object is valid.
class Validatable a
validate :: Validatable a => a -> ValidationMonad ()

-- | Run validation and return the original value as well. the original
--   value.
validate' :: Validatable a => a -> ValidationMonad a
instance Functor m => Functor (ValidationMonadT m)
instance Applicative m => Applicative (ValidationMonadT m)
instance Monad m => Monad (ValidationMonadT m)


-- | Common functions for partial parameters
module Ganeti.PartialParams

-- | Represents that data type <tt>p</tt> provides partial values for data
--   type <tt>f</tt>.
--   
--   Note: To avoid needless type annotations, the functional dependencies
--   currently include <tt>f -&gt; p</tt>. However, in theory it'd be
--   possible for one filled data type to have several partially filled
--   ones.
--   
--   Laws:
--   
--   <ol>
--   <li><tt>fillParams (fillParams f p) p = fillParams f p</tt>. 2.
--   <tt>fillParams _ (toPartial x) = x</tt>. 3. <tt>toFilled (toPartial x)
--   = Just x</tt>.</li>
--   </ol>
--   
--   If <tt>p</tt> is also a <tt>Monoid</tt> (or just <tt>Semigroup</tt>),
--   <a>fillParams</a> is a monoid (semigroup) action on <tt>f</tt>,
--   therefore it should additionally satisfy:
--   
--   <ul>
--   <li><tt>fillParams f mempty = f</tt> - <tt>fillParams f (p1 <a></a>
--   p2) = fillParams (fillParams f p1) p2</tt></li>
--   </ul>
class PartialParams f p | p -> f, f -> p
fillParams :: PartialParams f p => f -> p -> f
toPartial :: PartialParams f p => f -> p
toFilled :: PartialParams f p => p -> Maybe f

-- | Returns <a>True</a> if a given partial parameters are complete. See
--   <a>toFilled</a>.
isComplete :: PartialParams f p => p -> Bool


-- | Utility Template Haskell functions for working with types.
module Ganeti.THH.Types

-- | This fills the gap between <tt>()</tt> and <tt>(,)</tt>, providing a
--   wrapper for 1-element tuples. It's needed for RPC, where arguments for
--   a function are sent as a list of values, and therefore for 1-argument
--   functions we need this wrapper, which packs/unpacks 1-element lists.
newtype OneTuple a
OneTuple :: a -> OneTuple a
getOneTuple :: OneTuple a -> a

-- | Returns the type of a function. If the given name doesn't correspond
--   to a function, fails.
typeOfFun :: Name -> Q Type

-- | Splits a function type into the types of its arguments and the result.
funArgs :: Type -> ([Type], Type)
tupleArgs :: Type -> Maybe [Type]

-- | Given a type of the form <tt>m a</tt>, this function extracts
--   <tt>a</tt>. If the given type is of another form, it fails with an
--   error message.
argumentType :: Type -> Q Type

-- | Generic <a>uncurry</a> that counts the number of function arguments in
--   a type and constructs the appropriate uncurry function into <tt>i
--   -&gt; o</tt>. It the type has no arguments, it's converted into <tt>()
--   -&gt; o</tt>.
uncurryVarType :: Type -> Q Exp

-- | Creates an uncurried version of a function. If the function has no
--   arguments, it's converted into <tt>() -&gt; o</tt>.
uncurryVar :: Name -> Q Exp

-- | Generic <a>curry</a> that constructs a curring function of a given
--   arity.
curryN :: Int -> Q Exp
instance Eq a => Eq (OneTuple a)
instance Ord a => Ord (OneTuple a)
instance Show a => Show (OneTuple a)
instance Functor OneTuple
instance JSON a => JSON (OneTuple a)


-- | Combines the construction of RPC server components and their Python
--   stubs.
module Ganeti.THH.PyRPC
pythonIndentStep :: Int
nest' :: Doc -> Doc
genericInvokeName :: String
socketPathName :: String
apply :: String -> [Doc] -> Doc
emptyLine :: Doc
lowerFirst :: String -> String
upperFirst :: String -> String
toFunc :: String -> [Type] -> Q Doc
nameToFunc :: Name -> Q Doc
namesToClass :: String -> Doc -> [Name] -> Q Doc

-- | Takes a list of function names and creates a RPC handler that
--   delegates calls to them, as well as writes out the corresponding
--   Python stub.
--   
--   See <tt>mkRpcM</tt> for the requirements on the passed functions and
--   the returned expression.
genPyUDSRpcStub :: String -> String -> [Name] -> Q Doc
genPyUDSRpcStubStr :: String -> String -> [Name] -> Q Exp


-- | Ganeti lock-related types and type classes
module Ganeti.Locking.Types

-- | The type class of being a lock
--   
--   As usual, locks need to come with an order, the lock order, and be an
--   instance of Show, so that malformed requests can meaningfully be
--   reported.
--   
--   Additionally, in Ganeti we also have group locks, like a lock for all
--   nodes. While those group locks contain infinitely many locks, the set
--   of locks a single lock is included in is always finite, and usually
--   very small. So we take this association from a lock to the locks it is
--   (strictly) included in as additional data of the type class.
--   
--   It is a prerequisite that whenever <tt>a</tt> is implied in
--   <tt>b</tt>, then all locks that are in the lock order between
--   <tt>a</tt> and <tt>b</tt> are also implied in <tt>b</tt>.
class (Ord a, Show a) => Lock a
lockImplications :: Lock a => a -> [a]


-- | A data structure for measuring how many of a number of available slots
--   are taken.
module Ganeti.SlotMap

-- | A resource with [limit] available units and [occupied] of them taken.
data Slot
Slot :: Int -> Int -> Slot
slotOccupied :: Slot -> Int
slotLimit :: Slot -> Int

-- | A set of keys of type <tt>a</tt> and how many slots are available and
--   (to be) occupied per key.
--   
--   Some keys can be overfull (more slots occupied than available).
type SlotMap a = Map a Slot

-- | A set of keys of type <tt>a</tt> and how many there are of each.
type CountMap a = Map a Int

-- | Turns a <a>SlotMap</a> into a <a>CountMap</a> by throwing away the
--   limits.
toCountMap :: SlotMap a -> CountMap a

-- | Whether any more slots are occupied than available.
isOverfull :: SlotMap a -> Bool

-- | Fill slots of a <a>SlotMap</a>s by adding the given counts. Keys with
--   counts that don't appear in the <a>SlotMap</a> get a limit of 0.
occupySlots :: Ord a => SlotMap a -> CountMap a -> SlotMap a

-- | Whether the <a>SlotMap</a> has enough slots free to accomodate the
--   given counts.
--   
--   The <a>SlotMap</a> is allowed to be overfull in some keys; this
--   function still returns True as long as as adding the counts to the
--   <a>SlotMap</a> would not *create or increase* overfull keys.
--   
--   Adding counts &gt; 0 for a key which is not in the <a>SlotMap</a> does
--   create overfull keys.
hasSlotsFor :: Ord a => SlotMap a -> CountMap a -> Bool
instance Eq Slot
instance Ord Slot
instance Show Slot


-- | Utility functions for using MVars as simple locks.
module Ganeti.Utils.MVarLock
newtype Lock
MVarLock :: (MVar ()) -> Lock
newLock :: MonadBase IO m => m Lock
withLock :: MonadBaseControl IO m => Lock -> m a -> m a


-- | Provides all lens-related functions.
module Ganeti.Lens

-- | Creates an optimized lens where the setter also gets the original
--   value from the getter.
lensWith :: (s -> a) -> (s -> a -> b -> t) -> Lens s t a b
lensFieldName :: String -> String
makeCustomLensesFiltered :: (String -> Bool) -> Name -> Q [Dec]

-- | Create lenses for all fields of a given data type.
makeCustomLenses :: Name -> Q [Dec]

-- | Create lenses for some fields of a given data type.
makeCustomLenses' :: Name -> [Name] -> Q [Dec]

-- | Traverses over a composition of two functors. Most often the
--   <tt>g</tt> functor is <tt>(,) r</tt> and <a>traverseOf2</a> is used to
--   traverse an effectful computation that also returns an additional
--   output value.
traverseOf2 :: Over (->) (Compose f g) s t a b -> (a -> f (g b)) -> s -> f (g t)

-- | Traverses over a composition of a monad and a functor. See
--   <a>traverseOf2</a>.
mapMOf2 :: Over (->) (Compose (WrappedMonad m) g) s t a b -> (a -> m (g b)) -> s -> m (g t)

-- | A helper lens over sets. While a similar lens exists in the package
--   (as <tt>Lens' Set (Maybe ())</tt>), it's available only in most recent
--   versions. And using <tt>Bool</tt> instead of <tt>Maybe ()</tt> is more
--   convenient.
atSet :: Ord a => a -> Lens' (Set a) Bool


-- | Implementation of the doc strings for the opcodes.
module Ganeti.Hs2Py.OpDoc
opClusterPostInit :: String
opClusterDestroy :: String
opClusterQuery :: String
opClusterVerify :: String
opClusterVerifyConfig :: String
opClusterVerifyGroup :: String
opClusterVerifyDisks :: String
opGroupVerifyDisks :: String
opClusterRepairDiskSizes :: String
opClusterConfigQuery :: String
opClusterRename :: String
opClusterSetParams :: String
opClusterRedistConf :: String
opClusterActivateMasterIp :: String
opClusterDeactivateMasterIp :: String
opClusterRenewCrypto :: String
opQuery :: String
opQueryFields :: String
opOobCommand :: String
opRestrictedCommand :: String
opNodeRemove :: String
opNodeAdd :: String
opNodeQuery :: String
opNodeQueryvols :: String
opNodeQueryStorage :: String
opNodeModifyStorage :: String
opRepairNodeStorage :: String
opNodeSetParams :: String
opNodePowercycle :: String
opNodeMigrate :: String
opNodeEvacuate :: String
opInstanceCreate :: String
opInstanceMultiAlloc :: String
opInstanceReinstall :: String
opInstanceRemove :: String
opInstanceRename :: String
opInstanceStartup :: String
opInstanceShutdown :: String
opInstanceReboot :: String
opInstanceReplaceDisks :: String
opInstanceFailover :: String
opInstanceMigrate :: String
opInstanceMove :: String
opInstanceConsole :: String
opInstanceActivateDisks :: String
opInstanceDeactivateDisks :: String
opInstanceRecreateDisks :: String
opInstanceQuery :: String
opInstanceQueryData :: String
opInstanceSetParams :: String
opInstanceGrowDisk :: String
opInstanceChangeGroup :: String
opGroupAdd :: String
opGroupAssignNodes :: String
opGroupQuery :: String
opGroupSetParams :: String
opGroupRemove :: String
opGroupRename :: String
opGroupEvacuate :: String
opOsDiagnose :: String
opExtStorageDiagnose :: String
opBackupQuery :: String
opBackupPrepare :: String
opBackupExport :: String
opBackupRemove :: String
opTagsGet :: String
opTagsSearch :: String
opTagsSet :: String
opTagsDel :: String
opTestDelay :: String
opTestAllocator :: String
opTestJqueue :: String
opTestDummy :: String
opNetworkAdd :: String
opNetworkRemove :: String
opNetworkSetParams :: String
opNetworkConnect :: String
opNetworkDisconnect :: String
opNetworkQuery :: String


-- | Algorithms on Graphs.
--   
--   This module contains a few graph algorithms and the transoformations
--   needed for them to be used on nodes.
--   
--   For more information about Graph Coloring see:
--   <a>http://en.wikipedia.org/wiki/Graph_coloring</a>
--   <a>http://en.wikipedia.org/wiki/Greedy_coloring</a>
--   
--   LF-coloring is described in: Welsh, D. J. A.; Powell, M. B. (1967),
--   <a>An upper bound for the chromatic number of a graph and its
--   application to timetabling problems</a>, The Computer Journal 10 (1):
--   85-86, doi:10.1093<i>comjnl</i>10.1.85
--   <a>http://comjnl.oxfordjournals.org/content/10/1/85</a>
--   
--   DSatur is described in: Brelaz, D. (1979), <a>New methods to color the
--   vertices of a graph</a>, Communications of the ACM 22 (4): 251-256,
--   doi:10.1145/359094.359101
--   <a>http://dx.doi.org/10.1145%2F359094.359101</a>
--   
--   Also interesting: Klotz, W. (2002). Graph coloring algorithms.
--   Mathematics Report, Technical University Clausthal, 1-9.
--   &lt;http:<i></i>www.math.tu-clausthal.de<i>Arbeitsgruppen</i>Diskrete-Optimierung
--   <i>publications</i>2002/gca.pdf&gt;
module Ganeti.HTools.Graph

-- | Node colors.
type Color = Int
type Satur = Int

-- | Vertex to Color association.
type VertColorMap = IntMap Color

-- | Color to Vertex association.
type ColorVertMap = IntMap [Int]
verticesDegree :: Graph -> [(Vertex, Int)]

-- | vertices of a graph, sorted by ascending degree.
verticesByDegreeDesc :: Graph -> [Vertex]

-- | vertices of a graph, sorted by descending degree.
verticesByDegreeAsc :: Graph -> [Vertex]

-- | Get the neighbors of a vertex.
neighbors :: Graph -> Vertex -> [Vertex]

-- | Check whether a graph has no loops. (vertices connected to themselves)
hasLoop :: Graph -> Bool

-- | Check whether a graph is undirected
isUndirected :: Graph -> Bool

-- | Empty color map.
emptyVertColorMap :: VertColorMap

-- | Check whether a graph is colorable.
isColorable :: Graph -> Bool
verticesColors :: VertColorMap -> [Vertex] -> [Color]
verticesColorSet :: VertColorMap -> [Vertex] -> IntSet
neighColors :: Graph -> VertColorMap -> Vertex -> [Color]
colorNode :: Graph -> VertColorMap -> Vertex -> Color
colorNodeInMap :: Graph -> Vertex -> VertColorMap -> VertColorMap

-- | Color greedily all nodes in the given order.
colorInOrder :: Graph -> [Vertex] -> VertColorMap

-- | Color greedily all nodes, larger first.
colorLF :: Graph -> VertColorMap
vertexSaturation :: Graph -> VertColorMap -> Vertex -> (Vertex, (Satur, Int))
vertexColorDegree :: Graph -> VertColorMap -> Vertex -> (Vertex, (Int, Int))
colorDynamicOrder :: Ord a => (Graph -> VertColorMap -> Vertex -> (Vertex, a)) -> Graph -> VertColorMap -> [Vertex] -> VertColorMap

-- | Color greedily all nodes, highest number of colored neighbors, then
--   highest degree. This is slower than <a>colorLF</a> as we must
--   dynamically recalculate which node to color next among all remaining
--   ones but produces better results.
colorDcolor :: Graph -> VertColorMap

-- | Color greedily all nodes, highest saturation, then highest degree.
--   This is slower than <a>colorLF</a> as we must dynamically recalculate
--   which node to color next among all remaining ones but produces better
--   results.
colorDsatur :: Graph -> VertColorMap

-- | ColorVertMap from VertColorMap.
colorVertMap :: VertColorMap -> ColorVertMap


-- | Utility functions for statistical accumulation.
module Ganeti.Utils.Statistics

-- | Abstract type of statistical accumulations. They behave as if the
--   given statistics were computed on the list of values, but they allow a
--   potentially more efficient update of a given value.
data Statistics
SumStatistics :: Double -> Statistics
StdDevStatistics :: Double -> Double -> Double -> Statistics

-- | Get a statistics that sums up the values.
getSumStatistics :: [Double] -> Statistics

-- | Get a statistics for the standard deviation.
getStdDevStatistics :: [Double] -> Statistics

-- | Obtain the value of a statistics.
getStatisticValue :: Statistics -> Double

-- | In a given statistics replace on value by another. This will only give
--   meaningful results, if the original value was actually part of the
--   statistics.
updateStatistics :: Statistics -> (Double, Double) -> Statistics
instance Show Statistics


-- | Hsc2hs definitions for <a>Storable</a> interfaces.
module Ganeti.Curl.Internal

-- | Data representing a <tt>CURLMSG</tt> enum.
data CurlMsgCode
CurlMsgNone :: CurlMsgCode
CurlMsgDone :: CurlMsgCode

-- | Haskell specific code for unknown codes
CurlMsgUnknown :: CInt -> CurlMsgCode

-- | Data representing a <tt>struct CURLMsg</tt>.
data CurlMsg
CurlMsg :: CurlMsgCode -> CurlH -> CurlCode -> CurlMsg

-- | The message type
cmMessage :: CurlMsg -> CurlMsgCode

-- | The internal curl handle to which it applies
cmHandle :: CurlMsg -> CurlH

-- | The message-specific result
cmResult :: CurlMsg -> CurlCode

-- | Minimum buffer size for <a>CurlErrorBuffer</a>.
errorBufferSize :: Int

-- | Multi interface error codes.
data CurlMCode
CurlmCallMultiPerform :: CurlMCode
CurlmOK :: CurlMCode
CurlmBadHandle :: CurlMCode
CurlmBadEasyHandle :: CurlMCode
CurlmOutOfMemory :: CurlMCode
CurlmInternalError :: CurlMCode
CurlmBadSocket :: CurlMCode
CurlmUnknownOption :: CurlMCode

-- | Haskell specific code denoting undefined codes (e.g. when libcurl has
--   defined new codes that are not implemented yet)
CurlmUnknown :: CInt -> CurlMCode

-- | Convert a CInt CURLMSG code (as returned by the C library) to a
--   <a>CurlMsgCode</a>. When an unknown code is received, the special
--   <a>CurlMsgUnknown</a> constructor will be used.
toMsgCode :: CInt -> CurlMsgCode

-- | Convert a CurlMsgCode to a CInt.
fromMsgCode :: CurlMsgCode -> CInt

-- | Convert a CInt CURLMcode (as returned by the C library) to a
--   <a>CurlMCode</a>. When an unknown code is received, the special
--   <a>CurlmUnknown</a> constructor will be used.
toMCode :: CInt -> CurlMCode
instance Show CurlMsgCode
instance Eq CurlMsgCode
instance Show CurlMCode
instance Eq CurlMCode
instance Storable CurlMsg


-- | Utility functions for several parsers
--   
--   This module holds the definition for some utility functions for two
--   parsers. The parser for the <tt><i>proc</i>stat</tt> file and the
--   parser for the <tt><i>proc</i>diskstats</tt> file.
module Ganeti.Parsers

-- | Our own space-skipping function, because A.skipSpace also skips
--   newline characters. It skips ZERO or more spaces, so it does not fail
--   if there are no spaces.
skipSpaces :: Parser ()

-- | A parser recognizing a number preceeded by spaces.
numberP :: Parser Int

-- | A parser recognizing a word preceded by spaces, and closed by a space.
stringP :: Parser String


-- | Build-time configuration for Ganeti.
--   
--   Note that this file is autogenerated by the Makefile with a header
--   from <tt>AutoConf.hs.in</tt>.
module AutoConf
split :: String -> [String]
packageVersion :: String
versionMajor :: Int
versionMinor :: Int
versionRevision :: Int
versionSuffix :: String
versionFull :: String
dirVersion :: String
localstatedir :: String
sysconfdir :: String
sshConfigDir :: String
sshLoginUser :: String
sshConsoleUser :: String
exportDir :: String
backupDir :: String
osSearchPath :: [String]
esSearchPath :: [String]
xenBootloader :: String
xenConfigDir :: String
xenKernel :: String
xenInitrd :: String
kvmKernel :: String
sharedFileStorageDir :: String
iallocatorSearchPath :: [String]
defaultVg :: String
defaultBridge :: String
kvmPath :: String
ipPath :: String
socatPath :: String
pythonPath :: String
socatUseEscape :: Bool
socatUseCompress :: Bool
lvmStripecount :: Int
toolsdir :: String
gntScripts :: [String]
htoolsProgs :: [String]
pkglibdir :: String
sharedir :: String
versionedsharedir :: String
drbdBarriers :: String
drbdNoMetaFlush :: Bool
syslogUsage :: String
daemonsGroup :: String
adminGroup :: String
masterdUser :: String
masterdGroup :: String
metadUser :: String
metadGroup :: String
rapiUser :: String
rapiGroup :: String
confdUser :: String
confdGroup :: String
wconfdUser :: String
wconfdGroup :: String
kvmdUser :: String
kvmdGroup :: String
luxidUser :: String
luxidGroup :: String
nodedUser :: String
nodedGroup :: String
mondUser :: String
mondGroup :: String
diskSeparator :: String
qemuimgPath :: String
htools :: Bool
xenCmd :: String
enableRestrictedCommands :: Bool
enableMond :: Bool
enableMetad :: Bool
hasGnuLn :: Bool
manPages :: [(String, Int)]
pyAfInet4 :: Int
pyAfInet6 :: Int


-- | Unittests for <tt>AutoConf</tt>
module Test.AutoConf

-- | 'isFilePath x' tests whether <tt>x</tt> is a valid filepath
--   
--   A valid filepath must be absolute and must not contain commas.
isFilePath :: String -> Bool

-- | 'isGntScript x' tests whether <tt>x</tt> is a valid Ganeti script
--   
--   A valid Ganeti script is prefixed by <a>gnt-</a> and the rest of the
--   <a>String</a> contains only alphabetic <a>Char</a>s.
isGntScript :: String -> Bool

-- | 'isGroup x' tests whether <tt>x</tt> is a valid group name
--   
--   A valid group name name is an alphabetic <a>String</a> possibly
--   containing <a>-</a>.
isGroup :: String -> Bool

-- | 'isProgram x' tests whether <tt>x</tt> is a valid program name
--   
--   A valid program name is an alphabetic <a>String</a>.
isProgram :: String -> Bool

-- | 'isUser x' tests whether <tt>x</tt> is a valid username
--   
--   See <a>isGroup</a>.
isUser :: String -> Bool
case_versionSuffix :: Assertion
case_localstatedir :: Assertion
case_sysconfdir :: Assertion
case_sshConfigDir :: Assertion
case_sshLoginUser :: Assertion
case_sshConsoleUser :: Assertion
case_exportDir :: Assertion
case_osSearchPath :: Assertion
case_esSearchPath :: Assertion
case_xenBootloader :: Assertion
case_xenConfigDir :: Assertion
case_xenKernel :: Assertion
case_xenInitrd :: Assertion
case_kvmKernel :: Assertion
case_iallocatorSearchPath :: Assertion
case_kvmPath :: Assertion
case_ipPath :: Assertion
case_socatPath :: Assertion
case_toolsdir :: Assertion
case_gntScripts :: Assertion
case_htoolsProgs :: Assertion
case_pkglibdir :: Assertion
case_sharedir :: Assertion
case_versionedsharedir :: Assertion
case_drbdBarriers :: Assertion
case_syslogUsage :: Assertion
case_daemonsGroup :: Assertion
case_adminGroup :: Assertion
case_masterdUser :: Assertion
case_masterdGroup :: Assertion
case_rapiUser :: Assertion
case_rapiGroup :: Assertion
case_confdUser :: Assertion
case_confdGroup :: Assertion
case_luxidUser :: Assertion
case_luxidGroup :: Assertion
case_nodedUser :: Assertion
case_nodedGroup :: Assertion
case_mondUser :: Assertion
case_mondGroup :: Assertion
case_diskSeparator :: Assertion
case_qemuimgPath :: Assertion
testAutoConf :: Test


-- | Implements multi-maps - maps that map keys to sets of values
--   
--   This module uses the standard naming convention as other
--   collection-like libraries and is meant to be imported qualified.
module Ganeti.Utils.MultiMap

-- | A multi-map that contains multiple values for a single key. It doesn't
--   distinguish non-existent keys and keys with the empty set as the
--   value.
newtype MultiMap k v
MultiMap :: Map k (Set v) -> MultiMap k v
getMultiMap :: MultiMap k v -> Map k (Set v)

-- | Creates a multi-map from a map of sets.
multiMap :: (Ord k, Ord v) => Map k (Set v) -> MultiMap k v

-- | A <a>Lens</a> that allows to access a set under a given key in a
--   multi-map.
multiMapL :: (Ord k, Ord v) => k -> Lens' (MultiMap k v) (Set v)

-- | Return the set corresponding to a given key.
lookup :: (Ord k, Ord v) => k -> MultiMap k v -> Set v

-- | Tests if the given key has a non-empty set of values.
member :: (Ord k, Ord v) => k -> MultiMap k v -> Bool

-- | Tries to find a key corresponding to a given value.
findValue :: (Ord k, Ord v) => v -> MultiMap k v -> Maybe k

-- | Returns <a>True</a> iff a given value is present in a set of some key.
elem :: (Ord k, Ord v) => v -> MultiMap k v -> Bool
null :: MultiMap k v -> Bool
insert :: (Ord k, Ord v) => k -> v -> MultiMap k v -> MultiMap k v
fromList :: (Ord k, Ord v) => [(k, v)] -> MultiMap k v
delete :: (Ord k, Ord v) => k -> v -> MultiMap k v -> MultiMap k v
deleteAll :: (Ord k, Ord v) => k -> MultiMap k v -> MultiMap k v
values :: (Ord k, Ord v) => MultiMap k v -> Set v

-- | A <a>Lens</a> that allows to access a given value/key pair in a
--   multi-map.
--   
--   It is similar to the <a>At</a> instance, but uses more convenient
--   <a>Bool</a> instead of 'Maybe ()' and a pair key/value.
multiMapValueL :: (Ord k, Ord v) => k -> v -> Lens' (MultiMap k v) Bool
instance (Eq k, Eq v) => Eq (MultiMap k v)
instance (Ord k, Ord v) => Ord (MultiMap k v)
instance (Show k, Show v) => Show (MultiMap k v)
instance (JSON k, Ord k, JSON v, Ord v) => JSON (MultiMap k v)
instance Foldable (MultiMap k)
instance (Ord v, Ord k) => Monoid (MultiMap k v)


-- | Path-related helper functions.
module Ganeti.Path
pjoin :: IO String -> String -> IO String
getRootDir :: IO FilePath
addNodePrefix :: FilePath -> IO FilePath

-- | Directory for data.
dataDir :: IO FilePath
dataDirP :: FilePath -> IO FilePath

-- | Directory for runtime files.
runDir :: IO FilePath

-- | Directory for log files.
logDir :: IO FilePath

-- | Directory for Unix sockets.
socketDir :: IO FilePath

-- | Directory for the jobs' livelocks.
livelockDir :: IO FilePath

-- | Directory for luxid to write messages to running jobs, like requests
--   to change the priority.
luxidMessageDir :: IO FilePath

-- | A helper for building a job's livelock file. It prepends
--   <a>livelockDir</a> to a given filename.
livelockFile :: FilePath -> IO FilePath

-- | The default LUXI socket for queries.
defaultQuerySocket :: IO FilePath

-- | The default WConfD socket for queries.
defaultWConfdSocket :: IO FilePath

-- | The default MetaD socket for communication.
defaultMetadSocket :: IO FilePath

-- | Path to file containing confd's HMAC key.
confdHmacKey :: IO FilePath

-- | Path to cluster configuration file.
clusterConfFile :: IO FilePath

-- | Path to the file representing the lock status.
lockStatusFile :: IO FilePath

-- | Path to the file representing the lock status.
tempResStatusFile :: IO FilePath

-- | Path to the watcher pause file.
watcherPauseFile :: IO FilePath

-- | Path to the noded certificate.
nodedCertFile :: IO FilePath

-- | Path to the noded client certificate.
nodedClientCertFile :: IO FilePath

-- | Job queue directory.
queueDir :: IO FilePath

-- | Job queue serial file.
jobQueueSerialFile :: IO FilePath

-- | Job queue lock file
jobQueueLockFile :: IO FilePath

-- | Job queue drain file
jobQueueDrainFile :: IO FilePath

-- | Job queue archive directory.
jobQueueArchiveSubDir :: FilePath

-- | Directory containing the reason trails for the last change of status
--   of instances.
instanceReasonDir :: IO FilePath

-- | The path of the file containing the reason trail for an instance,
--   given the instance name.
getInstReasonFilename :: String -> IO FilePath

-- | The path to the Python executable for starting jobs.
jqueueExecutorPy :: IO FilePath


-- | Crypto-related helper functions.
module Ganeti.Hash

-- | Type alias for the hash key. This depends on the library being used.
type HashKey = [Word8]
stringToWord8 :: String -> HashKey
word8ToString :: HashKey -> String

-- | Computes the HMAC for a given key/test and salt.
computeMac :: HashKey -> Maybe String -> String -> String

-- | Verifies the HMAC for a given message.
verifyMac :: HashKey -> Maybe String -> String -> String -> Bool


-- | Compatibility helper module.
--   
--   This module holds definitions that help with supporting multiple
--   library versions or transitions between versions.
module Ganeti.Compat

-- | Wrapper over the function exported from
--   <a>Control.Parallel.Strategies</a>.
--   
--   This wraps either the old or the new name of the function, depending
--   on the detected library version.
rwhnf :: Strategy a
finiteBitSize :: Bits a => a -> Int


-- | Auto-generated module holding version information.
module Ganeti.Version

-- | The version of the sources.
version :: String


-- | Provides interface to the <tt>zlib</tt> library.
module Ganeti.Codec

-- | Compresses a lazy bytestring.
compressZlib :: ByteString -> ByteString

-- | Decompresses a lazy bytestring, throwing decoding errors using
--   <a>throwError</a>.
decompressZlib :: (MonadError e m, Error e) => ByteString -> m ByteString

module Ganeti.BasicTypes

-- | Generic monad for our error handling mechanisms.
data GenericResult a b
Bad :: a -> GenericResult a b
Ok :: b -> GenericResult a b

-- | Sum type structure of GenericResult.
genericResult :: (a -> c) -> (b -> c) -> GenericResult a b -> c

-- | Type alias for a string Result.
type Result = GenericResult String

-- | This is a monad transformation for Result. It's implementation is
--   based on the implementations of MaybeT and ErrorT.
--   
--   <a>ResultT</a> is very similar to <tt>ErrorT</tt>, but with one subtle
--   difference: If <a>mplus</a> combines two failing operations, errors of
--   both of them are combined.
newtype ResultT a m b
ResultT :: m (GenericResult a b) -> ResultT a m b
runResultT :: ResultT a m b -> m (GenericResult a b)
elimResultT :: Monad m => (a -> ResultT a' m b') -> (b -> ResultT a' m b') -> ResultT a m b -> ResultT a' m b'

-- | Changes the error message of a result value, if present. Note that
--   since <a>GenericResult</a> is also a <a>MonadError</a>, this function
--   is a generalization of <tt>(Error e') =&gt; (e' -&gt; e) -&gt;
--   GenericResult e' a -&gt; GenericResult e a</tt>
withError :: MonadError e m => (e' -> e) -> GenericResult e' a -> m a

-- | Changes the error message of a <tt>ResultT</tt> value, if present.
withErrorT :: (Monad m, Error e) => (e' -> e) -> ResultT e' m a -> ResultT e m a

-- | Lift a <a>Result</a> value to any <a>MonadError</a>. Since
--   <a>ResultT</a> is itself its instance, it's a generalization of
--   <tt>Monad m =&gt; GenericResult a b -&gt; ResultT a m b</tt>.
toError :: MonadError e m => GenericResult e a -> m a

-- | Lift a <a>ResultT</a> value into any <a>MonadError</a> with the same
--   base monad.
toErrorBase :: (MonadBase b m, MonadError e m) => ResultT e b a -> m a

-- | An alias for <tt>withError strMsg</tt>, which is often used to lift a
--   pure error to a monad stack. See also <a>annotateResult</a>.
toErrorStr :: (MonadError e m, Error e) => Result a -> m a

-- | Run a given computation and if an error occurs, return it as
--   <a>Left</a> of <a>Either</a>. This is a generalized version of
--   <a>try</a>.
tryError :: MonadError e m => m a -> m (Either e a)

-- | Converts a monadic result with a <a>String</a> message into a
--   <a>ResultT</a> with an arbitrary <a>Error</a>.
--   
--   Expects that the given action has already taken care of any possible
--   errors. In particular, if applied on <tt>IO (Result a)</tt>, any
--   exceptions should be handled by the given action.
--   
--   See also <a>toErrorStr</a>.
mkResultT :: (Monad m, Error e) => m (Result a) -> ResultT e m a

-- | Simple checker for whether a <a>GenericResult</a> is OK.
isOk :: GenericResult a b -> Bool

-- | Simple checker for whether a <a>GenericResult</a> is a failure.
isBad :: GenericResult a b -> Bool

-- | Simple filter returning only OK values of GenericResult
justOk :: [GenericResult a b] -> [b]

-- | Simple filter returning only Bad values of GenericResult
justBad :: [GenericResult a b] -> [a]

-- | Converter from Either to <a>GenericResult</a>.
eitherToResult :: Either a b -> GenericResult a b

-- | Check if an either is Left. Equivalent to isLeft from Data.Either
--   version 4.7.0.0 or higher.
isLeft :: Either a b -> Bool

-- | Check if an either is Right. Equivalent to isRight from Data.Either
--   version 4.7.0.0 or higher.
isRight :: Either a b -> Bool

-- | Annotate an error with an ownership information, lifting it to a
--   <a>MonadError</a>. Since <a>Result</a> is an instance of
--   <a>MonadError</a> itself, it's a generalization of type <tt>String
--   -&gt; Result a -&gt; Result a</tt>. See also <a>toErrorStr</a>.
annotateResult :: (MonadError e m, Error e) => String -> Result a -> m a

-- | Annotate an error with an ownership information inside a
--   <a>MonadError</a>. See also <a>annotateResult</a>.
annotateError :: (MonadError e m, Error e, Monoid e) => String -> m a -> m a

-- | Throws a <a>String</a> message as an error in a <a>MonadError</a>.
--   This is a generalization of <a>Bad</a>. It's similar to <a>fail</a>,
--   but works within a <a>MonadError</a>, avoiding the unsafe nature of
--   <a>fail</a>.
failError :: (MonadError e m, Error e) => String -> m a

-- | A synonym for <tt>flip</tt> <a>catchErrorT</a>.
handleErrorT :: (Monad m, Error e) => (e' -> ResultT e m a) -> ResultT e' m a -> ResultT e m a

-- | Catches an error in a <tt>ResultT</tt> value. This is similar to
--   <a>catchError</a>, but in addition allows to change the error type.
catchErrorT :: (Monad m, Error e) => ResultT e' m a -> (e' -> ResultT e m a) -> ResultT e m a

-- | If the first computation fails, run the second one. Unlike
--   <a>mplus</a> instance for <a>ResultT</a>, this doesn't require the
--   <a>Monoid</a> constrait.
orElse :: MonadError e m => m a -> m a -> m a

-- | Iterate while Ok.
iterateOk :: (a -> GenericResult b a) -> a -> [a]

-- | Return the first result with a True condition, or the default
--   otherwise.
select :: a -> [(Bool, a)] -> a

-- | Apply a function to the first element of a list, return the default
--   value, if the list is empty. This is just a convenient combination of
--   maybe and listToMaybe.
runListHead :: a -> (b -> a) -> [b] -> a

-- | The priority of a match in a lookup result.
data MatchPriority
ExactMatch :: MatchPriority
MultipleMatch :: MatchPriority
PartialMatch :: MatchPriority
FailMatch :: MatchPriority

-- | The result of a name lookup in a list.
data LookupResult
LookupResult :: MatchPriority -> String -> LookupResult

-- | The result type | Matching value (for ExactMatch, PartialMatch),
--   Lookup string otherwise
lrMatchPriority :: LookupResult -> MatchPriority
lrContent :: LookupResult -> String

-- | Check for prefix matches in names. Implemented in Ganeti core
--   utils.text.MatchNameComponent as the regexp r<a>^%s(..*)?$</a> %
--   re.escape(key)
prefixMatch :: String -> String -> Bool

-- | Is the lookup priority a <a>good</a> one?
goodMatchPriority :: MatchPriority -> Bool

-- | Is the lookup result an actual match?
goodLookupResult :: LookupResult -> Bool

-- | Compares a canonical name and a lookup string.
compareNameComponent :: String -> String -> LookupResult
chooseLookupResult :: String -> String -> LookupResult -> LookupResult

-- | Find the canonical name for a lookup string in a list of names.
lookupName :: [String] -> String -> LookupResult

-- | Wrapper for a Haskell <a>Set</a>
--   
--   This type wraps a <a>Set</a> and it is used in the Haskell to Python
--   opcode generation to transform a Haskell <a>Set</a> into a Python
--   <tt>list</tt> without duplicate elements.
newtype ListSet a
ListSet :: Set a -> ListSet a
unListSet :: ListSet a -> Set a
emptyListSet :: ListSet a
instance (Show a, Show b) => Show (GenericResult a b)
instance (Eq a, Eq b) => Eq (GenericResult a b)
instance Functor m => Functor (ResultT a m)
instance Show MatchPriority
instance Enum MatchPriority
instance Eq MatchPriority
instance Ord MatchPriority
instance Show LookupResult
instance Eq a => Eq (ListSet a)
instance Show a => Show (ListSet a)
instance Ord a => Ord (ListSet a)
instance (Ord a, JSON a) => JSON (ListSet a)
instance Ord LookupResult
instance Eq LookupResult
instance (Alternative m, Monad m, Error a, Monoid a) => Alternative (ResultT a m)
instance (Monad m, Error a, Monoid a) => MonadPlus (ResultT a m)
instance (Error a, MonadBaseControl IO m) => MonadBaseControl IO (ResultT a m)
instance Error a => MonadTransControl (ResultT a)
instance (MonadBase IO m, Error a) => MonadBase IO (ResultT a m)
instance (MonadIO m, Error a) => MonadIO (ResultT a m)
instance MonadTrans (ResultT a)
instance (Monad m, Error a) => MonadError a (ResultT a m)
instance (Monad m, Error a) => Monad (ResultT a m)
instance (Applicative m, Monad m, Error a) => Applicative (ResultT a m)
instance (Error a, Monoid a) => Alternative (GenericResult a)
instance Applicative (GenericResult a)
instance Error a => MonadError a (GenericResult a)
instance (Error a, Monoid a) => MonadPlus (GenericResult a)
instance Functor (GenericResult a)
instance Error a => Monad (GenericResult a)


-- | JSON utility functions.
module Ganeti.JSON
type JSField = (String, JSValue)

-- | A type alias for the list-based representation of J.JSObject.
type JSRecord = [JSField]

-- | Annotate <tt>readJSON</tt> error messages with descriptions of what is
--   being parsed into what.
readJSONWithDesc :: JSON a => String -> Bool -> JSValue -> Result a

-- | Converts a JSON Result into a monadic value.
fromJResult :: Monad m => String -> Result a -> m a

-- | Converts a JSON Result into a MonadError value.
fromJResultE :: (Error e, MonadError e m) => String -> Result a -> m a

-- | Tries to read a string from a JSON value.
--   
--   In case the value was not a string, we fail the read (in the context
--   of the current monad.
readEitherString :: Monad m => JSValue -> m String

-- | Converts a JSON message into an array of JSON objects.
loadJSArray :: Monad m => String -> String -> m [JSObject JSValue]
buildNoKeyError :: JSRecord -> String -> String

-- | Reads the value of a key in a JSON object.
fromObj :: (JSON a, Monad m) => JSRecord -> String -> m a

-- | Reads the value of an optional key in a JSON object. Missing keys, or
--   keys that have a 'null' value, will be returned as <a>Nothing</a>,
--   otherwise we attempt deserialisation and return a <a>Just</a> value.
maybeFromObj :: (JSON a, Monad m) => JSRecord -> String -> m (Maybe a)

-- | Reads the value of a key in a JSON object with a default if missing.
--   Note that both missing keys and keys with value 'null' will cause the
--   default value to be returned.
fromObjWithDefault :: (JSON a, Monad m) => JSRecord -> String -> a -> m a
arrayMaybeFromJVal :: (JSON a, Monad m) => JSValue -> m [Maybe a]
arrayMaybeFromObj :: (JSON a, Monad m) => JSRecord -> String -> m [Maybe a]

-- | Wrapper for arrayMaybeFromObj with better diagnostic
tryArrayMaybeFromObj :: JSON a => String -> JSRecord -> String -> Result [Maybe a]

-- | Reads a JValue, that originated from an object key.
fromKeyValue :: (JSON a, Monad m) => String -> JSValue -> m a

-- | Small wrapper over readJSON.
fromJVal :: (Monad m, JSON a) => JSValue -> m a

-- | Small wrapper over <tt>readJSON</tt> for <a>MonadError</a>.
fromJValE :: (Error e, MonadError e m, JSON a) => JSValue -> m a

-- | Helper function that returns Null or first element of the list.
jsonHead :: JSON b => [a] -> (a -> b) -> JSValue

-- | Helper for extracting Maybe values from a possibly empty list.
getMaybeJsonHead :: JSON b => [a] -> (a -> Maybe b) -> JSValue

-- | Helper for extracting Maybe values from a list that might be too
--   short.
getMaybeJsonElem :: JSON b => [a] -> Int -> (a -> Maybe b) -> JSValue

-- | Converts a JSON value into a JSON object.
asJSObject :: Monad m => JSValue -> m (JSObject JSValue)

-- | Coneverts a list of JSON values into a list of JSON objects.
asObjectList :: Monad m => [JSValue] -> m [JSObject JSValue]

-- | Try to extract a key from an object with better error reporting than
--   fromObj.
tryFromObj :: JSON a => String -> JSRecord -> String -> Result a

-- | Ensure a given JSValue is actually a JSArray.
toArray :: Monad m => JSValue -> m [JSValue]

-- | Creates a Maybe JSField. If the value string is Nothing, the JSField
--   will be Nothing as well.
optionalJSField :: JSON a => String -> Maybe a -> Maybe JSField

-- | Creates an object with all the non-Nothing fields of the given list.
optFieldsToObj :: [Maybe JSField] -> JSValue

-- | Class of types that can be converted from Strings. This is similar to
--   the <a>Read</a> class, but it's using a different serialisation
--   format, so we have to define a separate class. Mostly useful for
--   custom key types in JSON dictionaries, which have to be backed by
--   strings.
class HasStringRepr a
fromStringRepr :: (HasStringRepr a, Monad m) => String -> m a
toStringRepr :: HasStringRepr a => a -> String

-- | The container type, a wrapper over Data.Map
newtype GenericContainer a b
GenericContainer :: Map a b -> GenericContainer a b
fromContainer :: GenericContainer a b -> Map a b

-- | The empty container.
emptyContainer :: GenericContainer a b

-- | Type alias for string keys.
type Container = GenericContainer String

-- | Creates a GenericContainer from a list of key-value pairs.
containerFromList :: Ord a => [(a, b)] -> GenericContainer a b

-- | Looks up a value in a container with a default value. If a key has no
--   value, a given monadic default is returned. This allows simple error
--   handling, as the default can be <a>mzero</a>, <a>failError</a> etc.
lookupContainer :: (Monad m, Ord a) => m b -> a -> GenericContainer a b -> m b

-- | Updates a value inside a container. The signature of the function is
--   crafted so that it can be directly used as a lens.
alterContainerL :: (Functor f, Ord a) => a -> (Maybe b -> f (Maybe b)) -> GenericContainer a b -> f (GenericContainer a b)

-- | Container loader.
readContainer :: (Monad m, HasStringRepr a, Ord a, JSON b) => JSObject JSValue -> m (GenericContainer a b)
showContainer :: (HasStringRepr a, JSON b) => GenericContainer a b -> JSValue
newtype UsedKeys
UsedKeys :: (Maybe (Set String)) -> UsedKeys
mkUsedKeys :: Set String -> UsedKeys
allUsedKeys :: UsedKeys

-- | Class of objects that can be converted from and to <tt>JSObject</tt>
--   lists-format.
class DictObject a where fromDict = liftM fst . runWriterT . fromDictWKeys
toDict :: DictObject a => a -> [(String, JSValue)]
fromDictWKeys :: DictObject a => [(String, JSValue)] -> WriterT UsedKeys Result a
fromDict :: DictObject a => [(String, JSValue)] -> Result a

-- | A default implementation of <tt>showJSON</tt> using <a>toDict</a>.
showJSONtoDict :: DictObject a => a -> JSValue

-- | A default implementation of <tt>readJSON</tt> using <a>fromDict</a>.
--   Checks that the input value is a JSON object and converts it using
--   <a>fromDict</a>. Also checks the input contains only the used keys
--   returned by <a>fromDict</a>.
readJSONfromDict :: DictObject a => JSValue -> Result a

-- | Class of objects that can be converted from and to <tt>[JSValue]</tt>
--   with a fixed length and order.
class ArrayObject a
toJSArray :: ArrayObject a => a -> [JSValue]
fromJSArray :: ArrayObject a => [JSValue] -> Result a

-- | A Maybe newtype that allows for serialization more appropriate to the
--   semantics of Maybe and JSON in our calls. Does not produce needless
--   and confusing dictionaries.
--   
--   In particular, <a>JSNull</a> corresponds to <a>Nothing</a>. This also
--   means that this `Maybe a` newtype should not be used with <tt>a</tt>
--   values that themselves can serialize to <a>null</a>.
newtype MaybeForJSON a
MaybeForJSON :: Maybe a -> MaybeForJSON a
unMaybeForJSON :: MaybeForJSON a -> Maybe a
newtype TimeAsDoubleJSON
TimeAsDoubleJSON :: ClockTime -> TimeAsDoubleJSON
unTimeAsDoubleJSON :: TimeAsDoubleJSON -> ClockTime
newtype Tuple5 a b c d e
Tuple5 :: (a, b, c, d, e) -> Tuple5 a b c d e
unTuple5 :: Tuple5 a b c d e -> (a, b, c, d, e)

-- | Look up a value in a JSON object. Accessing <tt>[<a>a</a>, <a>b</a>,
--   <a>c</a>]</tt> on an object is equivalent as accessing
--   <tt>myobject.a.b.c</tt> on a JavaScript object.
--   
--   An error is returned if the object doesn't have such an accessor or if
--   any value during the nested access is not an object at all.
nestedAccessByKey :: [String] -> JSValue -> Result JSValue

-- | Same as <a>nestedAccessByKey</a>, but accessing with a dotted string
--   instead (like <tt>nestedAccessByKeyDotted <a>a.b.c</a></tt>).
nestedAccessByKeyDotted :: String -> JSValue -> Result JSValue

-- | Branch decoding on a field in a JSON object.
branchOnField :: String -> (JSValue -> Result a) -> (JSValue -> Result a) -> JSValue -> Result a

-- | Add a field to a JSON object; to nothing, if the argument is not an
--   object.
addField :: (String, JSValue) -> JSValue -> JSValue
instance (Show a, Show b) => Show (GenericContainer a b)
instance (Eq a, Eq b) => Eq (GenericContainer a b)
instance (Ord a, Ord b) => Ord (GenericContainer a b)
instance Functor (GenericContainer a)
instance Foldable (GenericContainer a)
instance Traversable (GenericContainer a)
instance Show a => Show (MaybeForJSON a)
instance Eq a => Eq (MaybeForJSON a)
instance Ord a => Ord (MaybeForJSON a)
instance Show TimeAsDoubleJSON
instance Eq TimeAsDoubleJSON
instance Ord TimeAsDoubleJSON
instance (JSON a, JSON b, JSON c, JSON d, JSON e) => JSON (Tuple5 a b c d e)
instance JSON TimeAsDoubleJSON
instance JSON a => JSON (MaybeForJSON a)
instance Monoid UsedKeys
instance (HasStringRepr a, Ord a, JSON b) => JSON (GenericContainer a b)
instance (NFData a, NFData b) => NFData (GenericContainer a b)
instance HasStringRepr String
instance NFData a => NFData (JSObject a)
instance NFData JSValue


-- | DRBD Data Types
--   
--   This module holds the definition of the data types describing the
--   status of DRBD.
module Ganeti.Storage.Drbd.Types

-- | Data type contaning all the data about the status of DRBD.
data DRBDStatus
DRBDStatus :: VersionInfo -> [DeviceInfo] -> DRBDStatus

-- | Version information about DRBD
versionInfo :: DRBDStatus -> VersionInfo

-- | Per-minor information
deviceInfos :: DRBDStatus -> [DeviceInfo]

-- | Data type describing the DRBD version.
data VersionInfo
VersionInfo :: Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> VersionInfo

-- | DRBD driver version
version :: VersionInfo -> Maybe String

-- | The api version
api :: VersionInfo -> Maybe String

-- | The protocol version
proto :: VersionInfo -> Maybe String

-- | The version of the source files
srcversion :: VersionInfo -> Maybe String

-- | Git hash of the source files
gitHash :: VersionInfo -> Maybe String

-- | Who built the binary (and, optionally, when)
buildBy :: VersionInfo -> Maybe String

-- | Data type describing a device.
data DeviceInfo

-- | An DRBD minor marked as unconfigured
UnconfiguredDevice :: Int -> DeviceInfo

-- | A configured DRBD minor
DeviceInfo :: Int -> ConnState -> LocalRemote Role -> LocalRemote DiskState -> Char -> String -> PerfIndicators -> Maybe SyncStatus -> Maybe AdditionalInfo -> Maybe AdditionalInfo -> Maybe String -> DeviceInfo

-- | The minor index of the device
minorNumber :: DeviceInfo -> Int

-- | State of the connection
connectionState :: DeviceInfo -> ConnState

-- | Roles of the resources
resourceRoles :: DeviceInfo -> LocalRemote Role

-- | Status of the disks
diskStates :: DeviceInfo -> LocalRemote DiskState

-- | The replication protocol being used
replicationProtocol :: DeviceInfo -> Char

-- | The input/output flags
ioFlags :: DeviceInfo -> String

-- | Performance indicators
perfIndicators :: DeviceInfo -> PerfIndicators

-- | The status of the syncronization of the disk (only if it is happening)
syncStatus :: DeviceInfo -> Maybe SyncStatus

-- | Additional info by DRBD 8.0
resync :: DeviceInfo -> Maybe AdditionalInfo

-- | Additional info by DRBD 8.0
actLog :: DeviceInfo -> Maybe AdditionalInfo

-- | The name of the associated instance
instName :: DeviceInfo -> Maybe String

-- | Data type describing the state of the connection.
data ConnState

-- | No network configuration available
StandAlone :: ConnState

-- | Temporary state during disconnection
Disconnecting :: ConnState

-- | Prior to a connection attempt
Unconnected :: ConnState

-- | Following a timeout in the communication
Timeout :: ConnState

-- | After the connection to the peer was lost
BrokenPipe :: ConnState

-- | After the connection to the partner was lost
NetworkFailure :: ConnState

-- | After the connection to the partner was lost
ProtocolError :: ConnState

-- | The peer is closing the connection
TearDown :: ConnState

-- | Waiting for the peer to become visible
WFConnection :: ConnState

-- | Waiting for first packet from peer
WFReportParams :: ConnState

-- | Connected, data mirroring active
Connected :: ConnState

-- | Source of a full sync started by admin
StartingSyncS :: ConnState

-- | Target of a full sync started by admin
StartingSyncT :: ConnState

-- | Source of a just starting partial sync
WFBitMapS :: ConnState

-- | Target of a just starting partial sync
WFBitMapT :: ConnState

-- | Synchronization is about to begin
WFSyncUUID :: ConnState

-- | Source of a running synchronization
SyncSource :: ConnState

-- | Target of a running synchronization
SyncTarget :: ConnState

-- | Source of a paused synchronization
PausedSyncS :: ConnState

-- | Target of a paused synchronization
PausedSyncT :: ConnState

-- | Source of a running verification
VerifyS :: ConnState

-- | Target of a running verification
VerifyT :: ConnState

-- | The device is not configured
Unconfigured :: ConnState

-- | Algebraic data type describing something that has a local and a remote
--   value.
data LocalRemote a
LocalRemote :: a -> a -> LocalRemote a

-- | The local value
local :: LocalRemote a -> a

-- | The remote value
remote :: LocalRemote a -> a

-- | Data type describing.
data Role

-- | The device role is primary
Primary :: Role

-- | The device role is secondary
Secondary :: Role

-- | The device role is unknown
Unknown :: Role

-- | Data type describing disk states.
data DiskState

-- | No local block device assigned to the DRBD driver
Diskless :: DiskState

-- | Reading meta data
Attaching :: DiskState

-- | I/O failure
Failed :: DiskState

-- | <a>Attach</a> on an already-connected device
Negotiating :: DiskState

-- | The data is inconsistent between nodes.
Inconsistent :: DiskState

-- | Data consistent but outdated
Outdated :: DiskState

-- | No network connection available
DUnknown :: DiskState

-- | Consistent data, but without network connection
Consistent :: DiskState

-- | Consistent, up-to-date. This is the normal state
UpToDate :: DiskState

-- | Data type containing data about performance indicators.
data PerfIndicators
PerfIndicators :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Maybe Int -> Maybe Char -> Maybe Int -> PerfIndicators

-- | KiB of data sent on the network
networkSend :: PerfIndicators -> Int

-- | KiB of data received from the network
networkReceive :: PerfIndicators -> Int

-- | KiB of data written on local disk
diskWrite :: PerfIndicators -> Int

-- | KiB of data read from local disk
diskRead :: PerfIndicators -> Int

-- | Number of updates of the activity log
activityLog :: PerfIndicators -> Int

-- | Number of updates to the bitmap area of the metadata
bitMap :: PerfIndicators -> Int

-- | Number of open requests to the local I/O subsystem
localCount :: PerfIndicators -> Int

-- | Num of requests sent to the partner but not yet answered
pending :: PerfIndicators -> Int

-- | Num of requests received by the partner but still to be answered
unacknowledged :: PerfIndicators -> Int

-- | Num of block I/O requests forwarded to DRBD but that have not yet been
--   answered
applicationPending :: PerfIndicators -> Int

-- | Number of epoch objects
epochs :: PerfIndicators -> Maybe Int

-- | Currently used write ordering method
writeOrder :: PerfIndicators -> Maybe Char

-- | KiB of storage currently out of sync
outOfSync :: PerfIndicators -> Maybe Int

-- | Data type containing data about the synchronization status of a
--   device.
data SyncStatus
SyncStatus :: Double -> Int -> Int -> SizeUnit -> Time -> Int -> Maybe Int -> SizeUnit -> TimeUnit -> SyncStatus

-- | Percentage of syncronized data
percentage :: SyncStatus -> Double

-- | Numerator of the fraction of synced data
partialSyncSize :: SyncStatus -> Int

-- | Denominator of the fraction of synced data
totalSyncSize :: SyncStatus -> Int

-- | Measurement unit of the previous fraction
syncUnit :: SyncStatus -> SizeUnit

-- | Expected time before finishing the syncronization
timeToFinish :: SyncStatus -> Time

-- | Speed of the syncronization
speed :: SyncStatus -> Int

-- | Want of the syncronization
want :: SyncStatus -> Maybe Int

-- | Size unit of the speed
speedSizeUnit :: SyncStatus -> SizeUnit

-- | Time unit of the speed
speedTimeUnit :: SyncStatus -> TimeUnit

-- | Data type describing a size unit for memory.
data SizeUnit
KiloByte :: SizeUnit
MegaByte :: SizeUnit

-- | Data type describing a time (hh:mm:ss).
data Time
Time :: Int -> Int -> Int -> Time
hour :: Time -> Int
min :: Time -> Int
sec :: Time -> Int

-- | Data type describing a time unit.
data TimeUnit
Second :: TimeUnit

-- | Additional device-specific cache-like information produced by drbd
--   &lt;= 8.0.
--   
--   Internal debug information exported by old DRBD versions. Undocumented
--   both in DRBD and here.
data AdditionalInfo
AdditionalInfo :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> AdditionalInfo
partialUsed :: AdditionalInfo -> Int
totalUsed :: AdditionalInfo -> Int
hits :: AdditionalInfo -> Int
misses :: AdditionalInfo -> Int
starving :: AdditionalInfo -> Int
dirty :: AdditionalInfo -> Int
changed :: AdditionalInfo -> Int

-- | Data type representing the pairing of a DRBD minor with an instance.
data DrbdInstMinor
DrbdInstMinor :: String -> Int -> String -> String -> String -> String -> DrbdInstMinor
dimNode :: DrbdInstMinor -> String
dimMinor :: DrbdInstMinor -> Int
dimInstName :: DrbdInstMinor -> String
dimDiskIdx :: DrbdInstMinor -> String
dimRole :: DrbdInstMinor -> String
dimPeer :: DrbdInstMinor -> String
instance Eq VersionInfo
instance Show VersionInfo
instance Show ConnState
instance Eq ConnState
instance Eq a => Eq (LocalRemote a)
instance Show a => Show (LocalRemote a)
instance Eq Role
instance Show Role
instance Eq DiskState
instance Show DiskState
instance Eq PerfIndicators
instance Show PerfIndicators
instance Eq SizeUnit
instance Show SizeUnit
instance Eq Time
instance Show Time
instance Eq TimeUnit
instance Show TimeUnit
instance Eq SyncStatus
instance Show SyncStatus
instance Eq AdditionalInfo
instance Show AdditionalInfo
instance Eq DeviceInfo
instance Show DeviceInfo
instance Eq DRBDStatus
instance Show DRBDStatus
instance Show DrbdInstMinor
instance JSON DrbdInstMinor
instance JSON TimeUnit
instance JSON Time
instance JSON SizeUnit
instance JSON SyncStatus
instance JSON PerfIndicators
instance JSON DiskState
instance JSON Role
instance JSON ConnState
instance JSON DeviceInfo
instance JSON VersionInfo
instance JSON DRBDStatus


-- | DRBD proc file parser
--   
--   This module holds the definition of the parser that extracts status
--   information from the DRBD proc file.
module Ganeti.Storage.Drbd.Parser
skipSpaces :: Parser ()
skipSpacesAndString :: Text -> Parser a -> Parser a
isBadEndOfLine :: Char -> Bool
optional :: Parser a -> Parser (Maybe a)

-- | The parser for a whole DRBD status file.
drbdStatusParser :: [DrbdInstMinor] -> Parser DRBDStatus
versionInfoParser :: Parser VersionInfo
deviceParser :: [DrbdInstMinor] -> Parser DeviceInfo
connStateParser :: Parser ConnState
localRemoteParser :: Parser a -> Parser (LocalRemote a)
roleParser :: Parser Role
diskStateParser :: Parser DiskState
ioFlagsParser :: Parser String
perfIndicatorsParser :: Parser PerfIndicators
syncStatusParser :: Parser SyncStatus
statusBarParser :: Parser ()
sizeUnitParser :: Parser SizeUnit
timeParser :: Parser Time
timeUnitParser :: Parser TimeUnit

-- | Haskell does not recognise ',' as the thousands separator every 3
--   digits but DRBD uses it, so we need an ah-hoc parser. If a number
--   beginning with more than 3 digits without a comma is parsed, only the
--   first 3 digits are considered to be valid, the rest is not consumed,
--   and left for further parsing.
commaIntParser :: Parser Int
commaIntHelper :: Int -> Parser Int
additionalInfoParser :: Parser AdditionalInfo


-- | PyValue contains instances for the <a>PyValue</a> typeclass.
--   
--   The typeclass <a>PyValue</a> converts Haskell values to Python values.
--   This module contains instances of this typeclass for several generic
--   types. These instances are used in the Haskell to Python generation of
--   opcodes and constants, for example.
module Ganeti.PyValue

-- | Converts Haskell values into Python values
--   
--   This is necessary for the default values of opcode parameters and
--   return values. For example, if a default value or return type is a
--   Data.Map, then it must be shown as a Python dictioanry.
class PyValue a where showValueList xs = "[" ++ intercalate "," (map showValue xs) ++ "]"
showValue :: PyValue a => a -> String
showValueList :: PyValue a => [a] -> String

-- | Encapsulates Python default values
data PyValueEx
PyValueEx :: a -> PyValueEx
instance PyValue PyValueEx
instance PyValue a => PyValue (ListSet a)
instance (PyValue k, PyValue a) => PyValue (Map k a)
instance PyValue a => PyValue [a]
instance (PyValue a, PyValue b, PyValue c) => PyValue (a, b, c)
instance (PyValue a, PyValue b) => PyValue (a, b)
instance PyValue Char
instance PyValue Double
instance PyValue Integer
instance PyValue Int
instance PyValue Bool


-- | ConstantUtils contains the helper functions for constants
--   
--   This module cannot be merged with <a>Utils</a> because it would create
--   a circular dependency if imported, for example, from <a>Constants</a>.
module Ganeti.ConstantUtils

-- | <a>PythonChar</a> wraps a Python <tt>char</tt>
newtype PythonChar
PythonChar :: Char -> PythonChar
unPythonChar :: PythonChar -> Char

-- | <a>PythonNone</a> wraps Python <tt>None</tt>
data PythonNone
PythonNone :: PythonNone

-- | FrozenSet wraps a Haskell <a>Set</a>
--   
--   See <a>PyValue</a> instance for <a>FrozenSet</a>.
newtype FrozenSet a
FrozenSet :: Set a -> FrozenSet a
unFrozenSet :: FrozenSet a -> Set a
mkSet :: Ord a => [a] -> FrozenSet a
toList :: FrozenSet a -> [a]
union :: Ord a => FrozenSet a -> FrozenSet a -> FrozenSet a
difference :: Ord a => FrozenSet a -> FrozenSet a -> FrozenSet a

-- | <a>Protocol</a> represents the protocols used by the daemons
data Protocol
Tcp :: Protocol
Udp :: Protocol

-- | Failure exit code
--   
--   These are defined here and not in <a>Constants</a> together with the
--   other exit codes in order to avoid a circular dependency between
--   <a>Constants</a> and <a>Runtime</a>
exitFailure :: Int

-- | Console device
--   
--   This is defined here and not in <a>Constants</a> order to avoid a
--   circular dependency between <a>Constants</a> and <a>Logging</a>
devConsole :: String

-- | Random uuid generator
--   
--   This is defined here and not in <a>Constants</a> order to avoid a
--   circular dependendy between <a>Constants</a> and <a>Types</a>
randomUuidFile :: String
priorityLow :: Int
priorityNormal :: Int
priorityHigh :: Int

-- | Calculates int version number from major, minor and revision numbers.
buildVersion :: Int -> Int -> Int -> Int

-- | Confd protocol version
--   
--   This is defined here in order to avoid a circular dependency between
--   <a>Types</a> and <a>Constants</a>.
confdProtocolVersion :: Int
confdReqqLink :: String
confdReqqIp :: String
confdReqqIplist :: String
confdReqqFields :: String
ispecMemSize :: String
ispecCpuCount :: String
ispecDiskCount :: String
ispecDiskSize :: String
ispecNicCount :: String
ispecSpindleUse :: String
ispecsMinmax :: String
ispecsStd :: String
ipolicyDts :: String
ipolicyVcpuRatio :: String
ipolicySpindleRatio :: String
ipolicyDefaultsVcpuRatio :: Double
ipolicyDefaultsSpindleRatio :: Double
instance Show PythonChar
instance Eq a => Eq (FrozenSet a)
instance Ord a => Ord (FrozenSet a)
instance Show a => Show (FrozenSet a)
instance Show Protocol
instance PyValue Protocol
instance PyValue a => PyValue (FrozenSet a)
instance PyValue PythonNone
instance PyValue PythonChar


-- | Implementation of the runtime configuration details.
module Ganeti.Runtime
data GanetiDaemon
GanetiMasterd :: GanetiDaemon
GanetiMetad :: GanetiDaemon
GanetiNoded :: GanetiDaemon
GanetiRapi :: GanetiDaemon
GanetiConfd :: GanetiDaemon
GanetiWConfd :: GanetiDaemon
GanetiKvmd :: GanetiDaemon
GanetiLuxid :: GanetiDaemon
GanetiMond :: GanetiDaemon
data MiscGroup
DaemonsGroup :: MiscGroup
AdminGroup :: MiscGroup
data GanetiGroup
DaemonGroup :: GanetiDaemon -> GanetiGroup
ExtraGroup :: MiscGroup -> GanetiGroup
data RuntimeEnts
RuntimeEnts :: Map GanetiDaemon UserID -> Map UserID String -> Map GanetiGroup GroupID -> Map GroupID String -> RuntimeEnts
reUserToUid :: RuntimeEnts -> Map GanetiDaemon UserID
reUidToUser :: RuntimeEnts -> Map UserID String
reGroupToGid :: RuntimeEnts -> Map GanetiGroup GroupID
reGidToGroup :: RuntimeEnts -> Map GroupID String

-- | Returns the daemon name for a given daemon.
daemonName :: GanetiDaemon -> String

-- | Returns whether the daemon only runs on the master node.
daemonOnlyOnMaster :: GanetiDaemon -> Bool

-- | Returns the log file base for a daemon.
daemonLogBase :: GanetiDaemon -> String

-- | Returns the configured user name for a daemon.
daemonUser :: GanetiDaemon -> String

-- | Returns the configured group for a daemon.
daemonGroup :: GanetiGroup -> String
data ExtraLogReason
AccessLog :: ExtraLogReason
ErrorLog :: ExtraLogReason

-- | Some daemons might require more than one logfile. Specifically, right
--   now only the Haskell http library <a>snap</a>, used by the monitoring
--   daemon, requires multiple log files.
daemonsExtraLogbase :: GanetiDaemon -> ExtraLogReason -> String

-- | Returns the log file for a daemon.
daemonLogFile :: GanetiDaemon -> IO FilePath

-- | Returns the extra log files for a daemon.
daemonsExtraLogFile :: GanetiDaemon -> ExtraLogReason -> IO FilePath

-- | Returns the pid file name for a daemon.
daemonPidFile :: GanetiDaemon -> IO FilePath
allGroups :: [GanetiGroup]

-- | Computes the group/user maps.
getEnts :: Error e => ResultT e IO RuntimeEnts

-- | Checks whether a daemon runs as the right user.
verifyDaemonUser :: GanetiDaemon -> RuntimeEnts -> IO ()
checkUidMatch :: String -> UserID -> UserID -> IO ()
instance Show GanetiDaemon
instance Enum GanetiDaemon
instance Bounded GanetiDaemon
instance Eq GanetiDaemon
instance Ord GanetiDaemon
instance Show MiscGroup
instance Enum MiscGroup
instance Bounded MiscGroup
instance Eq MiscGroup
instance Ord MiscGroup
instance Show GanetiGroup
instance Eq GanetiGroup
instance Ord GanetiGroup


-- | PyType helper for Ganeti Haskell code.
module Ganeti.THH.PyType

-- | Represents a Python encoding of types.
data PyType
PTMaybe :: PyType -> PyType
PTApp :: PyType -> [PyType] -> PyType
PTOther :: String -> PyType
PTAny :: PyType
PTDictOf :: PyType
PTListOf :: PyType
PTNone :: PyType
PTObject :: PyType
PTOr :: PyType
PTSetOf :: PyType
PTTupleOf :: PyType
ht :: String -> String
ptApp :: String -> [PyType] -> String
pyTypeName :: Name -> PyType

-- | Converts a Haskell type into a Python type.
pyType :: Type -> Q PyType
pyAppType :: Type -> (Type, [Type])

-- | <tt>pyType opt typ</tt> converts Haskell type <tt>typ</tt> into a
--   Python type, where <tt>opt</tt> determines if the converted type is
--   optional (i.e., Maybe).
pyOptionalType :: Bool -> Type -> Q PyType
instance Show PyType
instance Eq PyType
instance Ord PyType
instance PyValue PyType
instance Lift PyType


-- | TemplateHaskell helper for Ganeti Haskell code.
--   
--   As TemplateHaskell require that splices be defined in a separate
--   module, we combine all the TemplateHaskell functionality that HTools
--   needs in this module (except the one for unittests).
module Ganeti.THH
data OptionalType
NotOptional :: OptionalType
OptionalOmitNull :: OptionalType
OptionalSerializeNull :: OptionalType
AndRestArguments :: OptionalType

-- | Serialised field data type describing how to generate code for the
--   field. Each field has a type, which isn't captured in the type of the
--   data type, but is saved in the <a>Q</a> monad in <a>fieldType</a>.
--   
--   Let <tt>t</tt> be a type we want to parametrize the field with. There
--   are the following possible types of fields:
--   
--   <ul>
--   <li><i>Mandatory with no default.</i> Then <tt>fieldType</tt> holds
--   <tt>t</tt>, <tt>fieldDefault = Nothing</tt> and <tt>fieldIsOptional =
--   NotOptional</tt>.</li>
--   <li><i>Field with a default value.</i> Then <tt>fieldType</tt> holds
--   <tt>t</tt> and <tt>fieldDefault = Just exp</tt> where <tt>exp</tt> is
--   an expression of type <tt>t</tt> and <tt>fieldIsOptional =
--   NotOptional</tt>.</li>
--   <li><i>Optional, no default value.</i> Then <tt>fieldType</tt> holds
--   <tt>Maybe t</tt>, <tt>fieldDefault = Nothing</tt> and
--   <tt>fieldIsOptional</tt> is either <a>OptionalOmitNull</a> or
--   <a>OptionalSerializeNull</a>.</li>
--   </ul>
--   
--   Optional fields with a default value are prohibited, as their main
--   intention is to represent the information that a request didn't
--   contain the field data.
--   
--   <i>Custom (de)serialization:</i> Field can have custom
--   (de)serialization functions that are stored in <a>fieldRead</a> and
--   <a>fieldShow</a>. If they aren't provided, the default is to use
--   <tt>readJSON</tt> and <tt>showJSON</tt> for the field's type
--   <tt>t</tt>. If they are provided, the type of the contained
--   deserializing expression must be
--   
--   <pre>
--   [(String, JSON.JSValue)] -&gt; JSON.JSValue -&gt; JSON.Result t
--   </pre>
--   
--   where the first argument carries the whole record in the case the
--   deserializing function needs to process additional information.
--   
--   The type of the contained serializing experssion must be
--   
--   <pre>
--   t -&gt; (JSON.JSValue, [(String, JSON.JSValue)])
--   </pre>
--   
--   where the result can provide extra JSON fields to include in the
--   output record (or just return <tt>[]</tt> if they're not needed).
--   
--   Note that for optional fields the type appearing in the custom
--   functions is still <tt>t</tt>. Therefore making a field optional
--   doesn't change the functions.
--   
--   There is also a special type of optional field <a>AndRestArguments</a>
--   which allows to parse any additional arguments not covered by other
--   fields. There can be at most one such special field and it's type must
--   be <tt>Map String JSON.JSValue</tt>. See also <a>andRestArguments</a>.
data Field
Field :: String -> Q Type -> Maybe (Q Exp) -> Maybe (Q Exp) -> [String] -> Maybe (Q Exp) -> Bool -> Maybe String -> OptionalType -> String -> Bool -> Field
fieldName :: Field -> String

-- | the type of the field, <tt>t</tt> for non-optional fields, <tt>Maybe
--   t</tt> for optional ones.
fieldType :: Field -> Q Type

-- | an optional custom deserialization function of type <tt>[(String,
--   JSON.JSValue)] -&gt; JSON.JSValue -&gt; JSON.Result t</tt>
fieldRead :: Field -> Maybe (Q Exp)

-- | an optional custom serialization function of type <tt>t -&gt;
--   (JSON.JSValue, [(String, JSON.JSValue)])</tt>
fieldShow :: Field -> Maybe (Q Exp)

-- | a list of extra keys added by <a>fieldShow</a>
fieldExtraKeys :: Field -> [String]

-- | an optional default value of type <tt>t</tt>
fieldDefault :: Field -> Maybe (Q Exp)

-- | whether not presented default value will be serialized
fieldSerializeDefault :: Field -> Bool
fieldConstr :: Field -> Maybe String

-- | determines if a field is optional, and if yes, how
fieldIsOptional :: Field -> OptionalType
fieldDoc :: Field -> String
fieldPresentInForthcoming :: Field -> Bool

-- | Generates a simple field.
simpleField :: String -> Q Type -> Field

-- | Generate an AndRestArguments catch-all field.
andRestArguments :: String -> Field
withDoc :: String -> Field -> Field

-- | Sets the renamed constructor field.
renameField :: String -> Field -> Field

-- | Sets the default value on a field (makes it optional with a default
--   value).
defaultField :: Q Exp -> Field -> Field

-- | A defaultField which will be serialized only if it's value differs
--   from a default value.
notSerializeDefaultField :: Q Exp -> Field -> Field

-- | Mark a field as present in the forthcoming variant.
presentInForthcoming :: Field -> Field

-- | Marks a field optional (turning its base type into a Maybe).
optionalField :: Field -> Field

-- | Marks a field optional (turning its base type into a Maybe), but with
--   <a>Nothing</a> serialised explicitly as <i>null</i>.
optionalNullSerField :: Field -> Field

-- | Make a field optional, if it isn't already.
makeOptional :: Field -> Field

-- | Sets custom functions on a field.
customField :: Name -> Name -> [String] -> Field -> Field
fieldRecordName :: Field -> String
fieldVariable :: Field -> String
actualFieldType :: Field -> Q Type
checkNonOptDef :: Monad m => Field -> m ()
parseFn :: Field -> Q Exp -> Q Exp
loadFn :: Field -> Q Exp -> Q Exp -> Q Exp
loadFnOpt :: Field -> Q Exp -> Q Exp -> Q Exp
type SimpleField = (String, Q Type)
type SimpleConstructor = (String, [SimpleField])
type SimpleObject = [SimpleConstructor]
type OpCodeConstructor = (String, Q Type, String, [Field], String)
type LuxiConstructor = (String, [Field])
ensureLower :: String -> String
ensureUpper :: String -> String
fromObjE :: Q Exp
toRawName :: String -> Name
fromRawName :: String -> Name
reprE :: Either String Name -> Q Exp
appCons :: Name -> [Exp] -> Exp
appConsApp :: Name -> [Exp] -> Exp
buildConsField :: Q Type -> StrictTypeQ
buildSimpleCons :: Name -> SimpleObject -> Q Dec
genSaveSimpleObj :: Name -> String -> SimpleObject -> (SimpleConstructor -> Q Clause) -> Q (Dec, Dec)
strADTDecl :: Name -> [String] -> Dec
genToRaw :: Name -> Name -> Name -> [(String, Either String Name)] -> Q [Dec]
genFromRaw :: Name -> Name -> Name -> [(String, Either String Name)] -> Q [Dec]
declareADT :: (a -> Either String Name) -> Name -> String -> [(String, a)] -> Q [Dec]
declareLADT :: Name -> String -> [(String, String)] -> Q [Dec]
declareILADT :: String -> [(String, Int)] -> Q [Dec]
declareIADT :: String -> [(String, Name)] -> Q [Dec]
declareSADT :: String -> [(String, Name)] -> Q [Dec]
genShowJSON :: String -> Q Dec
genReadJSON :: String -> Q Dec

-- | Generates a JSON instance for a given type.
--   
--   This assumes that the <i>name</i>ToRaw and <i>name</i>FromRaw
--   functions have been defined as by the <a>declareSADT</a> function.
makeJSONInstance :: Name -> Q [Dec]

-- | Transforms a CamelCase string into an_underscore_based_one.
deCamelCase :: String -> String
camelCase :: String -> String
constructorName :: Con -> Q Name
reifyConsNames :: Name -> Q [String]
genConstrToStr :: (String -> Q String) -> Name -> String -> Q [Dec]

-- | Constructor-to-string for OpCode.
genOpID :: Name -> String -> Q [Dec]

-- | Strips <tt>Op</tt> from the constructor name, converts to lower-case
--   and adds a given prefix.
genOpLowerStrip :: String -> Name -> String -> Q [Dec]

-- | Builds a list with all defined constructor names for a type.
--   
--   <pre>
--   vstr :: String
--   vstr = [...]
--   </pre>
--   
--   Where the actual values of the string are the constructor names mapped
--   via <tt>trans_fun</tt>.
genAllConstr :: (String -> String) -> Name -> String -> Q [Dec]

-- | Generates a list of all defined opcode IDs.
genAllOpIDs :: Name -> String -> Q [Dec]
data OpCodeField
OpCodeField :: String -> PyType -> Maybe PyValueEx -> String -> OpCodeField
ocfName :: OpCodeField -> String
ocfType :: OpCodeField -> PyType
ocfDefl :: OpCodeField -> Maybe PyValueEx
ocfDoc :: OpCodeField -> String

-- | Transfers opcode data between the opcode description (through
--   <tt>genOpCode</tt>) and the Python code generation functions.
data OpCodeDescriptor
OpCodeDescriptor :: String -> PyType -> String -> [OpCodeField] -> String -> OpCodeDescriptor
ocdName :: OpCodeDescriptor -> String
ocdType :: OpCodeDescriptor -> PyType
ocdDoc :: OpCodeDescriptor -> String
ocdFields :: OpCodeDescriptor -> [OpCodeField]
ocdDescr :: OpCodeDescriptor -> String
maybeApp :: Maybe (Q Exp) -> Q Type -> Q Exp
genPyType' :: OptionalType -> Q Type -> Q PyType
genPyType :: Field -> Q PyType
genPyDefault :: Field -> Q Exp
pyField :: Field -> Q Exp
pyClass :: OpCodeConstructor -> Q Exp
pyClasses :: [OpCodeConstructor] -> Q [Dec]
opcodeConsToLuxiCons :: OpCodeConstructor -> LuxiConstructor
genOpCodeDictObject :: Name -> (LuxiConstructor -> Q Clause) -> (LuxiConstructor -> Q Exp) -> [LuxiConstructor] -> Q [Dec]

-- | Generates the OpCode data type.
--   
--   This takes an opcode logical definition, and builds both the datatype
--   and the JSON serialisation out of it. We can't use a generic
--   serialisation since we need to be compatible with Ganeti's own, so we
--   have a few quirks to work around.
genOpCode :: String -> [OpCodeConstructor] -> Q [Dec]
genOpConsFields :: OpCodeConstructor -> Clause
genAllOpFields :: String -> [OpCodeConstructor] -> (Dec, Dec)
saveConstructor :: LuxiConstructor -> Q Clause
genSaveOpCode :: [LuxiConstructor] -> (LuxiConstructor -> Q Clause) -> Q [Clause]
loadConstructor :: Name -> (Field -> Q Exp) -> [Field] -> Q Exp
loadOpConstructor :: LuxiConstructor -> Q Exp
genLoadOpCode :: [LuxiConstructor] -> (LuxiConstructor -> Q Exp) -> Q [Clause]

-- | Constructor-to-string for LuxiOp.
genStrOfOp :: Name -> String -> Q [Dec]

-- | Constructor-to-string for MsgKeys.
genStrOfKey :: Name -> String -> Q [Dec]

-- | Generates the LuxiOp data type.
--   
--   This takes a Luxi operation definition and builds both the datatype
--   and the function transforming the arguments to JSON. We can't use
--   anything less generic, because the way different operations are
--   serialized differs on both parameter- and top-level.
--   
--   There are two things to be defined for each parameter:
--   
--   <ul>
--   <li>name</li>
--   <li>type</li>
--   </ul>
genLuxiOp :: String -> [LuxiConstructor] -> Q [Dec]
saveLuxiConstructor :: LuxiConstructor -> Q Clause
fieldTypeInfo :: String -> Field -> Q (Name, Strict, Type)

-- | Build an object declaration.
buildObject :: String -> String -> [Field] -> Q [Dec]
buildAccessor :: Name -> String -> Name -> String -> Name -> String -> Field -> Q [Dec]
buildLens :: (Name, Name) -> (Name, Name) -> Name -> String -> Int -> (Field, Int) -> Q [Dec]

-- | Build an object that can have a forthcoming variant. This will create
--   3 data types: two objects, prefixed by <a>Real</a> and
--   <a>Forthcoming</a>, respectively, and a sum type of those. The JSON
--   representation of the latter will be a JSON object, dispatching on the
--   <a>forthcoming</a> key.
buildObjectWithForthcoming :: String -> String -> [Field] -> Q [Dec]

-- | Generates an object definition: data type and its JSON instance.
buildObjectSerialisation :: String -> [Field] -> Q [Dec]
objVarName :: Name
defaultToJSArray :: DictObject a => [String] -> a -> [JSValue]
defaultFromJSArray :: DictObject a => [String] -> [JSValue] -> Result a
genArrayObjectInstance :: Name -> [Field] -> Q Dec
genDictObject :: (Name -> Field -> Q Exp) -> (Field -> Q Exp) -> String -> [Field] -> Q [Dec]
genSaveObject :: String -> Q [Dec]
saveObjectField :: Name -> Field -> Q Exp
objectShowJSON :: String -> Q Dec
genLoadObject :: String -> Q (Dec, Dec)
loadObjectField :: [Field] -> Field -> Q Exp
fieldDictKeys :: Field -> Exp
fieldsDictKeys :: [Field] -> Exp
fieldsDictKeysQ :: [Field] -> Q Exp
fieldsUsedKeysQ :: [Field] -> Q Exp
objectReadJSON :: String -> Q Dec
paramTypeNames :: String -> (String, String)
paramFieldNames :: String -> Field -> (Name, Name)
paramFieldTypeInfo :: String -> Field -> VarStrictTypeQ

-- | Build a parameter declaration.
--   
--   This function builds two different data structures: a <i>filled</i>
--   one, in which all fields are required, and a <i>partial</i> one, in
--   which all fields are optional. Due to the current record syntax
--   issues, the fields need to be named differrently for the two
--   structures, so the partial ones get a <i>P</i> suffix. Also generate a
--   default value for the partial parameters.
buildParam :: String -> String -> [Field] -> Q [Dec]
buildParamAllFields :: String -> [Field] -> [Dec]
buildPParamSerialisation :: String -> [Field] -> Q [Dec]
savePParamField :: Name -> Field -> Q Exp
loadPParamField :: Field -> Q Exp
fillParam :: String -> String -> [Field] -> Q [Dec]

-- | Exception simple error message field.
excErrMsg :: (String, Q Type)

-- | Builds an exception type definition.
genException :: String -> SimpleObject -> Q [Dec]
saveExcCons :: String -> [SimpleField] -> Q Clause
loadExcConstructor :: Name -> String -> [SimpleField] -> Q Exp
genLoadExc :: Name -> String -> SimpleObject -> Q (Dec, Dec)
instance Show OptionalType
instance Eq OptionalType


-- | Implementation of the Ganeti logging functionality.
--   
--   This currently lacks the following (FIXME):
--   
--   <ul>
--   <li>log file reopening</li>
--   </ul>
--   
--   Note that this requires the hslogger library version 1.1 and above.
module Ganeti.Logging

-- | Syslog usage type.
data SyslogUsage
SyslogNo :: SyslogUsage
SyslogYes :: SyslogUsage
SyslogOnly :: SyslogUsage
syslogUsageFromRaw :: Monad m_aPMk => String -> m_aPMk SyslogUsage
syslogUsageToRaw :: SyslogUsage -> String
logFormatter :: String -> Bool -> Bool -> LogFormatter a
openFormattedHandler :: LogHandler a => Bool -> LogFormatter a -> IO a -> IO [a]

-- | Sets up the logging configuration.
setupLogging :: Maybe String -> String -> Bool -> Bool -> Bool -> SyslogUsage -> IO ()

-- | A monad that allows logging.
class Monad m => MonadLog m
logAt :: MonadLog m => Priority -> String -> m ()

-- | Log at debug level.
logDebug :: MonadLog m => String -> m ()

-- | Log at info level.
logInfo :: MonadLog m => String -> m ()

-- | Log at notice level.
logNotice :: MonadLog m => String -> m ()

-- | Log at warning level.
logWarning :: MonadLog m => String -> m ()

-- | Log at error level.
logError :: MonadLog m => String -> m ()

-- | Log at critical level.
logCritical :: MonadLog m => String -> m ()

-- | Log at alert level.
logAlert :: MonadLog m => String -> m ()

-- | Log at emergency level.
logEmergency :: MonadLog m => String -> m ()

-- | Check if the logging is at DEBUG level. DEBUG logging is unacceptable
--   for production.
isDebugMode :: IO Bool

-- | If an error occurs within a given computation, it annotated with a
--   given message and logged and the error is re-thrown.
withErrorLogAt :: (MonadLog m, MonadError e m, Show e) => Priority -> String -> m a -> m a
instance MonadLog m => MonadLog (IdentityT m)
instance Show SyslogUsage
instance Eq SyslogUsage
instance Enum SyslogUsage
instance Bounded SyslogUsage
instance Ord SyslogUsage
instance (MonadLog m, Error e) => MonadLog (ResultT e m)
instance (MonadLog m, Monoid w) => MonadLog (RWST r w s m)
instance MonadLog m => MonadLog (StateT s m)
instance MonadLog m => MonadLog (ReaderT r m)
instance MonadLog m => MonadLog (MaybeT m)
instance MonadLog IO


-- | Utility functions.
module Ganeti.Utils

-- | To be used only for debugging, breaks referential integrity.
debug :: Show a => a -> a

-- | Displays a modified form of the second parameter before returning it.
debugFn :: Show b => (a -> b) -> a -> a

-- | Show the first parameter before returning the second one.
debugXy :: Show a => a -> b -> b

-- | Apply the function if condition holds, otherwise use default value.
applyIf :: Bool -> (a -> a) -> a -> a

-- | Comma-join a string list.
commaJoin :: [String] -> String

-- | Split a list on a separator and return a list of lists.
sepSplit :: Eq a => a -> [a] -> [[a]]

-- | Finds the first unused element in a set starting from a given base.
findFirst :: (Ord a, Enum a) => a -> Set a -> a

-- | Simple pluralize helper
plural :: Int -> String -> String -> String

-- | Ensure a value is quoted if needed.
ensureQuoted :: String -> String

-- | Standard deviation function.
stdDev :: [Double] -> Double

-- | "if" as a function, rather than as syntactic sugar.
if' :: Bool -> a -> a -> a
parseChoices :: Monad m => String -> String -> [(a, String)] -> m a

-- | Safe <a>read</a> function returning data encapsulated in a Result.
tryRead :: (Monad m, Read a) => String -> String -> m a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <i>Backport from Text.Read introduced in base-4.6.0.0</i>
readMaybe :: Read a => String -> Maybe a

-- | Format a table of strings to maintain consistent length.
formatTable :: [[String]] -> [Bool] -> [[String]]

-- | Constructs a printable table from given header and rows
printTable :: String -> [String] -> [[String]] -> [Bool] -> String
parseUnitValue :: Monad m => Bool -> String -> m Rational
parseUnitEx :: (Monad m, Integral a, Read a) => Bool -> String -> m a

-- | Tries to extract number and scale from the given string.
--   
--   Input must be in the format NUMBER+ SPACE* [UNIT]. If no unit is
--   specified, it defaults to MiB. Return value is always an integral
--   value in MiB.
parseUnit :: (Monad m, Integral a, Read a) => String -> m a

-- | Tries to extract a number and scale from a given string, taking all
--   kilos to be binary.
parseUnitAssumeBinary :: (Monad m, Integral a, Read a) => String -> m a

-- | Unwraps a <a>Result</a>, exiting the program if it is a <a>Bad</a>
--   value, otherwise returning the actual contained value.
exitIfBad :: String -> Result a -> IO a

-- | Exits immediately with an error message.
exitErr :: String -> IO a

-- | Exits with an error message if the given boolean condition if true.
exitWhen :: Bool -> String -> IO ()

-- | Exits with an error message <i>unless</i> the given boolean condition
--   if true, the opposite of <a>exitWhen</a>.
exitUnless :: Bool -> String -> IO ()

-- | Unwraps a <a>Result</a>, logging a warning message and then returning
--   a default value if it is a <a>Bad</a> value, otherwise returning the
--   actual contained value.
logWarningIfBad :: String -> a -> Result a -> IO a

-- | Try an IO interaction, log errors and unfold as a <a>Result</a>.
tryAndLogIOError :: IO a -> String -> (a -> Result b) -> IO (Result b)

-- | Try an IO interaction and return a default value if the interaction
--   throws an IOError.
withDefaultOnIOError :: a -> IO a -> IO a

-- | Print a warning, but do not exit.
warn :: String -> IO ()
extractKey :: [Either Integer String] -> String -> ([Either Integer String], String)

-- | Sort a list of strings based on digit and non-digit groupings.
--   
--   Given a list of names <tt>[<tt>a1</tt>, <tt>a10</tt>, <tt>a11</tt>,
--   <tt>a2</tt>]</tt> this function will sort the list in the logical
--   order <tt>[<tt>a1</tt>, <tt>a2</tt>, <tt>a10</tt>, <tt>a11</tt>]</tt>.
--   
--   The sort algorithm breaks each name in groups of either only-digits or
--   no-digits, and sorts based on each group.
--   
--   Internally, this is not implemented via regexes (like the Python
--   version), but via actual splitting of the string in sequences of
--   either digits or everything else, and converting the digit sequences
--   in <i>Left Integer</i> and the non-digit ones in <i>Right String</i>,
--   at which point sorting becomes trivial due to the built-in
--   <a>Either</a> ordering; we only need one extra step of dropping the
--   key at the end.
niceSort :: [String] -> [String]

-- | Key-version of <a>niceSort</a>. We use <a>sortBy</a> and <tt>compare
--   <a>on</a> fst</tt> since we don't want to add an ordering constraint
--   on the <i>a</i> type, hence the need to only compare the first element
--   of the <i>(key, a)</i> tuple.
niceSortKey :: (a -> String) -> [a] -> [a]

-- | Strip space characthers (including newline). As this is expensive,
--   should only be run on small strings.
rStripSpace :: String -> String

-- | Returns a random UUID. This is a Linux-specific method as it uses the
--   /proc filesystem.
newUUID :: IO String
uuidCheckParser :: Parser ()

-- | Checks if the string is a valid UUID as in
--   <a>Ganeti.Constants.uuidRegex</a>.
isUUID :: String -> Bool

-- | Returns the current time as an <a>Integer</a> representing the number
--   of seconds from the Unix epoch.
getCurrentTime :: IO Integer

-- | Returns the current time as an <a>Integer</a> representing the number
--   of microseconds from the Unix epoch (hence the need for
--   <a>Integer</a>).
getCurrentTimeUSec :: IO Integer

-- | Convert a ClockTime into a (seconds-only) timestamp.
clockTimeToString :: ClockTime -> String

-- | Convert a ClockTime into a (seconds-only) <a>EpochTime</a> (AKA
--   <tt>time_t</tt>).
clockTimeToCTime :: ClockTime -> EpochTime

-- | Convert a ClockTime the number of microseconds since the epoch.
clockTimeToUSec :: ClockTime -> Integer

-- | Convert a ClockTime into a (seconds-only) <a>EpochTime</a> (AKA
--   <tt>time_t</tt>).
cTimeToClockTime :: EpochTime -> ClockTime

-- | Strip a prefix from a string, allowing the last character of the
--   prefix (which is assumed to be a separator) to be absent from the
--   string if the string terminates there.
--   
--   &gt;&gt;&gt; chompPrefix "foo:bar:" "a:b:c" Nothing
--   
--   &gt;&gt;&gt; chompPrefix "foo:bar:" "foo:bar:baz" Just "baz"
--   
--   &gt;&gt;&gt; chompPrefix "foo:bar:" "foo:bar:" Just ""
--   
--   &gt;&gt;&gt; chompPrefix "foo:bar:" "foo:bar" Just ""
--   
--   &gt;&gt;&gt; chompPrefix "foo:bar:" "foo:barbaz" Nothing
chompPrefix :: String -> String -> Maybe String

-- | Breaks a string in lines with length &lt;= maxWidth.
--   
--   NOTE: The split is OK if:
--   
--   <ul>
--   <li>It doesn't break a word, i.e. the next line begins with space
--   (<tt>isSpace . head $ rest</tt>) or the current line ends with space
--   (<tt>null revExtra</tt>);</li>
--   <li>It breaks a very big word that doesn't fit anyway (<tt>null
--   revLine</tt>).</li>
--   </ul>
wrap :: Int -> String -> [String]

-- | Removes surrounding whitespace. Should only be used in small strings.
trim :: String -> String

-- | A safer head version, with a default value.
defaultHead :: a -> [a] -> a

-- | A <a>head</a> version in the I/O monad, for validating parameters
--   without which we cannot continue.
exitIfEmpty :: String -> [a] -> IO a

-- | Obtain the unique element of a list in an arbitrary monad.
monadicThe :: (Eq a, Monad m) => String -> [a] -> m a

-- | Split an <a>Either</a> list into two separate lists (containing the
--   <a>Left</a> and <a>Right</a> elements, plus a "trail" list that allows
--   recombination later.
--   
--   This is splitter; for recombination, look at <a>recombineEithers</a>.
--   The sum of "left" and "right" lists should be equal to the original
--   list length, and the trail list should be the same length as well. The
--   entries in the resulting lists are reversed in comparison with the
--   original list.
splitEithers :: [Either a b] -> ([a], [b], [Bool])

-- | Recombines two "left" and "right" lists using a "trail" list into a
--   single <a>Either</a> list.
--   
--   This is the counterpart to <a>splitEithers</a>. It does the opposite
--   transformation, and the output list will be the reverse of the input
--   lists. Since <a>splitEithers</a> also reverses the lists, calling
--   these together will result in the original list.
--   
--   Mismatches in the structure of the lists (e.g. inconsistent lengths)
--   are represented via <a>Bad</a>; normally this function should not
--   fail, if lists are passed as generated by <a>splitEithers</a>.
recombineEithers :: (Show a, Show b) => [a] -> [b] -> [Bool] -> Result [Either a b]
resolveAddrHints :: Maybe AddrInfo

-- | Resolves a numeric address.
resolveAddr :: Int -> String -> IO (Result (Family, SockAddr))

-- | Set the owner and the group of a file (given as names, not numeric
--   id).
setOwnerAndGroupFromNames :: FilePath -> GanetiDaemon -> GanetiGroup -> IO ()

-- | Resets permissions so that the owner can read/write and the group only
--   read. All other permissions are cleared.
setOwnerWGroupR :: FilePath -> IO ()

-- | Formats an integral number, appending a suffix.
formatOrdinal :: (Integral a, Show a) => a -> String

-- | Attempt, in a non-blocking way, to obtain a lock on a given file;
--   report back success. Returns the file descriptor so that the lock can
--   be released by closing
lockFile :: FilePath -> IO (Result Fd)

-- | File stat identifier.
type FStat = (EpochTime, FileID, FileOffset)

-- | Null <a>FStat</a> value.
nullFStat :: FStat
buildFileStatus :: FileStatus -> FStat

-- | Wrapper over <a>buildFileStatus</a>. This reads the data from the
--   filesystem and then builds our cache structure.
getFStat :: FilePath -> IO FStat

-- | Safe version of <a>getFStat</a>, that ignores IOErrors.
getFStatSafe :: FilePath -> IO FStat

-- | Check if the file needs reloading
needsReload :: FStat -> FilePath -> IO (Maybe FStat)
watchFileEx :: Eq b => Integer -> b -> IORef b -> (a -> Bool) -> IO a -> IO a

-- | Within the given timeout (in seconds), wait for for the output of the
--   given method to satisfy a given predicate and return the new value;
--   make use of the promise that the method will only change its value, if
--   the given file changes on disk. If the file does not exist on disk,
--   return immediately.
watchFileBy :: FilePath -> Int -> (a -> Bool) -> IO a -> IO a

-- | Within the given timeout (in seconds), wait for for the output of the
--   given method to change and return the new value; make use of the
--   promise that the method will only change its value, if the given file
--   changes on disk. If the file does not exist on disk, return
--   immediately.
watchFile :: Eq a => FilePath -> Int -> a -> IO a -> IO a

-- | Type describing ownership and permissions of newly generated
--   directories and files. All parameters are optional, with nothing
--   meaning that the default value should be left untouched.
data FilePermissions
FilePermissions :: Maybe GanetiDaemon -> Maybe GanetiGroup -> FileMode -> FilePermissions
fpOwner :: FilePermissions -> Maybe GanetiDaemon
fpGroup :: FilePermissions -> Maybe GanetiGroup
fpPermissions :: FilePermissions -> FileMode

-- | Ensure that a given file or directory has the permissions, and
--   possibly ownerships, as required.
ensurePermissions :: FilePath -> FilePermissions -> IO (Result ())

-- | Safely rename a file, creating the target directory, if needed.
safeRenameFile :: FilePermissions -> FilePath -> FilePath -> IO (Result ())

-- | Removes duplicates, preserving order.
ordNub :: Ord a => [a] -> [a]

-- | `isSubsequenceOf a b`: Checks if a is a subsequence of b.
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool


-- | Implementation of the Ganeti confd types.
module Ganeti.Confd.Types
data ConfdRequestType
ReqPing :: ConfdRequestType
ReqNodeRoleByName :: ConfdRequestType
ReqNodePipByInstPip :: ConfdRequestType
ReqClusterMaster :: ConfdRequestType
ReqNodePipList :: ConfdRequestType
ReqMcPipList :: ConfdRequestType
ReqInstIpsList :: ConfdRequestType
ReqNodeDrbd :: ConfdRequestType
ReqNodeInstances :: ConfdRequestType
ReqInstanceDisks :: ConfdRequestType
ReqConfigQuery :: ConfdRequestType
ReqDataCollectors :: ConfdRequestType
confdRequestTypeFromRaw :: Monad m_aVen => Int -> m_aVen ConfdRequestType
confdRequestTypeToRaw :: ConfdRequestType -> Int
_ReqDataCollectors :: Int
_ReqConfigQuery :: Int
_ReqInstanceDisks :: Int
_ReqNodeInstances :: Int
_ReqNodeDrbd :: Int
_ReqInstIpsList :: Int
_ReqMcPipList :: Int
_ReqNodePipList :: Int
_ReqClusterMaster :: Int
_ReqNodePipByInstPip :: Int
_ReqNodeRoleByName :: Int
_ReqPing :: Int
data ConfdReqField
ReqFieldName :: ConfdReqField
ReqFieldIp :: ConfdReqField
ReqFieldMNodePip :: ConfdReqField
confdReqFieldFromRaw :: Monad m_aVjk => Int -> m_aVjk ConfdReqField
confdReqFieldToRaw :: ConfdReqField -> Int
_ReqFieldMNodePip :: Int
_ReqFieldIp :: Int
_ReqFieldName :: Int
data ConfdReqQ
ConfdReqQ :: Maybe String -> [String] -> Maybe String -> [ConfdReqField] -> ConfdReqQ
confdReqQIp :: ConfdReqQ -> Maybe String
confdReqQIpList :: ConfdReqQ -> [String]
confdReqQLink :: ConfdReqQ -> Maybe String
confdReqQFields :: ConfdReqQ -> [ConfdReqField]
loadConfdReqQ :: JSValue -> Result ConfdReqQ
saveConfdReqQ :: ConfdReqQ -> JSValue

-- | Confd query type. This is complex enough that we can't automatically
--   derive it via THH.
data ConfdQuery
EmptyQuery :: ConfdQuery
PlainQuery :: String -> ConfdQuery
DictQuery :: ConfdReqQ -> ConfdQuery
data ConfdReplyStatus
ReplyStatusOk :: ConfdReplyStatus
ReplyStatusError :: ConfdReplyStatus
ReplyStatusNotImpl :: ConfdReplyStatus
confdReplyStatusFromRaw :: Monad m_aVuA => Int -> m_aVuA ConfdReplyStatus
confdReplyStatusToRaw :: ConfdReplyStatus -> Int
_ReplyStatusNotImpl :: Int
_ReplyStatusError :: Int
_ReplyStatusOk :: Int
data ConfdNodeRole
NodeRoleMaster :: ConfdNodeRole
NodeRoleCandidate :: ConfdNodeRole
NodeRoleOffline :: ConfdNodeRole
NodeRoleDrained :: ConfdNodeRole
NodeRoleRegular :: ConfdNodeRole
confdNodeRoleFromRaw :: Monad m_aVyM => Int -> m_aVyM ConfdNodeRole
confdNodeRoleToRaw :: ConfdNodeRole -> Int
_NodeRoleRegular :: Int
_NodeRoleDrained :: Int
_NodeRoleOffline :: Int
_NodeRoleCandidate :: Int
_NodeRoleMaster :: Int
data ConfdErrorType
ConfdErrorUnknownEntry :: ConfdErrorType
ConfdErrorInternal :: ConfdErrorType
ConfdErrorArgument :: ConfdErrorType
confdErrorTypeFromRaw :: Monad m_aVCU => Int -> m_aVCU ConfdErrorType
confdErrorTypeToRaw :: ConfdErrorType -> Int
_ConfdErrorArgument :: Int
_ConfdErrorInternal :: Int
_ConfdErrorUnknownEntry :: Int
data ConfdRequest
ConfdRequest :: Int -> ConfdRequestType -> ConfdQuery -> String -> ConfdRequest
confdRqProtocol :: ConfdRequest -> Int
confdRqType :: ConfdRequest -> ConfdRequestType
confdRqQuery :: ConfdRequest -> ConfdQuery
confdRqRsalt :: ConfdRequest -> String
loadConfdRequest :: JSValue -> Result ConfdRequest
saveConfdRequest :: ConfdRequest -> JSValue

-- | Client side helper function for creating requests. It automatically
--   fills in some default values.
newConfdRequest :: ConfdRequestType -> ConfdQuery -> IO ConfdRequest
data ConfdReply
ConfdReply :: Int -> ConfdReplyStatus -> JSValue -> Int -> ConfdReply
confdReplyProtocol :: ConfdReply -> Int
confdReplyStatus :: ConfdReply -> ConfdReplyStatus
confdReplyAnswer :: ConfdReply -> JSValue
confdReplySerial :: ConfdReply -> Int
loadConfdReply :: JSValue -> Result ConfdReply
saveConfdReply :: ConfdReply -> JSValue
data SignedMessage
SignedMessage :: String -> String -> String -> SignedMessage
signedMsgHmac :: SignedMessage -> String
signedMsgMsg :: SignedMessage -> String
signedMsgSalt :: SignedMessage -> String
loadSignedMessage :: JSValue -> Result SignedMessage
saveSignedMessage :: SignedMessage -> JSValue

-- | Data type containing information used by the Confd client.
data ConfdClient
ConfdClient :: HashKey -> [String] -> PortNumber -> ConfdClient

-- | The hmac used for authentication
hmacKey :: ConfdClient -> HashKey

-- | The list of nodes to query
peers :: ConfdClient -> [String]

-- | The port where confd server is listening
serverPort :: ConfdClient -> PortNumber
instance Show SignedMessage
instance Eq SignedMessage
instance JSON SignedMessage
instance ArrayObject SignedMessage
instance DictObject SignedMessage
instance Show ConfdReply
instance Eq ConfdReply
instance JSON ConfdReply
instance ArrayObject ConfdReply
instance DictObject ConfdReply
instance Show ConfdRequest
instance Eq ConfdRequest
instance JSON ConfdRequest
instance ArrayObject ConfdRequest
instance DictObject ConfdRequest
instance JSON ConfdErrorType
instance Show ConfdErrorType
instance Eq ConfdErrorType
instance Enum ConfdErrorType
instance Bounded ConfdErrorType
instance Ord ConfdErrorType
instance JSON ConfdNodeRole
instance Show ConfdNodeRole
instance Eq ConfdNodeRole
instance Enum ConfdNodeRole
instance Bounded ConfdNodeRole
instance Ord ConfdNodeRole
instance JSON ConfdReplyStatus
instance Show ConfdReplyStatus
instance Eq ConfdReplyStatus
instance Enum ConfdReplyStatus
instance Bounded ConfdReplyStatus
instance Ord ConfdReplyStatus
instance Show ConfdReqQ
instance Eq ConfdReqQ
instance Show ConfdQuery
instance Eq ConfdQuery
instance JSON ConfdQuery
instance JSON ConfdReqQ
instance ArrayObject ConfdReqQ
instance DictObject ConfdReqQ
instance JSON ConfdReqField
instance Show ConfdReqField
instance Eq ConfdReqField
instance Enum ConfdReqField
instance Bounded ConfdReqField
instance Ord ConfdReqField
instance JSON ConfdRequestType
instance Show ConfdRequestType
instance Eq ConfdRequestType
instance Enum ConfdRequestType
instance Bounded ConfdRequestType
instance Ord ConfdRequestType


-- | Ganeti-specific implementation of the Curl multi interface
--   (<a>http://curl.haxx.se/libcurl/c/libcurl-multi.html</a>).
--   
--   TODO: Evaluate implementing and switching to
--   curl_multi_socket_action(3) interface, which is deemed to be more
--   performant for high-numbers of connections (but this is not the case
--   for Ganeti).
module Ganeti.Curl.Multi

-- | Empty data type denoting a Curl multi handle. Naming is similar to
--   <a>Network.Curl</a> types.
data CurlM_

-- | Type alias for a pointer to a Curl multi handle.
type CurlMH = Ptr CurlM_

-- | Our type alias for maps indexing <a>CurlH</a> handles to the
--   <a>IORef</a> for the Curl code.
type HandleMap = Map CurlH (IORef CurlCode)
curl_multi_init :: IO CurlMH
curl_multi_cleanup :: CurlMH -> IO CInt
curl_multi_add_handle :: CurlMH -> CurlH -> IO CInt
curl_multi_remove_handle :: CurlMH -> CurlH -> IO CInt
curl_multi_perform :: CurlMH -> Ptr CInt -> IO CInt
curl_multi_info_read :: CurlMH -> Ptr CInt -> IO (Ptr CurlMsg)

-- | Adds an easy handle to a multi handle. This is a nicer wrapper over
--   <a>curl_multi_add_handle</a> that fails for wrong codes.
curlMultiAddHandle :: CurlMH -> Curl -> IO ()

-- | Nice wrapper over <a>curl_multi_info_read</a> that massages the
--   results into Haskell types.
curlMultiInfoRead :: CurlMH -> IO (Maybe CurlMsg, CInt)

-- | Nice wrapper over <a>curl_multi_perform</a>.
curlMultiPerform :: CurlMH -> IO (CurlMCode, CInt)

-- | Magical constant for the polling delay. This needs to be chosen such
--   that:
--   
--   <ul>
--   <li>we don't poll too often; a slower poll allows the RTS to schedule
--   other threads, and let them work</li>
--   <li>we don't want to pool too slow, so that Curl gets to act on the
--   handles that need it</li>
--   </ul>
pollDelayInterval :: Int

-- | Writes incoming curl data to a list of strings, stored in an
--   <a>IORef</a>.
writeHandle :: IORef [String] -> Ptr CChar -> CInt -> CInt -> Ptr () -> IO CInt

-- | Loops and extracts all pending messages from a Curl multi handle.
readMessages :: CurlMH -> HandleMap -> IO ()

-- | Loops and polls curl until there are no more remaining handles.
performMulti :: CurlMH -> HandleMap -> CInt -> IO ()

-- | Template for the Curl error buffer.
errorBuffer :: String

-- | Allocate a NULL-initialised error buffer.
mallocErrorBuffer :: IO CString

-- | Initialise a curl handle. This is just a wrapper over the
--   <a>Network.Curl</a> function <a>initialize</a>, plus adding our
--   options.
makeEasyHandle :: (IORef [String], Ptr CChar, ([CurlOption], URLString)) -> IO Curl

-- | Perform a multi-call against a list of nodes.
execMultiCall :: [([CurlOption], String)] -> IO [(CurlCode, String)]


-- | Ganeti logging functions expressed using MonadBase
--   
--   This allows to use logging functions without having instances for all
--   possible transformers.
module Ganeti.Logging.Lifted

-- | A monad that allows logging.
logAt :: (MonadLog b, MonadBase b m) => Priority -> String -> m ()

-- | Log at debug level.
logDebug :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at info level.
logInfo :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at notice level.
logNotice :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at warning level.
logWarning :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at error level.
logError :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at critical level.
logCritical :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at alert level.
logAlert :: (MonadLog b, MonadBase b m) => String -> m ()

-- | Log at emergency level.
logEmergency :: (MonadLog b, MonadBase b m) => String -> m ()


-- | A pure implementation of MonadLog using MonadWriter
module Ganeti.Logging.WriterLog
type LogSeq = Seq (Priority, String)
type WriterSeq = WriterT LogSeq

-- | A monad transformer that adds pure logging capability.
newtype WriterLogT m a
WriterLogT :: WriterSeq m a -> WriterLogT m a
unwrapWriterLogT :: WriterLogT m a -> WriterSeq m a
type WriterLog = WriterLogT Identity
runWriterLogT :: WriterLogT m a -> m (a, LogSeq)
runWriterLog :: WriterLog a -> (a, LogSeq)

-- | Runs a <a>WriterLogT</a>, and when it finishes, resends all log
--   messages to the underlying monad that implements <a>MonadLog</a>.
--   
--   This can be used to delay logging messages, by accumulating them in
--   <a>WriterLogT</a>, and resending them at the end to the underlying
--   monad.
execWriterLogT :: MonadLog m => WriterLogT m a -> m a

-- | Sends all log messages to the a monad that implements <a>MonadLog</a>.
dumpLogSeq :: MonadLog m => LogSeq -> m ()

-- | Runs a <a>WriterLog</a>, and when it finishes, resends all log
--   messages to the a monad that implements <a>MonadLog</a>.
execWriterLog :: MonadLog m => WriterLog a -> m a
instance MonadBase IO m => MonadBase IO (WriterLogT m)
instance Functor m => Functor (WriterLogT m)
instance Applicative m => Applicative (WriterLogT m)
instance Alternative m => Alternative (WriterLogT m)
instance Monad m => Monad (WriterLogT m)
instance MonadPlus m => MonadPlus (WriterLogT m)
instance MonadIO m => MonadIO (WriterLogT m)
instance MonadTrans WriterLogT
instance MonadBaseControl IO m => MonadBaseControl IO (WriterLogT m)
instance MonadTransControl WriterLogT
instance Monad m => MonadLog (WriterLogT m)


-- | Some common Ganeti types.
--   
--   This holds types common to both core work, and to htools. Types that
--   are very core specific (e.g. configuration objects) should go in
--   <a>Objects</a>, while types that are specific to htools in-memory
--   representation should go into <a>Types</a>.
module Ganeti.Types

-- | Type that holds a non-negative value.
newtype NonNegative a
NonNegative :: a -> NonNegative a
fromNonNegative :: NonNegative a -> a

-- | Smart constructor for <a>NonNegative</a>.
mkNonNegative :: (Monad m, Num a, Ord a, Show a) => a -> m (NonNegative a)

-- | Type that holds a positive value.
newtype Positive a
Positive :: a -> Positive a
fromPositive :: Positive a -> a

-- | Smart constructor for <a>Positive</a>.
mkPositive :: (Monad m, Num a, Ord a, Show a) => a -> m (Positive a)

-- | Type that holds a negative value.
newtype Negative a
Negative :: a -> Negative a
fromNegative :: Negative a -> a

-- | Smart constructor for <a>Negative</a>.
mkNegative :: (Monad m, Num a, Ord a, Show a) => a -> m (Negative a)

-- | Type that holds a non-null list.
newtype NonEmpty a
NonEmpty :: [a] -> NonEmpty a
fromNonEmpty :: NonEmpty a -> [a]

-- | Smart constructor for <a>NonEmpty</a>.
mkNonEmpty :: Monad m => [a] -> m (NonEmpty a)

-- | A simple type alias for non-empty strings.
type NonEmptyString = NonEmpty Char
type QueryResultCode = Int
newtype IPv4Address
IPv4Address :: String -> IPv4Address
fromIPv4Address :: IPv4Address -> String
mkIPv4Address :: Monad m => String -> m IPv4Address
newtype IPv4Network
IPv4Network :: String -> IPv4Network
fromIPv4Network :: IPv4Network -> String
mkIPv4Network :: Monad m => String -> m IPv4Network
newtype IPv6Address
IPv6Address :: String -> IPv6Address
fromIPv6Address :: IPv6Address -> String
mkIPv6Address :: Monad m => String -> m IPv6Address
newtype IPv6Network
IPv6Network :: String -> IPv6Network
fromIPv6Network :: IPv6Network -> String
mkIPv6Network :: Monad m => String -> m IPv6Network

-- | Instance disk template type. The disk template is a name for the
--   constructor of the disk configuration <tt>DiskLogicalId</tt> used for
--   serialization, configuration values, etc.
data DiskTemplate
DTDiskless :: DiskTemplate
DTFile :: DiskTemplate
DTSharedFile :: DiskTemplate
DTPlain :: DiskTemplate
DTBlock :: DiskTemplate
DTDrbd8 :: DiskTemplate
DTRbd :: DiskTemplate
DTExt :: DiskTemplate
DTGluster :: DiskTemplate
diskTemplateFromRaw :: Monad m_a14mx => String -> m_a14mx DiskTemplate
diskTemplateToRaw :: DiskTemplate -> String

-- | Data type representing what items the tag operations apply to.
data TagKind
TagKindInstance :: TagKind
TagKindNode :: TagKind
TagKindGroup :: TagKind
TagKindCluster :: TagKind
TagKindNetwork :: TagKind
tagKindFromRaw :: Monad m_a14sl => String -> m_a14sl TagKind
tagKindToRaw :: TagKind -> String

-- | The Group allocation policy type.
--   
--   Note that the order of constructors is important as the automatic Ord
--   instance will order them in the order they are defined, so when
--   changing this data type be careful about the interaction with the
--   desired sorting order.
data AllocPolicy
AllocPreferred :: AllocPolicy
AllocLastResort :: AllocPolicy
AllocUnallocable :: AllocPolicy
allocPolicyFromRaw :: Monad m_a14wu => String -> m_a14wu AllocPolicy
allocPolicyToRaw :: AllocPolicy -> String

-- | The Instance real state type.
data InstanceStatus
StatusDown :: InstanceStatus
StatusOffline :: InstanceStatus
ErrorDown :: InstanceStatus
ErrorUp :: InstanceStatus
NodeDown :: InstanceStatus
NodeOffline :: InstanceStatus
Running :: InstanceStatus
UserDown :: InstanceStatus
WrongNode :: InstanceStatus
instanceStatusFromRaw :: Monad m_a14Bd => String -> m_a14Bd InstanceStatus
instanceStatusToRaw :: InstanceStatus -> String

-- | Migration mode.
data MigrationMode
MigrationLive :: MigrationMode
MigrationNonLive :: MigrationMode
migrationModeFromRaw :: Monad m_a14FD => String -> m_a14FD MigrationMode
migrationModeToRaw :: MigrationMode -> String

-- | Verify optional checks.
data VerifyOptionalChecks
VerifyNPlusOneMem :: VerifyOptionalChecks
verifyOptionalChecksFromRaw :: Monad m_a14J4 => String -> m_a14J4 VerifyOptionalChecks
verifyOptionalChecksToRaw :: VerifyOptionalChecks -> String

-- | Cluster verify error codes.
data CVErrorCode
CvECLUSTERCFG :: CVErrorCode
CvECLUSTERCERT :: CVErrorCode
CvECLUSTERCLIENTCERT :: CVErrorCode
CvECLUSTERFILECHECK :: CVErrorCode
CvECLUSTERDANGLINGNODES :: CVErrorCode
CvECLUSTERDANGLINGINST :: CVErrorCode
CvEINSTANCEBADNODE :: CVErrorCode
CvEINSTANCEDOWN :: CVErrorCode
CvEINSTANCELAYOUT :: CVErrorCode
CvEINSTANCEMISSINGDISK :: CVErrorCode
CvEINSTANCEFAULTYDISK :: CVErrorCode
CvEINSTANCEWRONGNODE :: CVErrorCode
CvEINSTANCESPLITGROUPS :: CVErrorCode
CvEINSTANCEPOLICY :: CVErrorCode
CvEINSTANCEUNSUITABLENODE :: CVErrorCode
CvEINSTANCEMISSINGCFGPARAMETER :: CVErrorCode
CvENODEDRBD :: CVErrorCode
CvENODEDRBDVERSION :: CVErrorCode
CvENODEDRBDHELPER :: CVErrorCode
CvENODEFILECHECK :: CVErrorCode
CvENODEHOOKS :: CVErrorCode
CvENODEHV :: CVErrorCode
CvENODELVM :: CVErrorCode
CvENODEN1 :: CVErrorCode
CvENODENET :: CVErrorCode
CvENODEOS :: CVErrorCode
CvENODEORPHANINSTANCE :: CVErrorCode
CvENODEORPHANLV :: CVErrorCode
CvENODERPC :: CVErrorCode
CvENODESSH :: CVErrorCode
CvENODEVERSION :: CVErrorCode
CvENODESETUP :: CVErrorCode
CvENODETIME :: CVErrorCode
CvENODEOOBPATH :: CVErrorCode
CvENODEUSERSCRIPTS :: CVErrorCode
CvENODEFILESTORAGEPATHS :: CVErrorCode
CvENODEFILESTORAGEPATHUNUSABLE :: CVErrorCode
CvENODESHAREDFILESTORAGEPATHUNUSABLE :: CVErrorCode
CvENODEGLUSTERSTORAGEPATHUNUSABLE :: CVErrorCode
CvEGROUPDIFFERENTPVSIZE :: CVErrorCode
cVErrorCodeFromRaw :: Monad m_a14Rr => String -> m_a14Rr CVErrorCode
cVErrorCodeToRaw :: CVErrorCode -> String

-- | Dynamic device modification, just add/remove version.
data DdmSimple
DdmSimpleAdd :: DdmSimple
DdmSimpleAttach :: DdmSimple
DdmSimpleRemove :: DdmSimple
DdmSimpleDetach :: DdmSimple
ddmSimpleFromRaw :: Monad m_a14Z7 => String -> m_a14Z7 DdmSimple
ddmSimpleToRaw :: DdmSimple -> String

-- | Dynamic device modification, all operations version.
--   
--   TODO: DDM_SWAP, DDM_MOVE?
data DdmFull
DdmFullAdd :: DdmFull
DdmFullAttach :: DdmFull
DdmFullRemove :: DdmFull
DdmFullDetach :: DdmFull
DdmFullModify :: DdmFull
ddmFullFromRaw :: Monad m_a153q => String -> m_a153q DdmFull
ddmFullToRaw :: DdmFull -> String

-- | Hypervisor type definitions.
data Hypervisor
Kvm :: Hypervisor
XenPvm :: Hypervisor
Chroot :: Hypervisor
XenHvm :: Hypervisor
Lxc :: Hypervisor
Fake :: Hypervisor
hypervisorFromRaw :: Monad m_a157X => String -> m_a157X Hypervisor
hypervisorToRaw :: Hypervisor -> String

-- | Oob command type.
data OobCommand
OobHealth :: OobCommand
OobPowerCycle :: OobCommand
OobPowerOff :: OobCommand
OobPowerOn :: OobCommand
OobPowerStatus :: OobCommand
oobCommandFromRaw :: Monad m_a15cP => String -> m_a15cP OobCommand
oobCommandToRaw :: OobCommand -> String

-- | Oob command status
data OobStatus
OobStatusCritical :: OobStatus
OobStatusOk :: OobStatus
OobStatusUnknown :: OobStatus
OobStatusWarning :: OobStatus
oobStatusFromRaw :: Monad m_a15h6 => String -> m_a15h6 OobStatus
oobStatusToRaw :: OobStatus -> String

-- | Storage type.
data StorageType
StorageFile :: StorageType
StorageSharedFile :: StorageType
StorageGluster :: StorageType
StorageLvmPv :: StorageType
StorageLvmVg :: StorageType
StorageDiskless :: StorageType
StorageBlock :: StorageType
StorageRados :: StorageType
StorageExt :: StorageType
storageTypeFromRaw :: Monad m_a15lV => String -> m_a15lV StorageType
storageTypeToRaw :: StorageType -> String

-- | Storage keys are identifiers for storage units. Their content varies
--   depending on the storage type, for example a storage key for LVM
--   storage is the volume group name.
type StorageKey = String
type SPExclusiveStorage = Bool

-- | Storage units without storage-type-specific parameters
data StorageUnitRaw
SURaw :: StorageType -> StorageKey -> StorageUnitRaw

-- | Full storage unit with storage-type-specific parameters
data StorageUnit
SUFile :: StorageKey -> StorageUnit
SUSharedFile :: StorageKey -> StorageUnit
SUGluster :: StorageKey -> StorageUnit
SULvmPv :: StorageKey -> SPExclusiveStorage -> StorageUnit
SULvmVg :: StorageKey -> SPExclusiveStorage -> StorageUnit
SUDiskless :: StorageKey -> StorageUnit
SUBlock :: StorageKey -> StorageUnit
SURados :: StorageKey -> StorageUnit
SUExt :: StorageKey -> StorageUnit
showSUSimple :: StorageType -> StorageKey -> String
showSULvm :: StorageType -> StorageKey -> SPExclusiveStorage -> String

-- | Mapping from disk templates to storage types.
diskTemplateToStorageType :: DiskTemplate -> StorageType

-- | Equips a raw storage unit with its parameters
addParamsToStorageUnit :: SPExclusiveStorage -> StorageUnitRaw -> StorageUnit

-- | Node evac modes.
--   
--   This is part of the <tt>IAllocator</tt> interface and it is used, for
--   example, in <a>RqType</a>. However, it must reside in this module, and
--   not in <a>Types</a>, because it is also used by <a>Constants</a>.
data EvacMode
ChangePrimary :: EvacMode
ChangeSecondary :: EvacMode
ChangeAll :: EvacMode
evacModeFromRaw :: Monad m_a15tq => String -> m_a15tq EvacMode
evacModeToRaw :: EvacMode -> String

-- | The file driver type.
data FileDriver
FileLoop :: FileDriver
FileBlktap :: FileDriver
FileBlktap2 :: FileDriver
fileDriverFromRaw :: Monad m_a15xn => String -> m_a15xn FileDriver
fileDriverToRaw :: FileDriver -> String

-- | The instance create mode.
data InstCreateMode
InstCreate :: InstCreateMode
InstImport :: InstCreateMode
InstRemoteImport :: InstCreateMode
instCreateModeFromRaw :: Monad m_a15Bk => String -> m_a15Bk InstCreateMode
instCreateModeToRaw :: InstCreateMode -> String

-- | Reboot type.
data RebootType
RebootSoft :: RebootType
RebootHard :: RebootType
RebootFull :: RebootType
rebootTypeFromRaw :: Monad m_a15Fh => String -> m_a15Fh RebootType
rebootTypeToRaw :: RebootType -> String

-- | Export modes.
data ExportMode
ExportModeLocal :: ExportMode
ExportModeRemote :: ExportMode
exportModeFromRaw :: Monad m_a15J6 => String -> m_a15J6 ExportMode
exportModeToRaw :: ExportMode -> String

-- | IAllocator run types (OpTestIAllocator).
data IAllocatorTestDir
IAllocatorDirIn :: IAllocatorTestDir
IAllocatorDirOut :: IAllocatorTestDir
iAllocatorTestDirFromRaw :: Monad m_a15MF => String -> m_a15MF IAllocatorTestDir
iAllocatorTestDirToRaw :: IAllocatorTestDir -> String

-- | IAllocator mode. FIXME: use this in <a>HTools.Backend.IAlloc</a>.
data IAllocatorMode
IAllocatorAlloc :: IAllocatorMode
IAllocatorMultiAlloc :: IAllocatorMode
IAllocatorReloc :: IAllocatorMode
IAllocatorNodeEvac :: IAllocatorMode
IAllocatorChangeGroup :: IAllocatorMode
iAllocatorModeFromRaw :: Monad m_a15QC => String -> m_a15QC IAllocatorMode
iAllocatorModeToRaw :: IAllocatorMode -> String

-- | Network mode.
data NICMode
NMBridged :: NICMode
NMRouted :: NICMode
NMOvs :: NICMode
NMPool :: NICMode
nICModeFromRaw :: Monad m_a15UT => String -> m_a15UT NICMode
nICModeToRaw :: NICMode -> String

-- | The JobStatus data type. Note that this is ordered especially such
--   that greater/lesser comparison on values of this type makes sense.
data JobStatus
JOB_STATUS_QUEUED :: JobStatus
JOB_STATUS_WAITING :: JobStatus
JOB_STATUS_CANCELING :: JobStatus
JOB_STATUS_RUNNING :: JobStatus
JOB_STATUS_CANCELED :: JobStatus
JOB_STATUS_SUCCESS :: JobStatus
JOB_STATUS_ERROR :: JobStatus
jobStatusFromRaw :: Monad m_a15Zs => String -> m_a15Zs JobStatus
jobStatusToRaw :: JobStatus -> String

-- | Finalized job status.
data FinalizedJobStatus
JobStatusCanceled :: FinalizedJobStatus
JobStatusSuccessful :: FinalizedJobStatus
JobStatusFailed :: FinalizedJobStatus
finalizedJobStatusFromRaw :: Monad m_a163N => String -> m_a163N FinalizedJobStatus
finalizedJobStatusToRaw :: FinalizedJobStatus -> String

-- | The Ganeti job type.
newtype JobId
JobId :: Int -> JobId
fromJobId :: JobId -> Int

-- | Builds a job ID.
makeJobId :: Monad m => Int -> m JobId

-- | Builds a job ID from a string.
makeJobIdS :: Monad m => String -> m JobId
parseJobId :: Monad m => JSValue -> m JobId

-- | Relative job ID type alias.
type RelativeJobId = Negative Int

-- | Job ID dependency.
data JobIdDep
JobDepRelative :: RelativeJobId -> JobIdDep
JobDepAbsolute :: JobId -> JobIdDep
absoluteJobIdDep :: Monad m => JobIdDep -> JobId -> m JobIdDep

-- | Job Dependency type.
data JobDependency
JobDependency :: JobIdDep -> [FinalizedJobStatus] -> JobDependency

-- | From job dependency and job id compute an absolute job dependency.
absoluteJobDependency :: Monad m => JobDependency -> JobId -> m JobDependency

-- | From a job dependency get the absolute job id it depends on, if given
--   absolutely.
getJobIdFromDependency :: JobDependency -> [JobId]

-- | Valid opcode priorities for submit.
data OpSubmitPriority
OpPrioLow :: OpSubmitPriority
OpPrioNormal :: OpSubmitPriority
OpPrioHigh :: OpSubmitPriority
opSubmitPriorityFromRaw :: Monad m_a16fs => Int -> m_a16fs OpSubmitPriority
opSubmitPriorityToRaw :: OpSubmitPriority -> Int

-- | Parse submit priorities from a string.
parseSubmitPriority :: Monad m => String -> m OpSubmitPriority

-- | Format a submit priority as string.
fmtSubmitPriority :: OpSubmitPriority -> String

-- | Our ADT for the OpCode status at runtime (while in a job).
data OpStatus
OP_STATUS_QUEUED :: OpStatus
OP_STATUS_WAITING :: OpStatus
OP_STATUS_CANCELING :: OpStatus
OP_STATUS_RUNNING :: OpStatus
OP_STATUS_CANCELED :: OpStatus
OP_STATUS_SUCCESS :: OpStatus
OP_STATUS_ERROR :: OpStatus
opStatusFromRaw :: Monad m_a16kf => String -> m_a16kf OpStatus
opStatusToRaw :: OpStatus -> String

-- | Type for the job message type.
data ELogType
ELogMessage :: ELogType
ELogRemoteImport :: ELogType
ELogJqueueTest :: ELogType
ELogDelayTest :: ELogType
eLogTypeFromRaw :: Monad m_a16oI => String -> m_a16oI ELogType
eLogTypeToRaw :: ELogType -> String

-- | Type of one element of a reason trail, of form <tt>(source, reason,
--   timestamp)</tt>.
type ReasonElem = (String, String, Integer)

-- | Type representing a reason trail.
type ReasonTrail = [ReasonElem]

-- | The VTYPES, a mini-type system in Python.
data VType
VTypeString :: VType
VTypeMaybeString :: VType
VTypeBool :: VType
VTypeSize :: VType
VTypeInt :: VType
VTypeFloat :: VType
vTypeFromRaw :: Monad m_a16te => String -> m_a16te VType
vTypeToRaw :: VType -> String
data NodeRole
NROffline :: NodeRole
NRDrained :: NodeRole
NRRegular :: NodeRole
NRCandidate :: NodeRole
NRMaster :: NodeRole
nodeRoleFromRaw :: Monad m_a16y3 => String -> m_a16y3 NodeRole
nodeRoleToRaw :: NodeRole -> String

-- | The description of the node role.
roleDescription :: NodeRole -> String
data DiskMode
DiskRdOnly :: DiskMode
DiskRdWr :: DiskMode
diskModeFromRaw :: Monad m_a16C6 => String -> m_a16C6 DiskMode
diskModeToRaw :: DiskMode -> String

-- | The persistent block driver type. Currently only one type is allowed.
data BlockDriver
BlockDrvManual :: BlockDriver
blockDriverFromRaw :: Monad m_a16Fx => String -> m_a16Fx BlockDriver
blockDriverToRaw :: BlockDriver -> String
data AdminState
AdminOffline :: AdminState
AdminDown :: AdminState
AdminUp :: AdminState
adminStateFromRaw :: Monad m_a16J8 => String -> m_a16J8 AdminState
adminStateToRaw :: AdminState -> String
data AdminStateSource
AdminSource :: AdminStateSource
UserSource :: AdminStateSource
adminStateSourceFromRaw :: Monad m_a16MX => String -> m_a16MX AdminStateSource
adminStateSourceToRaw :: AdminStateSource -> String
data StorageField
SFUsed :: StorageField
SFName :: StorageField
SFAllocatable :: StorageField
SFFree :: StorageField
SFSize :: StorageField
storageFieldFromRaw :: Monad m_a16R4 => String -> m_a16R4 StorageField
storageFieldToRaw :: StorageField -> String
data DiskAccessMode
DiskUserspace :: DiskAccessMode
DiskKernelspace :: DiskAccessMode
diskAccessModeFromRaw :: Monad m_a16V5 => String -> m_a16V5 DiskAccessMode
diskAccessModeToRaw :: DiskAccessMode -> String

-- | Local disk status
--   
--   Python code depends on: DiskStatusOk &lt; DiskStatusUnknown &lt;
--   DiskStatusFaulty
data LocalDiskStatus
DiskStatusOk :: LocalDiskStatus
DiskStatusSync :: LocalDiskStatus
DiskStatusUnknown :: LocalDiskStatus
DiskStatusFaulty :: LocalDiskStatus
localDiskStatusFromRaw :: Monad m_a16YP => Int -> m_a16YP LocalDiskStatus
localDiskStatusToRaw :: LocalDiskStatus -> Int
_DiskStatusFaulty :: Int
_DiskStatusUnknown :: Int
_DiskStatusSync :: Int
_DiskStatusOk :: Int
localDiskStatusName :: LocalDiskStatus -> String

-- | Replace disks type.
data ReplaceDisksMode
ReplaceOnPrimary :: ReplaceDisksMode
ReplaceOnSecondary :: ReplaceDisksMode
ReplaceNewSecondary :: ReplaceDisksMode
ReplaceAuto :: ReplaceDisksMode
replaceDisksModeFromRaw :: Monad m_a172C => String -> m_a172C ReplaceDisksMode
replaceDisksModeToRaw :: ReplaceDisksMode -> String

-- | Basic timeouts for RPC calls.
data RpcTimeout
Urgent :: RpcTimeout
Fast :: RpcTimeout
Normal :: RpcTimeout
Slow :: RpcTimeout
FourHours :: RpcTimeout
OneDay :: RpcTimeout
rpcTimeoutFromRaw :: Monad m_a177l => Int -> m_a177l RpcTimeout
rpcTimeoutToRaw :: RpcTimeout -> Int
_OneDay :: Int
_FourHours :: Int
_Slow :: Int
_Normal :: Int
_Fast :: Int
_Urgent :: Int

-- | Hotplug action.
data HotplugAction
HAAdd :: HotplugAction
HARemove :: HotplugAction
HAMod :: HotplugAction
hotplugActionFromRaw :: Monad m_a17bc => String -> m_a17bc HotplugAction
hotplugActionToRaw :: HotplugAction -> String

-- | Hotplug Device Target.
data HotplugTarget
HTDisk :: HotplugTarget
HTNic :: HotplugTarget
hotplugTargetFromRaw :: Monad m_a17f1 => String -> m_a17f1 HotplugTarget
hotplugTargetToRaw :: HotplugTarget -> String

-- | A container for values that should be happy to be manipulated yet
--   refuses to be shown unless explicitly requested.
newtype Private a
Private :: a -> Private a
getPrivate :: Private a -> a
showPrivateJSObject :: JSON a => [(String, a)] -> JSObject (Private JSValue)

-- | The hypervisor parameter type. This is currently a simple map, without
--   type checking on key/value pairs.
type HvParams = Container JSValue

-- | The OS parameters type. This is, and will remain, a string container,
--   since the keys are dynamically declared by the OSes, and the values
--   are always strings.
type OsParams = Container String
type OsParamsPrivate = Container (Private String)

-- | Class of objects that have timestamps.
class TimeStampObject a
cTimeOf :: TimeStampObject a => a -> ClockTime
mTimeOf :: TimeStampObject a => a -> ClockTime

-- | Class of objects that have an UUID.
class UuidObject a
uuidOf :: UuidObject a => a -> String

-- | Class of objects that can be forthcoming.
class ForthcomingObject a
isForthcoming :: ForthcomingObject a => a -> Bool

-- | Class of object that have a serial number.
class SerialNoObject a
serialOf :: SerialNoObject a => a -> Int

-- | Class of objects that have tags.
class TagsObject a
tagsOf :: TagsObject a => a -> Set String
instance Eq a => Eq (Private a)
instance Ord a => Ord (Private a)
instance Functor Private
instance Monad Private
instance Applicative Private
instance PyValue a => PyValue (Private a)
instance Show a => Show (Private a)
instance (Show a, JSON a) => JSON (Private a)
instance JSON HotplugTarget
instance Show HotplugTarget
instance Eq HotplugTarget
instance Enum HotplugTarget
instance Bounded HotplugTarget
instance Ord HotplugTarget
instance JSON HotplugAction
instance Show HotplugAction
instance Eq HotplugAction
instance Enum HotplugAction
instance Bounded HotplugAction
instance Ord HotplugAction
instance Show RpcTimeout
instance Eq RpcTimeout
instance Enum RpcTimeout
instance Bounded RpcTimeout
instance Ord RpcTimeout
instance JSON ReplaceDisksMode
instance Show ReplaceDisksMode
instance Eq ReplaceDisksMode
instance Enum ReplaceDisksMode
instance Bounded ReplaceDisksMode
instance Ord ReplaceDisksMode
instance Show LocalDiskStatus
instance Eq LocalDiskStatus
instance Enum LocalDiskStatus
instance Bounded LocalDiskStatus
instance Ord LocalDiskStatus
instance JSON DiskAccessMode
instance Show DiskAccessMode
instance Eq DiskAccessMode
instance Enum DiskAccessMode
instance Bounded DiskAccessMode
instance Ord DiskAccessMode
instance JSON StorageField
instance Show StorageField
instance Eq StorageField
instance Enum StorageField
instance Bounded StorageField
instance Ord StorageField
instance PyValue AdminStateSource
instance JSON AdminStateSource
instance Show AdminStateSource
instance Eq AdminStateSource
instance Enum AdminStateSource
instance Bounded AdminStateSource
instance Ord AdminStateSource
instance JSON AdminState
instance Show AdminState
instance Eq AdminState
instance Enum AdminState
instance Bounded AdminState
instance Ord AdminState
instance JSON BlockDriver
instance Show BlockDriver
instance Eq BlockDriver
instance Enum BlockDriver
instance Bounded BlockDriver
instance Ord BlockDriver
instance JSON DiskMode
instance Show DiskMode
instance Eq DiskMode
instance Enum DiskMode
instance Bounded DiskMode
instance Ord DiskMode
instance JSON NodeRole
instance Show NodeRole
instance Eq NodeRole
instance Enum NodeRole
instance Bounded NodeRole
instance Ord NodeRole
instance PyValue VType
instance JSON VType
instance Show VType
instance Eq VType
instance Enum VType
instance Bounded VType
instance Ord VType
instance JSON ELogType
instance Show ELogType
instance Eq ELogType
instance Enum ELogType
instance Bounded ELogType
instance Ord ELogType
instance JSON OpStatus
instance Show OpStatus
instance Eq OpStatus
instance Enum OpStatus
instance Bounded OpStatus
instance Ord OpStatus
instance JSON OpSubmitPriority
instance Show OpSubmitPriority
instance Eq OpSubmitPriority
instance Enum OpSubmitPriority
instance Bounded OpSubmitPriority
instance Ord OpSubmitPriority
instance Show JobId
instance Eq JobId
instance Ord JobId
instance Show JobIdDep
instance Eq JobIdDep
instance Ord JobIdDep
instance Show JobDependency
instance Eq JobDependency
instance Ord JobDependency
instance JSON JobDependency
instance JSON JobIdDep
instance JSON JobId
instance JSON FinalizedJobStatus
instance Show FinalizedJobStatus
instance Eq FinalizedJobStatus
instance Enum FinalizedJobStatus
instance Bounded FinalizedJobStatus
instance Ord FinalizedJobStatus
instance JSON JobStatus
instance Show JobStatus
instance Eq JobStatus
instance Enum JobStatus
instance Bounded JobStatus
instance Ord JobStatus
instance JSON NICMode
instance Show NICMode
instance Eq NICMode
instance Enum NICMode
instance Bounded NICMode
instance Ord NICMode
instance JSON IAllocatorMode
instance Show IAllocatorMode
instance Eq IAllocatorMode
instance Enum IAllocatorMode
instance Bounded IAllocatorMode
instance Ord IAllocatorMode
instance JSON IAllocatorTestDir
instance Show IAllocatorTestDir
instance Eq IAllocatorTestDir
instance Enum IAllocatorTestDir
instance Bounded IAllocatorTestDir
instance Ord IAllocatorTestDir
instance JSON ExportMode
instance Show ExportMode
instance Eq ExportMode
instance Enum ExportMode
instance Bounded ExportMode
instance Ord ExportMode
instance JSON RebootType
instance Show RebootType
instance Eq RebootType
instance Enum RebootType
instance Bounded RebootType
instance Ord RebootType
instance JSON InstCreateMode
instance Show InstCreateMode
instance Eq InstCreateMode
instance Enum InstCreateMode
instance Bounded InstCreateMode
instance Ord InstCreateMode
instance JSON FileDriver
instance Show FileDriver
instance Eq FileDriver
instance Enum FileDriver
instance Bounded FileDriver
instance Ord FileDriver
instance JSON EvacMode
instance Show EvacMode
instance Eq EvacMode
instance Enum EvacMode
instance Bounded EvacMode
instance Ord EvacMode
instance Eq StorageUnit
instance JSON StorageUnit
instance Show StorageUnit
instance JSON StorageType
instance Show StorageType
instance Eq StorageType
instance Enum StorageType
instance Bounded StorageType
instance Ord StorageType
instance JSON OobStatus
instance Show OobStatus
instance Eq OobStatus
instance Enum OobStatus
instance Bounded OobStatus
instance Ord OobStatus
instance JSON OobCommand
instance Show OobCommand
instance Eq OobCommand
instance Enum OobCommand
instance Bounded OobCommand
instance Ord OobCommand
instance HasStringRepr Hypervisor
instance PyValue Hypervisor
instance JSON Hypervisor
instance Show Hypervisor
instance Eq Hypervisor
instance Enum Hypervisor
instance Bounded Hypervisor
instance Ord Hypervisor
instance JSON DdmFull
instance Show DdmFull
instance Eq DdmFull
instance Enum DdmFull
instance Bounded DdmFull
instance Ord DdmFull
instance JSON DdmSimple
instance Show DdmSimple
instance Eq DdmSimple
instance Enum DdmSimple
instance Bounded DdmSimple
instance Ord DdmSimple
instance JSON CVErrorCode
instance Show CVErrorCode
instance Eq CVErrorCode
instance Enum CVErrorCode
instance Bounded CVErrorCode
instance Ord CVErrorCode
instance JSON VerifyOptionalChecks
instance Show VerifyOptionalChecks
instance Eq VerifyOptionalChecks
instance Enum VerifyOptionalChecks
instance Bounded VerifyOptionalChecks
instance Ord VerifyOptionalChecks
instance JSON MigrationMode
instance Show MigrationMode
instance Eq MigrationMode
instance Enum MigrationMode
instance Bounded MigrationMode
instance Ord MigrationMode
instance JSON InstanceStatus
instance Show InstanceStatus
instance Eq InstanceStatus
instance Enum InstanceStatus
instance Bounded InstanceStatus
instance Ord InstanceStatus
instance JSON AllocPolicy
instance Show AllocPolicy
instance Eq AllocPolicy
instance Enum AllocPolicy
instance Bounded AllocPolicy
instance Ord AllocPolicy
instance JSON TagKind
instance Show TagKind
instance Eq TagKind
instance Enum TagKind
instance Bounded TagKind
instance Ord TagKind
instance HasStringRepr DiskTemplate
instance PyValue DiskTemplate
instance JSON DiskTemplate
instance Show DiskTemplate
instance Eq DiskTemplate
instance Enum DiskTemplate
instance Bounded DiskTemplate
instance Ord DiskTemplate
instance Show a => Show (NonNegative a)
instance Eq a => Eq (NonNegative a)
instance Ord a => Ord (NonNegative a)
instance Show a => Show (Positive a)
instance Eq a => Eq (Positive a)
instance Ord a => Ord (Positive a)
instance Show a => Show (Negative a)
instance Eq a => Eq (Negative a)
instance Ord a => Ord (Negative a)
instance Show a => Show (NonEmpty a)
instance Eq a => Eq (NonEmpty a)
instance Ord a => Ord (NonEmpty a)
instance Show IPv4Address
instance Eq IPv4Address
instance Ord IPv4Address
instance Show IPv4Network
instance Eq IPv4Network
instance Ord IPv4Network
instance Show IPv6Address
instance Eq IPv6Address
instance Ord IPv6Address
instance Show IPv6Network
instance Eq IPv6Network
instance Ord IPv6Network
instance JSON IPv6Network
instance JSON IPv6Address
instance JSON IPv4Network
instance JSON IPv4Address
instance JSON a => JSON (NonEmpty a)
instance (JSON a, Num a, Ord a, Show a) => JSON (Negative a)
instance (JSON a, Num a, Ord a, Show a) => JSON (Positive a)
instance (JSON a, Num a, Ord a, Show a) => JSON (NonNegative a)


-- | Some common types.
module Ganeti.HTools.Types

-- | The instance index type.
type Idx = Int

-- | The node index type.
type Ndx = Int

-- | The group index type.
type Gdx = Int

-- | The type used to hold name-to-idx mappings.
type NameAssoc = Map String Int

-- | A separate name for the cluster score type.
type Score = Double

-- | A separate name for a weight metric.
type Weight = Double

-- | The Group UUID type.
type GroupID = String

-- | Default group UUID (just a string, not a real UUID).
defaultGroupID :: GroupID

-- | Mirroring type.
data MirrorType

-- | No mirroring/movability
MirrorNone :: MirrorType

-- | DRBD-type mirroring
MirrorInternal :: MirrorType

-- | Shared-storage type mirroring
MirrorExternal :: MirrorType

-- | Correspondence between disk template and mirror type.
templateMirrorType :: DiskTemplate -> MirrorType

-- | The resource spec type.
data RSpec
RSpec :: Int -> Int -> Int -> Int -> RSpec

-- | Requested VCPUs
rspecCpu :: RSpec -> Int

-- | Requested memory
rspecMem :: RSpec -> Int

-- | Requested disk
rspecDsk :: RSpec -> Int

-- | Requested spindles
rspecSpn :: RSpec -> Int

-- | Allocation stats type. This is used instead of <a>RSpec</a> (which was
--   used at first), because we need to track more stats. The actual data
--   can refer either to allocated, or available, etc. values depending on
--   the context. See also <a>computeAllocationDelta</a>.
data AllocInfo
AllocInfo :: Int -> Double -> Int -> Int -> Int -> AllocInfo

-- | VCPUs
allocInfoVCpus :: AllocInfo -> Int

-- | Normalised CPUs
allocInfoNCpus :: AllocInfo -> Double

-- | Memory
allocInfoMem :: AllocInfo -> Int

-- | Disk
allocInfoDisk :: AllocInfo -> Int

-- | Spindles
allocInfoSpn :: AllocInfo -> Int

-- | Currently used, possibly to allocate, unallocable.
type AllocStats = (AllocInfo, AllocInfo, AllocInfo)

-- | The network UUID type.
type NetworkID = String

-- | Instance specification type.
data ISpec
ISpec :: Int -> Int -> Int -> Int -> Int -> Int -> ISpec
iSpecMemorySize :: ISpec -> Int
iSpecCpuCount :: ISpec -> Int
iSpecDiskSize :: ISpec -> Int
iSpecDiskCount :: ISpec -> Int
iSpecNicCount :: ISpec -> Int
iSpecSpindleUse :: ISpec -> Int
loadISpec :: JSValue -> Result ISpec
saveISpec :: ISpec -> JSValue

-- | The default minimum ispec.
defMinISpec :: ISpec

-- | The default standard ispec.
defStdISpec :: ISpec
maxDisks :: Int
maxNics :: Int

-- | The default max ispec.
defMaxISpec :: ISpec

-- | Minimum and maximum instance specs type.
data MinMaxISpecs
MinMaxISpecs :: ISpec -> ISpec -> MinMaxISpecs
minMaxISpecsMinSpec :: MinMaxISpecs -> ISpec
minMaxISpecsMaxSpec :: MinMaxISpecs -> ISpec
loadMinMaxISpecs :: JSValue -> Result MinMaxISpecs
saveMinMaxISpecs :: MinMaxISpecs -> JSValue
defMinMaxISpecs :: [MinMaxISpecs]

-- | Instance policy type.
data IPolicy
IPolicy :: [MinMaxISpecs] -> ISpec -> [DiskTemplate] -> Double -> Double -> IPolicy
iPolicyMinMaxISpecs :: IPolicy -> [MinMaxISpecs]
iPolicyStdSpec :: IPolicy -> ISpec
iPolicyDiskTemplates :: IPolicy -> [DiskTemplate]
iPolicyVcpuRatio :: IPolicy -> Double
iPolicySpindleRatio :: IPolicy -> Double
loadIPolicy :: JSValue -> Result IPolicy
saveIPolicy :: IPolicy -> JSValue

-- | Converts an ISpec type to a RSpec one.
rspecFromISpec :: ISpec -> RSpec

-- | The default instance policy.
defIPolicy :: IPolicy

-- | The dynamic resource specs of a machine (i.e. load or load capacity,
--   as opposed to size).
data DynUtil
DynUtil :: Weight -> Weight -> Weight -> Weight -> DynUtil

-- | Standardised CPU usage
cpuWeight :: DynUtil -> Weight

-- | Standardised memory load
memWeight :: DynUtil -> Weight

-- | Standardised disk I/O usage
dskWeight :: DynUtil -> Weight

-- | Standardised network usage
netWeight :: DynUtil -> Weight

-- | Initial empty utilisation.
zeroUtil :: DynUtil

-- | Base utilisation (used when no actual utilisation data is supplied).
baseUtil :: DynUtil

-- | Sum two utilisation records.
addUtil :: DynUtil -> DynUtil -> DynUtil

-- | Substracts one utilisation record from another.
subUtil :: DynUtil -> DynUtil -> DynUtil

-- | The description of an instance placement. It contains the instance
--   index, the new primary and secondary node, the move being performed
--   and the score of the cluster after the move.
type Placement = (Idx, Ndx, Ndx, IMove, Score)

-- | An instance move definition.
data IMove

-- | Failover the instance (f)
Failover :: IMove

-- | Failover to a random node (fa:np), for shared storage
FailoverToAny :: Ndx -> IMove

-- | Replace primary (f, r:np, f)
ReplacePrimary :: Ndx -> IMove

-- | Replace secondary (r:ns)
ReplaceSecondary :: Ndx -> IMove

-- | Replace secondary, failover (r:np, f)
ReplaceAndFailover :: Ndx -> IMove

-- | Failover, replace secondary (f, r:ns)
FailoverAndReplace :: Ndx -> IMove

-- | Formatted solution output for one move (involved nodes and commands.
type MoveJob = ([Ndx], Idx, IMove, [String])

-- | Unknown field in table output.
unknownField :: String

-- | A list of command elements.
type JobSet = [MoveJob]

-- | Default max disk usage ratio.
defReservedDiskRatio :: Double

-- | Base memory unit.
unitMem :: Int

-- | Base disk unit.
unitDsk :: Int

-- | Base vcpus unit.
unitCpu :: Int

-- | Base spindles unit.
unitSpindle :: Int

-- | Reason for an operation's falure.
data FailMode

-- | Failed due to not enough RAM
FailMem :: FailMode

-- | Failed due to not enough disk
FailDisk :: FailMode

-- | Failed due to not enough CPU capacity
FailCPU :: FailMode

-- | Failed due to not passing N1 checks
FailN1 :: FailMode

-- | Failed due to tag exclusion
FailTags :: FailMode

-- | Failed due to migration restrictions
FailMig :: FailMode

-- | Failed due to wrong number of disks
FailDiskCount :: FailMode

-- | Failed due to wrong/missing spindles
FailSpindles :: FailMode

-- | Internal error
FailInternal :: FailMode

-- | List with failure statistics.
type FailStats = [(FailMode, Int)]

-- | Either-like data-type customized for our failure modes.
--   
--   The failure values for this monad track the specific allocation
--   failures, so this is not a general error-monad (compare with the
--   <a>Result</a> data type). One downside is that this type cannot encode
--   a generic failure mode, hence our way to build a FailMode from string
--   will instead raise an exception.
type OpResult = GenericResult FailMode

-- | Conversion from <a>OpResult</a> to <a>Result</a>.
opToResult :: OpResult a -> Result a

-- | A generic class for items that have updateable names and indices.
class Element a where computeAlias dom e = setAlias e alias where alias = take (length name - length dom) name name = nameOf e
nameOf :: Element a => a -> String
allNames :: Element a => a -> [String]
idxOf :: Element a => a -> Int
setAlias :: Element a => a -> String -> a
computeAlias :: Element a => String -> a -> a
setIdx :: Element a => a -> Int -> a

-- | The repair modes for the auto-repair tool.
data AutoRepairType
ArFixStorage :: AutoRepairType
ArMigrate :: AutoRepairType
ArFailover :: AutoRepairType
ArReinstall :: AutoRepairType
autoRepairTypeFromRaw :: Monad m_a1zbs => String -> m_a1zbs AutoRepairType
autoRepairTypeToRaw :: AutoRepairType -> String

-- | The possible auto-repair results.
data AutoRepairResult
ArEnoperm :: AutoRepairResult
ArSuccess :: AutoRepairResult
ArFailure :: AutoRepairResult
autoRepairResultFromRaw :: Monad m_a1zf1 => String -> m_a1zf1 AutoRepairResult
autoRepairResultToRaw :: AutoRepairResult -> String

-- | The possible auto-repair policy for a given instance.
data AutoRepairPolicy

-- | Auto-repair explicitly enabled
ArEnabled :: AutoRepairType -> AutoRepairPolicy

-- | Suspended temporarily, or forever
ArSuspended :: AutoRepairSuspendTime -> AutoRepairPolicy

-- | Auto-repair not explicitly enabled
ArNotEnabled :: AutoRepairPolicy

-- | The suspend timeout for <a>ArSuspended</a>.
data AutoRepairSuspendTime

-- | Permanently suspended
Forever :: AutoRepairSuspendTime

-- | Suspended up to a certain time
Until :: ClockTime -> AutoRepairSuspendTime

-- | The possible auto-repair states for any given instance.
data AutoRepairStatus

-- | No problems detected with the instance
ArHealthy :: (Maybe AutoRepairData) -> AutoRepairStatus

-- | Instance has problems, no action taken
ArNeedsRepair :: AutoRepairData -> AutoRepairStatus

-- | Repair jobs ongoing for the instance
ArPendingRepair :: AutoRepairData -> AutoRepairStatus

-- | Some repair jobs for the instance failed
ArFailedRepair :: AutoRepairData -> AutoRepairStatus

-- | The data accompanying a repair operation (future, pending, or failed).
data AutoRepairData
AutoRepairData :: AutoRepairType -> String -> ClockTime -> [JobId] -> Maybe AutoRepairResult -> String -> AutoRepairData
arType :: AutoRepairData -> AutoRepairType
arUuid :: AutoRepairData -> String
arTime :: AutoRepairData -> ClockTime
arJobs :: AutoRepairData -> [JobId]
arResult :: AutoRepairData -> Maybe AutoRepairResult
arTag :: AutoRepairData -> String
instance Show AutoRepairResult
instance Eq AutoRepairResult
instance Enum AutoRepairResult
instance Bounded AutoRepairResult
instance Ord AutoRepairResult
instance Eq AutoRepairSuspendTime
instance Show AutoRepairSuspendTime
instance Eq AutoRepairPolicy
instance Show AutoRepairPolicy
instance Eq AutoRepairData
instance Show AutoRepairData
instance Eq AutoRepairStatus
instance Show AutoRepairStatus
instance Show AutoRepairType
instance Eq AutoRepairType
instance Enum AutoRepairType
instance Bounded AutoRepairType
instance Ord AutoRepairType
instance Show IPolicy
instance Eq IPolicy
instance Show DynUtil
instance Eq DynUtil
instance Show IMove
instance Eq FailMode
instance Enum FailMode
instance Bounded FailMode
instance Show FailMode
instance Error FailMode
instance JSON IPolicy
instance ArrayObject IPolicy
instance DictObject IPolicy
instance Show MinMaxISpecs
instance Eq MinMaxISpecs
instance JSON MinMaxISpecs
instance ArrayObject MinMaxISpecs
instance DictObject MinMaxISpecs
instance Show ISpec
instance Eq ISpec
instance JSON ISpec
instance ArrayObject ISpec
instance DictObject ISpec
instance Eq MirrorType
instance Show MirrorType
instance Show RSpec
instance Eq RSpec
instance Show AllocInfo
instance Eq AllocInfo


-- | Constants contains the Haskell constants
--   
--   The constants in this module are used in Haskell and are also
--   converted to Python.
--   
--   Do not write any definitions in this file other than constants. Do not
--   even write helper functions. The definitions in this module are
--   automatically stripped to build the Makefile.am target <a>hs</a>. If
--   there are helper functions in this module, they will also be dragged
--   and it will cause compilation to fail. Therefore, all helper functions
--   should go to a separate module and imported.
module Ganeti.Constants
htoolsProgs :: [String]
drbdBarriers :: String
drbdNoMetaFlush :: Bool
lvmStripecount :: Int
hasGnuLn :: Bool
exportDir :: String
backupDir :: String
osSearchPath :: [String]
esSearchPath :: [String]
sshConfigDir :: String
xenConfigDir :: String
sysconfdir :: String
toolsdir :: String
localstatedir :: String
pkglibdir :: String
sharedir :: String
manPages :: Map String Int
versionedsharedir :: String
gntScripts :: [String]
releaseVersion :: String
versionMajor :: Int
versionMinor :: Int
versionRevision :: Int
dirVersion :: String
osApiV10 :: Int
osApiV15 :: Int
osApiV20 :: Int
osApiVersions :: FrozenSet Int

-- | The version of the backup/export instance description file format we
--   are producing when exporting and accepting when importing. The two are
--   currently tightly intertwined.
exportVersion :: Int
rapiVersion :: Int
configMajor :: Int
configMinor :: Int

-- | The configuration is supposed to remain stable across revisions.
--   Therefore, the revision number is cleared to '0'.
configRevision :: Int
configVersion :: Int

-- | Similarly to the configuration (see <a>configRevision</a>), the
--   protocols are supposed to remain stable across revisions.
protocolVersion :: Int
daemonsGroup :: String
adminGroup :: String
masterdUser :: String
masterdGroup :: String
metadUser :: String
metadGroup :: String
rapiUser :: String
rapiGroup :: String
confdUser :: String
confdGroup :: String
wconfdUser :: String
wconfdGroup :: String
kvmdUser :: String
kvmdGroup :: String
luxidUser :: String
luxidGroup :: String
nodedUser :: String
nodedGroup :: String
mondUser :: String
mondGroup :: String
sshLoginUser :: String
sshConsoleUser :: String
cpuPinningSep :: String
cpuPinningAll :: String

-- | Internal representation of <a>all</a>
cpuPinningAllVal :: Int

-- | One <a>all</a> entry in a CPU list means CPU pinning is off
cpuPinningOff :: [Int]

-- | A Xen-specific implementation detail is that there is no way to
--   actually say <a>use any cpu for pinning</a> in a Xen configuration
--   file, as opposed to the command line, where you can say <tt> xm
--   vcpu-pin <a>domain</a> <a>vcpu</a> all </tt>
--   
--   The workaround used in Xen is <a>0-63</a> (see source code function
--   <a>xm_vcpu_pin</a> in
--   <tt><a>xen-source</a><i>tools</i>python<i>xen</i>xm/main.py</tt>).
--   
--   To support future changes, the following constant is treated as a
--   blackbox string that simply means <a>use any cpu for pinning under
--   xen</a>.
cpuPinningAllXen :: String
ddCmd :: String

-- | 1 MiB The default block size for the <tt>dd</tt> command
ddBlockSize :: Int

-- | 1GB
maxWipeChunk :: Int
minWipeChunkPercent :: Int
runDirsMode :: Int
secureDirMode :: Int
secureFileMode :: Int
adoptableBlockdevRoot :: String
enableMond :: Bool
enableMetad :: Bool
enableRestrictedCommands :: Bool
ssh :: String
scp :: String
confd :: String
masterd :: String
metad :: String
mond :: String
noded :: String
wconfd :: String
luxid :: String
rapi :: String
kvmd :: String
daemonsMaster :: FrozenSet String
daemons :: FrozenSet String
defaultConfdPort :: Int
defaultMondPort :: Int
defaultMetadPort :: Int
defaultNodedPort :: Int
defaultRapiPort :: Int
daemonsPorts :: Map String (Protocol, Int)
firstDrbdPort :: Int
lastDrbdPort :: Int
daemonsLogbase :: Map String String
daemonsExtraLogbase :: Map String (Map String String)
extraLogreasonAccess :: String
extraLogreasonError :: String
devConsole :: String
procMounts :: String
luxiEom :: PythonChar

-- | Environment variable for the luxi override socket
luxiOverride :: String
luxiOverrideMaster :: String
luxiOverrideQuery :: String
luxiVersion :: Int
syslogUsage :: String
syslogNo :: String
syslogYes :: String
syslogOnly :: String
syslogSocket :: String
exportConfFile :: String
xenBootloader :: String
xenCmdXl :: String
xenCmdXm :: String
xenInitrd :: String
xenKernel :: String
xlSocatCmd :: String
xlMigrationPidfile :: String
knownXenCommands :: FrozenSet String
kvmPath :: String
kvmKernel :: String
socatEscapeCode :: String
socatPath :: String
socatUseCompress :: Bool
socatUseEscape :: Bool
lxcDevicesDefault :: String
lxcDropCapabilitiesDefault :: String
lxcStateRunning :: String

-- | Display a message for console access
consMessage :: String

-- | Console as SPICE server
consSpice :: String

-- | Console as SSH command
consSsh :: String

-- | Console as VNC server
consVnc :: String
consAll :: FrozenSet String

-- | RSA key bit length
--   
--   For RSA keys more bits are better, but they also make operations more
--   expensive. NIST SP 800-131 recommends a minimum of 2048 bits from the
--   year 2010 on.
rsaKeyBits :: Int

-- | Ciphers allowed for SSL connections.
--   
--   For the format, see ciphers(1). A better way to disable ciphers would
--   be to use the exclamation mark (!), but socat versions below 1.5 can't
--   parse exclamation marks in options properly. When modifying the
--   ciphers, ensure not to accidentially add something after it's been
--   removed. Use the <a>openssl</a> utility to check the allowed ciphers,
--   e.g. <a>openssl ciphers -v HIGH:-DES</a>.
opensslCiphers :: String

-- | commonName (CN) used in certificates
x509CertCn :: String

-- | Default validity of certificates in days
x509CertDefaultValidity :: Int
x509CertSignatureHeader :: String

-- | Digest used to sign certificates (<a>openssl x509</a> uses SHA1 by
--   default)
x509CertSignDigest :: String
iemExport :: String
iemImport :: String
iecGzip :: String
iecGzipFast :: String
iecGzipSlow :: String
iecLzop :: String
iecNone :: String
iecAll :: [String]
iecDefaultTools :: [String]
iecCompressionUtilities :: Map String String
ieCustomSize :: String

-- | Direct file I<i>O, equivalent to a shell's I</i>O redirection using
--   <a>&lt;</a> or <a>&gt;</a>
ieioFile :: String

-- | Raw block device I/O using <a>dd</a>
ieioRawDisk :: String

-- | OS definition import/export script
ieioScript :: String
valueDefault :: String
valueAuto :: String
valueGenerate :: String
valueNone :: String
valueTrue :: String
valueFalse :: String
hooksNameCfgupdate :: String
hooksNameWatcher :: String
hooksPath :: String
hooksPhasePost :: String
hooksPhasePre :: String
hooksVersion :: Int
htypeCluster :: String
htypeGroup :: String
htypeInstance :: String
htypeNetwork :: String
htypeNode :: String
hkrSkip :: Int
hkrFail :: Int
hkrSuccess :: Int
stBlock :: String
stDiskless :: String
stExt :: String
stFile :: String
stSharedFile :: String
stGluster :: String
stLvmPv :: String
stLvmVg :: String
stRados :: String
storageTypes :: FrozenSet String

-- | The set of storage types for which full storage reporting is available
stsReport :: FrozenSet String

-- | The set of storage types for which node storage reporting is available
--   | (as used by LUQueryNodeStorage)
stsReportNodeStorage :: FrozenSet String
sfNode :: String
sfType :: String
sfAllocatable :: String
sfFree :: String
sfName :: String
sfSize :: String
sfUsed :: String
validStorageFields :: FrozenSet String
modifiableStorageFields :: Map String (FrozenSet String)
soFixConsistency :: String
validStorageOperations :: Map String (FrozenSet String)
vfDev :: String
vfInstance :: String
vfName :: String
vfNode :: String
vfPhys :: String
vfSize :: String
vfVg :: String
ldsFaulty :: Int
ldsOkay :: Int
ldsUnknown :: Int
ldsSync :: Int
ldsNames :: Map Int String
dtDiskless :: String
dtFile :: String
dtSharedFile :: String
dtPlain :: String
dtBlock :: String
dtDrbd8 :: String
dtRbd :: String
dtExt :: String
dtGluster :: String
dtMixed :: String

-- | This is used to order determine the default disk template when the
--   list of enabled disk templates is inferred from the current state of
--   the cluster. This only happens on an upgrade from a version of Ganeti
--   that did not support the <tt>enabled_disk_templates</tt> so far.
diskTemplatePreference :: [String]
diskTemplates :: FrozenSet String

-- | Disk templates that are enabled by default
defaultEnabledDiskTemplates :: [String]

-- | Mapping of disk templates to storage types
mapDiskTemplateStorageType :: Map String String

-- | The set of network-mirrored disk templates
dtsIntMirror :: FrozenSet String

-- | <a>DTDiskless</a> is <tt>trivially</tt> externally mirrored
dtsExtMirror :: FrozenSet String

-- | The set of non-lvm-based disk templates
dtsNotLvm :: FrozenSet String

-- | The set of disk templates which can be grown
dtsGrowable :: FrozenSet String

-- | The set of disk templates that allow adoption
dtsMayAdopt :: FrozenSet String

-- | The set of disk templates that *must* use adoption
dtsMustAdopt :: FrozenSet String

-- | The set of disk templates that allow migrations
dtsMirrored :: FrozenSet String

-- | The set of file based disk templates
dtsFilebased :: FrozenSet String

-- | The set of file based disk templates whose path is tied to the
--   instance name
dtsInstanceDependentPath :: FrozenSet String

-- | The set of disk templates that can be moved by copying
--   
--   Note: a requirement is that they're not accessed externally or shared
--   between nodes; in particular, sharedfile is not suitable.
dtsCopyable :: FrozenSet String

-- | The set of disk templates which can be snapshot.
dtsSnapshotCapable :: FrozenSet String

-- | The set of disk templates that are supported by exclusive_storage
dtsExclStorage :: FrozenSet String

-- | Templates for which we don't perform checks on free space
dtsNoFreeSpaceCheck :: FrozenSet String
dtsBlock :: FrozenSet String

-- | The set of lvm-based disk templates
dtsLvm :: FrozenSet String

-- | The set of lvm-based disk templates
dtsHaveAccess :: FrozenSet String

-- | The set of disk templates that cannot convert from
dtsNotConvertibleFrom :: FrozenSet String

-- | The set of disk templates that cannot convert to
dtsNotConvertibleTo :: FrozenSet String
drbdHmacAlg :: String
drbdDefaultNetProtocol :: String
drbdMigrationNetProtocol :: String
drbdStatusFile :: String

-- | The length of generated DRBD secrets (see also TempRes module).
drbdSecretLength :: Int

-- | Size of DRBD meta block device
drbdMetaSize :: Int
drbdBDiskBarriers :: String
drbdBDiskDrain :: String
drbdBDiskFlush :: String
drbdBNone :: String

-- | Valid barrier combinations: <a>n</a> or any non-null subset of
--   <a>bfd</a>
drbdValidBarrierOpt :: FrozenSet (FrozenSet String)

-- | Rbd tool command
rbdCmd :: String
fdBlktap :: String
fdBlktap2 :: String
fdLoop :: String
fdDefault :: String
fileDriver :: FrozenSet String

-- | The set of drbd-like disk types
dtsDrbd :: FrozenSet String
diskRdonly :: String
diskRdwr :: String
diskAccessSet :: FrozenSet String
replaceDiskAuto :: String
replaceDiskChg :: String
replaceDiskPri :: String
replaceDiskSec :: String
replaceModes :: FrozenSet String
exportModeLocal :: String
exportModeRemote :: String
exportModes :: FrozenSet String
instanceCreate :: String
instanceImport :: String
instanceRemoteImport :: String
instanceCreateModes :: FrozenSet String
rieHandshake :: String
rieVersion :: Int

-- | Remote import/export certificate validity (seconds)
rieCertValidity :: Int

-- | Export only: how long to wait per connection attempt (seconds)
rieConnectAttemptTimeout :: Int

-- | Export only: number of attempts to connect
rieConnectRetries :: Int

-- | Overall timeout for establishing connection
rieConnectTimeout :: Int

-- | Give child process up to 5 seconds to exit after sending a signal
childLingerTimeout :: Double
inisectBep :: String
inisectExp :: String
inisectHyp :: String
inisectIns :: String
inisectOsp :: String
inisectOspPrivate :: String
ddmAdd :: String
ddmAttach :: String
ddmModify :: String
ddmRemove :: String
ddmDetach :: String
ddmsValues :: FrozenSet String
ddmsValuesWithModify :: FrozenSet String
exitSuccess :: Int
exitFailure :: Int
exitNotcluster :: Int
exitNotmaster :: Int
exitNodesetupError :: Int

-- | Need user confirmation
exitConfirmation :: Int

-- | Exit code for query operations with unknown fields
exitUnknownField :: Int
tagCluster :: String
tagInstance :: String
tagNetwork :: String
tagNode :: String
tagNodegroup :: String
validTagTypes :: FrozenSet String
maxTagLen :: Int
maxTagsPerObj :: Int
defaultBridge :: String
defaultOvs :: String

-- | 60 MiB<i>s, expressed in KiB</i>s
classicDrbdSyncSpeed :: Int
ip4AddressAny :: String
ip4AddressLocalhost :: String
ip6AddressAny :: String
ip6AddressLocalhost :: String
ip4Version :: Int
ip6Version :: Int
validIpVersions :: FrozenSet Int
tcpPingTimeout :: Int
defaultVg :: String
defaultDrbdHelper :: String
minVgSize :: Int
defaultMacPrefix :: String

-- | Default maximum instance wait time (seconds)
defaultShutdownTimeout :: Int

-- | Node clock skew (seconds)
nodeMaxClockSkew :: Int

-- | Time for an intra-cluster disk transfer to wait for a connection
diskTransferConnectTimeout :: Int

-- | Disk index separator
diskSeparator :: String
ipCommandPath :: String

-- | Key for job IDs in opcode result
jobIdsKey :: String
runpartsErr :: Int
runpartsRun :: Int
runpartsSkip :: Int
runpartsStatus :: [Int]
rpcEncodingNone :: Int
rpcEncodingZlibBase64 :: Int
rpcTmoUrgent :: Int
rpcTmoFast :: Int
rpcTmoNormal :: Int
rpcTmoSlow :: Int

-- | <a>rpcTmo_4hrs</a> contains an underscore to circumvent a limitation
--   in the <a>deCamelCase</a> function and generate the correct Python
--   name.
rpcTmo_4hrs :: Int

-- | <a>rpcTmo_1day</a> contains an underscore to circumvent a limitation
--   in the <a>deCamelCase</a> function and generate the correct Python
--   name.
rpcTmo_1day :: Int

-- | Timeout for connecting to nodes (seconds)
rpcConnectTimeout :: Int
osScriptCreate :: String
osScriptCreateUntrusted :: String
osScriptExport :: String
osScriptImport :: String
osScriptRename :: String
osScriptVerify :: String
osScripts :: [String]
osApiFile :: String
osVariantsFile :: String
osParametersFile :: String
osValidateParameters :: String
osValidateCalls :: FrozenSet String

-- | External Storage (ES) related constants
esActionAttach :: String
esActionCreate :: String
esActionDetach :: String
esActionGrow :: String
esActionRemove :: String
esActionSetinfo :: String
esActionVerify :: String
esActionSnapshot :: String
esActionOpen :: String
esActionClose :: String
esScriptCreate :: String
esScriptRemove :: String
esScriptGrow :: String
esScriptAttach :: String
esScriptDetach :: String
esScriptSetinfo :: String
esScriptVerify :: String
esScriptSnapshot :: String
esScriptOpen :: String
esScriptClose :: String
esScripts :: FrozenSet String
esParametersFile :: String
instanceRebootSoft :: String
instanceRebootHard :: String
instanceRebootFull :: String
rebootTypes :: FrozenSet String
instanceRebootAllowed :: String
instanceRebootExit :: String
rebootBehaviors :: [String]
vtypeBool :: VType
vtypeInt :: VType
vtypeFloat :: VType
vtypeMaybeString :: VType

-- | Size in MiBs
vtypeSize :: VType
vtypeString :: VType
enforceableTypes :: FrozenSet VType

-- | Constant representing that the user does not specify any IP version
ifaceNoIpVersionSpecified :: Int
validSerialSpeeds :: [Int]
hvAcpi :: String
hvBlockdevPrefix :: String
hvBootloaderArgs :: String
hvBootloaderPath :: String
hvBootOrder :: String
hvCdromImagePath :: String
hvCpuCap :: String
hvCpuCores :: String
hvCpuMask :: String
hvCpuSockets :: String
hvCpuThreads :: String
hvCpuType :: String
hvCpuWeight :: String
hvDeviceModel :: String
hvDiskCache :: String
hvDiskType :: String
hvInitrdPath :: String
hvInitScript :: String
hvKernelArgs :: String
hvKernelPath :: String
hvKeymap :: String
hvKvmCdrom2ImagePath :: String
hvKvmCdromDiskType :: String
hvKvmExtra :: String
hvKvmFlag :: String
hvKvmFloppyImagePath :: String
hvKvmMachineVersion :: String
hvKvmMigrationCaps :: String
hvKvmPath :: String
hvKvmDiskAio :: String
hvKvmSpiceAudioCompr :: String
hvKvmSpiceBind :: String
hvKvmSpiceIpVersion :: String
hvKvmSpiceJpegImgCompr :: String
hvKvmSpiceLosslessImgCompr :: String
hvKvmSpicePasswordFile :: String
hvKvmSpiceStreamingVideoDetection :: String
hvKvmSpiceTlsCiphers :: String
hvKvmSpiceUseTls :: String
hvKvmSpiceUseVdagent :: String
hvKvmSpiceZlibGlzImgCompr :: String
hvKvmUseChroot :: String
hvKvmUserShutdown :: String
hvLxcStartupTimeout :: String
hvLxcExtraCgroups :: String
hvLxcDevices :: String
hvLxcDropCapabilities :: String
hvLxcExtraConfig :: String
hvLxcNumTtys :: String
hvMemPath :: String
hvMigrationBandwidth :: String
hvMigrationDowntime :: String
hvMigrationMode :: String
hvMigrationPort :: String
hvNicType :: String
hvPae :: String
hvPassthrough :: String
hvRebootBehavior :: String
hvRootPath :: String
hvSecurityDomain :: String
hvSecurityModel :: String
hvSerialConsole :: String
hvSerialSpeed :: String
hvSoundhw :: String
hvUsbDevices :: String
hvUsbMouse :: String
hvUseBootloader :: String
hvUseLocaltime :: String
hvVga :: String
hvVhostNet :: String
hvVirtioNetQueues :: String
hvVifScript :: String
hvVifType :: String
hvViridian :: String
hvVncBindAddress :: String
hvVncPasswordFile :: String
hvVncTls :: String
hvVncX509 :: String
hvVncX509Verify :: String
hvVnetHdr :: String
hvXenCmd :: String
hvXenCpuid :: String
hvsParameterTitles :: Map String String
hvsParameters :: FrozenSet String
hvsParameterTypes :: Map String VType
hvMigrationActive :: String
hvMigrationCancelled :: String
hvMigrationCompleted :: String
hvMigrationFailed :: String
hvMigrationValidStatuses :: FrozenSet String
hvMigrationFailedStatuses :: FrozenSet String

-- | KVM-specific statuses
--   
--   FIXME: this constant seems unnecessary
hvKvmMigrationValidStatuses :: FrozenSet String

-- | Node info keys
hvNodeinfoKeyVersion :: String
hvstCpuNode :: String
hvstCpuTotal :: String
hvstMemoryHv :: String
hvstMemoryNode :: String
hvstMemoryTotal :: String
hvstsParameters :: FrozenSet String
hvstDefaults :: Map String Int
hvstsParameterTypes :: Map String VType
dsDiskOverhead :: String
dsDiskReserved :: String
dsDiskTotal :: String
dsDefaults :: Map String Int
dssParameterTypes :: Map String VType
dssParameters :: FrozenSet String
dsValidTypes :: FrozenSet String
beAlwaysFailover :: String
beAutoBalance :: String
beMaxmem :: String

-- | Deprecated and replaced by max and min mem
beMemory :: String
beMinmem :: String
beSpindleUse :: String
beVcpus :: String
besParameterTypes :: Map String VType
besParameterTitles :: Map String String
besParameterCompat :: Map String VType
besParameters :: FrozenSet String

-- | Instance specs
--   
--   FIXME: these should be associated with <a>ISpec</a>
ispecMemSize :: String
ispecCpuCount :: String
ispecDiskCount :: String
ispecDiskSize :: String
ispecNicCount :: String
ispecSpindleUse :: String
ispecsParameterTypes :: Map String VType
ispecsParameters :: FrozenSet String
ispecsMinmax :: String
ispecsMax :: String
ispecsMin :: String
ispecsStd :: String
ipolicyDts :: String
ipolicyVcpuRatio :: String
ipolicySpindleRatio :: String
ispecsMinmaxKeys :: FrozenSet String
ipolicyParameters :: FrozenSet String
ipolicyAllKeys :: FrozenSet String

-- | Node parameter names
ndExclusiveStorage :: String
ndOobProgram :: String
ndSpindleCount :: String
ndOvs :: String
ndOvsLink :: String
ndOvsName :: String
ndSshPort :: String
ndCpuSpeed :: String
ndsParameterTypes :: Map String VType
ndsParameters :: FrozenSet String
ndsParameterTitles :: Map String String
ldpAccess :: String
ldpBarriers :: String
ldpDefaultMetavg :: String
ldpDelayTarget :: String
ldpDiskCustom :: String
ldpDynamicResync :: String
ldpFillTarget :: String
ldpMaxRate :: String
ldpMinRate :: String
ldpNetCustom :: String
ldpNoMetaFlush :: String
ldpPlanAhead :: String
ldpPool :: String
ldpProtocol :: String
ldpResyncRate :: String
ldpStripes :: String
diskLdTypes :: Map String VType
diskLdParameters :: FrozenSet String
drbdResyncRate :: String
drbdDataStripes :: String
drbdMetaStripes :: String
drbdDiskBarriers :: String
drbdMetaBarriers :: String
drbdDefaultMetavg :: String
drbdDiskCustom :: String
drbdNetCustom :: String
drbdProtocol :: String
drbdDynamicResync :: String
drbdPlanAhead :: String
drbdFillTarget :: String
drbdDelayTarget :: String
drbdMaxRate :: String
drbdMinRate :: String
lvStripes :: String
rbdAccess :: String
rbdPool :: String
diskDtTypes :: Map String VType
diskDtParameters :: FrozenSet String
ddpLocalIp :: String
ddpRemoteIp :: String
ddpPort :: String
ddpLocalMinor :: String
ddpRemoteMinor :: String
oobPowerOn :: String
oobPowerOff :: String
oobPowerCycle :: String
oobPowerStatus :: String
oobHealth :: String
oobCommands :: FrozenSet String
oobPowerStatusPowered :: String

-- | 60 seconds
oobTimeout :: Int

-- | 2 seconds
oobPowerDelay :: Double
oobStatusCritical :: String
oobStatusOk :: String
oobStatusUnknown :: String
oobStatusWarning :: String
oobStatuses :: FrozenSet String

-- | Instance Parameters Profile
ppDefault :: String
nicLink :: String
nicMode :: String
nicVlan :: String
nicsParameterTypes :: Map String VType
nicsParameters :: FrozenSet String
nicModeBridged :: String
nicModeRouted :: String
nicModeOvs :: String
nicIpPool :: String
nicValidModes :: FrozenSet String
releaseAction :: String
reserveAction :: String
idiskAdopt :: String
idiskMetavg :: String
idiskMode :: String
idiskName :: String
idiskSize :: String
idiskSpindles :: String
idiskVg :: String
idiskProvider :: String
idiskAccess :: String
idiskType :: String
idiskParamsTypes :: Map String VType
idiskParams :: FrozenSet String
modifiableIdiskParamsTypes :: Map String VType
modifiableIdiskParams :: FrozenSet String
inicBridge :: String
inicIp :: String
inicLink :: String
inicMac :: String
inicMode :: String
inicName :: String
inicNetwork :: String
inicVlan :: String
inicParamsTypes :: Map String VType
inicParams :: FrozenSet String
htXenPvm :: String
htFake :: String
htXenHvm :: String
htKvm :: String
htChroot :: String
htLxc :: String
hyperTypes :: FrozenSet String
htsReqPort :: FrozenSet String
vncBasePort :: Int
vncDefaultBindAddress :: String
htNicE1000 :: String
htNicI82551 :: String
htNicI8259er :: String
htNicI85557b :: String
htNicNe2kIsa :: String
htNicNe2kPci :: String
htNicParavirtual :: String
htNicPcnet :: String
htNicRtl8139 :: String
htHvmValidNicTypes :: FrozenSet String
htKvmValidNicTypes :: FrozenSet String

-- | Default vif type in xen-hvm
htHvmVifIoemu :: String
htHvmVifVif :: String
htHvmValidVifTypes :: FrozenSet String
htDiskIde :: String
htDiskIoemu :: String
htDiskMtd :: String
htDiskParavirtual :: String
htDiskPflash :: String
htDiskScsi :: String
htDiskSd :: String
htHvmValidDiskTypes :: FrozenSet String
htKvmValidDiskTypes :: FrozenSet String
htCacheDefault :: String
htCacheNone :: String
htCacheWback :: String
htCacheWthrough :: String
htValidCacheTypes :: FrozenSet String
htKvmAioThreads :: String
htKvmAioNative :: String
htKvmValidAioTypes :: FrozenSet String
htMouseMouse :: String
htMouseTablet :: String
htKvmValidMouseTypes :: FrozenSet String
htBoCdrom :: String
htBoDisk :: String
htBoFloppy :: String
htBoNetwork :: String
htKvmValidBoTypes :: FrozenSet String
htKvmSpiceLosslessImgComprAutoGlz :: String
htKvmSpiceLosslessImgComprAutoLz :: String
htKvmSpiceLosslessImgComprGlz :: String
htKvmSpiceLosslessImgComprLz :: String
htKvmSpiceLosslessImgComprOff :: String
htKvmSpiceLosslessImgComprQuic :: String
htKvmSpiceValidLosslessImgComprOptions :: FrozenSet String
htKvmSpiceLossyImgComprAlways :: String
htKvmSpiceLossyImgComprAuto :: String
htKvmSpiceLossyImgComprNever :: String
htKvmSpiceValidLossyImgComprOptions :: FrozenSet String
htKvmSpiceVideoStreamDetectionAll :: String
htKvmSpiceVideoStreamDetectionFilter :: String
htKvmSpiceVideoStreamDetectionOff :: String
htKvmSpiceValidVideoStreamDetectionOptions :: FrozenSet String
htSmNone :: String
htSmPool :: String
htSmUser :: String
htKvmValidSmTypes :: FrozenSet String
htKvmDisabled :: String
htKvmEnabled :: String
htKvmFlagValues :: FrozenSet String
htMigrationLive :: String
htMigrationNonlive :: String
htMigrationModes :: FrozenSet String
verifyNplusoneMem :: String
verifyOptionalChecks :: FrozenSet String
cvTcluster :: String
cvTgroup :: String
cvTnode :: String
cvTinstance :: String
cvWarning :: String
cvError :: String
cvEclustercert :: (String, String, String)
cvEclusterclientcert :: (String, String, String)
cvEclustercfg :: (String, String, String)
cvEclusterdanglinginst :: (String, String, String)
cvEclusterdanglingnodes :: (String, String, String)
cvEclusterfilecheck :: (String, String, String)
cvEgroupdifferentpvsize :: (String, String, String)
cvEinstancebadnode :: (String, String, String)
cvEinstancedown :: (String, String, String)
cvEinstancefaultydisk :: (String, String, String)
cvEinstancelayout :: (String, String, String)
cvEinstancemissingcfgparameter :: (String, String, String)
cvEinstancemissingdisk :: (String, String, String)
cvEinstancepolicy :: (String, String, String)
cvEinstancesplitgroups :: (String, String, String)
cvEinstanceunsuitablenode :: (String, String, String)
cvEinstancewrongnode :: (String, String, String)
cvEnodedrbd :: (String, String, String)
cvEnodedrbdhelper :: (String, String, String)
cvEnodedrbdversion :: (String, String, String)
cvEnodefilecheck :: (String, String, String)
cvEnodefilestoragepaths :: (String, String, String)
cvEnodefilestoragepathunusable :: (String, String, String)
cvEnodehooks :: (String, String, String)
cvEnodehv :: (String, String, String)
cvEnodelvm :: (String, String, String)
cvEnoden1 :: (String, String, String)
cvEnodenet :: (String, String, String)
cvEnodeoobpath :: (String, String, String)
cvEnodeorphaninstance :: (String, String, String)
cvEnodeorphanlv :: (String, String, String)
cvEnodeos :: (String, String, String)
cvEnoderpc :: (String, String, String)
cvEnodesetup :: (String, String, String)
cvEnodesharedfilestoragepathunusable :: (String, String, String)
cvEnodeglusterstoragepathunusable :: (String, String, String)
cvEnodessh :: (String, String, String)
cvEnodetime :: (String, String, String)
cvEnodeuserscripts :: (String, String, String)
cvEnodeversion :: (String, String, String)
cvAllEcodes :: FrozenSet (String, String, String)
cvAllEcodesStrings :: FrozenSet String
nvBridges :: String
nvClientCert :: String
nvDrbdhelper :: String
nvDrbdversion :: String
nvDrbdlist :: String
nvExclusivepvs :: String
nvFilelist :: String
nvAcceptedStoragePaths :: String
nvFileStoragePath :: String
nvSharedFileStoragePath :: String
nvGlusterStoragePath :: String
nvHvinfo :: String
nvHvparams :: String
nvHypervisor :: String
nvInstancelist :: String
nvLvlist :: String
nvMasterip :: String
nvNodelist :: String
nvNodenettest :: String
nvNodesetup :: String
nvOobPaths :: String
nvOslist :: String
nvPvlist :: String
nvTime :: String
nvUserscripts :: String
nvVersion :: String
nvVglist :: String
nvNonvmnodes :: String
nvSshSetup :: String
nvSshClutter :: String
inststAdmindown :: String
inststAdminoffline :: String
inststErrordown :: String
inststErrorup :: String
inststNodedown :: String
inststNodeoffline :: String
inststRunning :: String
inststUserdown :: String
inststWrongnode :: String
inststAll :: FrozenSet String
adminstDown :: String
adminstOffline :: String
adminstUp :: String
adminstAll :: FrozenSet String
adminSource :: AdminStateSource
userSource :: AdminStateSource
adminStateSources :: FrozenSet AdminStateSource
nrDrained :: String
nrMaster :: String
nrMcandidate :: String
nrOffline :: String
nrRegular :: String
nrAll :: FrozenSet String
sslCertExpirationError :: Int
sslCertExpirationWarn :: Int
iallocatorVersion :: Int
iallocatorDirIn :: String
iallocatorDirOut :: String
validIallocatorDirections :: FrozenSet String
iallocatorModeAlloc :: String
iallocatorModeChgGroup :: String
iallocatorModeMultiAlloc :: String
iallocatorModeNodeEvac :: String
iallocatorModeReloc :: String
validIallocatorModes :: FrozenSet String
iallocatorSearchPath :: [String]
defaultIallocatorShortcut :: String

-- | Time delay in seconds between repeated opportunistic instance
--   creations. Rather than failing with an informative error message if
--   the opportunistic creation cannot grab enough nodes, for some uses it
--   is better to retry the creation with an interval between attempts.
--   This is a reasonable default.
defaultOpportunisticRetryInterval :: Int
nodeEvacPri :: String
nodeEvacSec :: String
nodeEvacAll :: String
nodeEvacModes :: FrozenSet String
jobQueueVersion :: Int
jobQueueSizeHardLimit :: Int
jobQueueFilesPerms :: Int
jobNotchanged :: String
jobStatusQueued :: String
jobStatusWaiting :: String
jobStatusCanceling :: String
jobStatusRunning :: String
jobStatusCanceled :: String
jobStatusSuccess :: String
jobStatusError :: String
jobsPending :: FrozenSet String
jobsFinalized :: FrozenSet String
jobStatusAll :: FrozenSet String
opStatusCanceling :: String
opStatusQueued :: String
opStatusRunning :: String
opStatusWaiting :: String
opStatusCanceled :: String
opStatusError :: String
opStatusSuccess :: String
opsFinalized :: FrozenSet String
opPrioLowest :: Int
opPrioHighest :: Int
opPrioLow :: Int
opPrioNormal :: Int
opPrioHigh :: Int
opPrioSubmitValid :: FrozenSet Int
opPrioDefault :: Int
locksAppend :: String
locksReplace :: String
lockAttemptsMaxwait :: Double
lockAttemptsMinwait :: Double
lockAttemptsTimeout :: Int
elogMessage :: String
elogRemoteImport :: String
elogJqueueTest :: String
elogDelayTest :: String
etcHostsAdd :: String
etcHostsRemove :: String
jqtMsgprefix :: String
jqtExec :: String
jqtExpandnames :: String
jqtLogmsg :: String
jqtStartmsg :: String
jqtAll :: FrozenSet String
qrCluster :: String
qrExport :: String
qrExtstorage :: String
qrGroup :: String
qrInstance :: String
qrJob :: String
qrLock :: String
qrNetwork :: String
qrFilter :: String
qrNode :: String
qrOs :: String

-- | List of resources which can be queried using <a>OpQuery</a>
qrViaOp :: FrozenSet String

-- | List of resources which can be queried using Local UniX Interface
qrViaLuxi :: FrozenSet String

-- | List of resources which can be queried using RAPI
qrViaRapi :: FrozenSet String

-- | List of resources which can be queried via RAPI including PUT requests
qrViaRapiPut :: FrozenSet String
qftBool :: String
qftNumber :: String
qftNumberFloat :: String
qftOther :: String
qftText :: String
qftTimestamp :: String
qftUnit :: String
qftUnknown :: String
qftAll :: FrozenSet String

-- | No data (e.g. RPC error), can be used instead of <a>rsOffline</a>
rsNodata :: Int
rsNormal :: Int

-- | Resource marked offline
rsOffline :: Int

-- | Value unavailable/unsupported for item; if this field is supported but
--   we cannot get the data for the moment, <a>rsNodata</a> or
--   <a>rsOffline</a> should be used
rsUnavail :: Int
rsUnknown :: Int
rsAll :: FrozenSet Int

-- | Special field cases and their verbose/terse formatting
rssDescription :: Map Int (String, String)
maxDisks :: Int
maxNics :: Int

-- | SSCONF file prefix
ssconfFileprefix :: String
ssClusterName :: String
ssClusterTags :: String
ssFileStorageDir :: String
ssSharedFileStorageDir :: String
ssGlusterStorageDir :: String
ssMasterCandidates :: String
ssMasterCandidatesIps :: String
ssMasterCandidatesCerts :: String
ssMasterIp :: String
ssMasterNetdev :: String
ssMasterNetmask :: String
ssMasterNode :: String
ssNodeList :: String
ssNodePrimaryIps :: String
ssNodeSecondaryIps :: String
ssNodeVmCapable :: String
ssOfflineNodes :: String
ssOnlineNodes :: String
ssPrimaryIpFamily :: String
ssInstanceList :: String
ssReleaseVersion :: String
ssHypervisorList :: String
ssMaintainNodeHealth :: String
ssUidPool :: String
ssNodegroups :: String
ssNetworks :: String

-- | This is not a complete SSCONF key, but the prefix for the hypervisor
--   keys
ssHvparamsPref :: String
ssHvparamsXenChroot :: String
ssHvparamsXenFake :: String
ssHvparamsXenHvm :: String
ssHvparamsXenKvm :: String
ssHvparamsXenLxc :: String
ssHvparamsXenPvm :: String
validSsHvparamsKeys :: FrozenSet String
ssFilePerms :: Int
ssEnabledUserShutdown :: String
ssSshPorts :: String

-- | Cluster wide default parameters
defaultEnabledHypervisor :: String
hvcDefaults :: Map Hypervisor (Map String PyValueEx)
hvcGlobals :: FrozenSet String
becDefaults :: Map String PyValueEx
ndcDefaults :: Map String PyValueEx
ndcGlobals :: FrozenSet String

-- | Default delay target measured in sectors
defaultDelayTarget :: Int
defaultDiskCustom :: String
defaultDiskResync :: Bool

-- | Default fill target measured in sectors
defaultFillTarget :: Int

-- | Default mininum rate measured in KiB/s
defaultMinRate :: Int
defaultNetCustom :: String

-- | Default plan ahead measured in sectors
--   
--   The default values for the DRBD dynamic resync speed algorithm are
--   taken from the drbsetup 8.3.11 man page, except for c-plan-ahead (that
--   we don't need to set to 0, because we have a separate option to enable
--   it) and for c-max-rate, that we cap to the default value for the
--   static resync rate.
defaultPlanAhead :: Int
defaultRbdPool :: String
diskLdDefaults :: Map DiskTemplate (Map String PyValueEx)
diskDtDefaults :: Map DiskTemplate (Map String PyValueEx)
niccDefaults :: Map String PyValueEx

-- | All of the following values are quite arbitrary - there are no
--   <a>good</a> defaults, these must be customised per-site
ispecsMinmaxDefaults :: Map String (Map String Int)
ipolicyDefaults :: Map String PyValueEx
masterPoolSizeDefault :: Int

-- | Error margin used to compare physical disks
partMargin :: Double

-- | Space reserved when creating instance disks
partReserved :: Double

-- | Time intervall in seconds for polling updates on the job queue. This
--   intervall is only relevant if the number of running jobs reaches the
--   maximal allowed number, as otherwise new jobs will be started
--   immediately anyway. Also, as jobs are watched via inotify, scheduling
--   usually works independent of polling. Therefore we chose a
--   sufficiently large interval, in the order of 5 minutes. As with the
--   interval for reloading the configuration, we chose a prime number to
--   avoid accidental 'same wakeup' with other processes.
luxidJobqueuePollInterval :: Int

-- | The default value for the maximal number of jobs to be running at the
--   same time. Once the maximal number is reached, new jobs will just be
--   queued and only started, once some of the other jobs have finished.
luxidMaximalRunningJobsDefault :: Int

-- | The default value for the maximal number of jobs that luxid tracks via
--   inotify. If the number of running jobs exceeds this limit (which only
--   happens if the user increases the default value of maximal running
--   jobs), new forked jobs are no longer tracked by inotify; progress will
--   still be noticed on the regular polls.
luxidMaximalTrackedJobsDefault :: Int

-- | The number of retries when trying to <tt>fork</tt> a new job. Due to a
--   bug in GHC, this can fail even though we synchronize all forks and
--   restrain from other <tt>IO</tt> operations in the thread.
luxidRetryForkCount :: Int

-- | The average time period (in <i>us</i>) to wait between two
--   <tt>fork</tt> attempts. The forking thread wait a random time period
--   between <tt>0</tt> and twice the number, and with each attempt it
--   doubles the step. See <a>luxidRetryForkCount</a>.
luxidRetryForkStepUS :: Int

-- | The number of attempts to prove that a job is dead after sending it a
--   KILL signal.
luxidJobDeathDetectionRetries :: Int

-- | Time to delay (in <i>us</i>) after unsucessfully verifying the death
--   of a job we believe to be dead. This is best choosen to be the average
--   time sending a SIGKILL to take effect.
luxidJobDeathDelay :: Int

-- | Time itnervall in seconds between checks that all lock owners are
--   still alive, and cleaning up the resources for the dead ones. As jobs
--   dying without releasing resources is the exception, not the rule, we
--   don't want this task to take up too many cycles itself. Hence we
--   choose a sufficiently large intervall, in the order of 5 minutes. To
--   avoid accidental 'same wakeup' with other tasks, we choose the next
--   unused prime number.
wconfdDeathdetectionIntervall :: Int
wconfdDefCtmo :: Int
wconfdDefRwto :: Int

-- | The prefix of the WConfD livelock file name.
wconfLivelockPrefix :: String
confdProtocolVersion :: Int
confdReqPing :: Int
confdReqNodeRoleByname :: Int
confdReqNodePipByInstanceIp :: Int
confdReqClusterMaster :: Int
confdReqNodePipList :: Int
confdReqMcPipList :: Int
confdReqInstancesIpsList :: Int
confdReqNodeDrbd :: Int
confdReqNodeInstances :: Int
confdReqInstanceDisks :: Int
confdReqConfigQuery :: Int
confdReqDataCollectors :: Int
confdReqs :: FrozenSet Int
confdReqfieldName :: Int
confdReqfieldIp :: Int
confdReqfieldMnodePip :: Int
confdReplStatusOk :: Int
confdReplStatusError :: Int
confdReplStatusNotimplemented :: Int
confdReplStatuses :: FrozenSet Int
confdNodeRoleMaster :: Int
confdNodeRoleCandidate :: Int
confdNodeRoleOffline :: Int
confdNodeRoleDrained :: Int
confdNodeRoleRegular :: Int
confdErrorUnknownEntry :: Int
confdErrorInternal :: Int
confdErrorArgument :: Int
confdReqqLink :: String
confdReqqIp :: String
confdReqqIplist :: String
confdReqqFields :: String

-- | Each request is <a>salted</a> by the current timestamp.
--   
--   This constant decides how many seconds of skew to accept.
--   
--   TODO: make this a default and allow the value to be more configurable
confdMaxClockSkew :: Int

-- | When we haven't reloaded the config for more than this amount of
--   seconds, we force a test to see if inotify is betraying us. Using a
--   prime number to ensure we get less chance of 'same wakeup' with other
--   processes.
confdConfigReloadTimeout :: Int

-- | If we receive more than one update in this amount of microseconds, we
--   move to polling every RATELIMIT seconds, rather than relying on
--   inotify, to be able to serve more requests.
confdConfigReloadRatelimit :: Int

-- | Magic number prepended to all confd queries.
--   
--   This allows us to distinguish different types of confd protocols and
--   handle them. For example by changing this we can move the whole
--   payload to be compressed, or move away from json.
confdMagicFourcc :: String

-- | By default a confd request is sent to the minimum between this number
--   and all MCs. 6 was chosen because even in the case of a disastrous 50%
--   response rate, we should have enough answers to be able to compare
--   more than one.
confdDefaultReqCoverage :: Int

-- | Timeout in seconds to expire pending query request in the confd client
--   library. We don't actually expect any answer more than 10 seconds
--   after we sent a request.
confdClientExpireTimeout :: Int

-- | Maximum UDP datagram size.
--   
--   On IPv4: 64K - 20 (ip header size) - 8 (udp header size) = 65507 On
--   IPv6: 64K - 40 (ip6 header size) - 8 (udp header size) = 65487
--   (assuming we can't use jumbo frames) We just set this to 60K, which
--   should be enough
maxUdpDataSize :: Int
uidpoolUidMin :: Int

-- | Assuming 32 bit user-ids
uidpoolUidMax :: Integer

-- | Name or path of the pgrep command
pgrep :: String

-- | Name of the node group that gets created at cluster init or upgrade
initialNodeGroupName :: String
allocPolicyLastResort :: String
allocPolicyPreferred :: String
allocPolicyUnallocable :: String
validAllocPolicies :: [String]

-- | Temporary external/shared storage parameters
blockdevDriverManual :: String

-- | 'qemu-img' path, required for <tt>ovfconverter</tt>
qemuimgPath :: String

-- | The hail iallocator
iallocHail :: String
fakeOpMasterTurndown :: String
fakeOpMasterTurnup :: String
cryptoTypeSslDigest :: String
cryptoTypeSsh :: String
cryptoTypes :: FrozenSet String
cryptoActionGet :: String
cryptoActionCreate :: String
cryptoActionDelete :: String
cryptoActions :: FrozenSet String
cryptoBootstrap :: String
cryptoOptionCertFile :: String
cryptoOptionSerialNo :: String
sshkDsa :: String
sshkEcdsa :: String
sshkRsa :: String
sshkAll :: FrozenSet String
sshakDss :: String
sshakRsa :: String
sshakAll :: FrozenSet String
sshsClusterName :: String
sshsSshHostKey :: String
sshsSshRootKey :: String
sshsSshAuthorizedKeys :: String
sshsSshPublicKeys :: String
sshsNodeDaemonCertificate :: String
sshsMaxRetries :: Integer
sshsAdd :: String
sshsReplaceOrAdd :: String
sshsRemove :: String
sshsOverride :: String
sshsClear :: String
sshsGenerate :: String
sshsSuffix :: String
sshsMasterSuffix :: String
sshsActions :: FrozenSet String
sshHostDsaPriv :: String
sshHostDsaPub :: String
sshHostEcdsaPriv :: String
sshHostEcdsaPub :: String
sshHostRsaPriv :: String
sshHostRsaPub :: String
sshDaemonKeyfiles :: Map String (String, String)
ndsClusterName :: String
ndsNodeDaemonCertificate :: String
ndsSsconf :: String
ndsStartNodeDaemon :: String
ndsNodeName :: String
ndsAction :: String
vClusterEtcHosts :: String
vClusterVirtPathPrefix :: String
vClusterRootdirEnvname :: String
vClusterHostnameEnvname :: String
vClusterVpathWhitelist :: FrozenSet String
opcodeReasonSrcClient :: String
_opcodeReasonSrcDaemon :: String
_opcodeReasonSrcMasterd :: String
opcodeReasonSrcNoded :: String
opcodeReasonSrcOpcode :: String
opcodeReasonSrcPickup :: String
opcodeReasonSrcWatcher :: String
opcodeReasonSrcRlib2 :: String
opcodeReasonSrcUser :: String
opcodeReasonSources :: FrozenSet String

-- | Path generating random UUID
randomUuidFile :: String
autoRepairFailover :: String
autoRepairFixStorage :: String
autoRepairMigrate :: String
autoRepairReinstall :: String
autoRepairAllTypes :: FrozenSet String
autoRepairEnoperm :: String
autoRepairFailure :: String
autoRepairSuccess :: String
autoRepairAllResults :: FrozenSet String

-- | The version identifier for builtin data collectors
builtinDataCollectorVersion :: String

-- | The reason trail opcode parameter name
opcodeReason :: String

-- | The reason trail opcode parameter name
opcodeSequential :: String
diskstatsFile :: String
statFile :: String
cpuavgloadBufferSize :: Int

-- | Window size for averaging in seconds.
cpuavgloadWindowSize :: Int

-- | Mond's variable for periodical data collection
mondTimeInterval :: Int

-- | Mond's waiting time for requesting the current configuration.
mondConfigTimeInterval :: Int

-- | Mond's latest API version
mondLatestApiVersion :: Int
mondDefaultCategory :: String
diskUserspace :: String
diskKernelspace :: String
diskValidAccessModes :: FrozenSet String

-- | Timeout for queue draining in upgrades
upgradeQueueDrainTimeout :: Int

-- | Intervall at which the queue is polled during upgrades
upgradeQueuePollInterval :: Int
hotplugActionAdd :: String
hotplugActionRemove :: String
hotplugActionModify :: String
hotplugAllActions :: FrozenSet String
hotplugTargetNic :: String
hotplugTargetDisk :: String
hotplugAllTargets :: FrozenSet String

-- | Timeout for disk removal (seconds)
diskRemoveRetryTimeout :: Int

-- | Interval between disk removal retries (seconds)
diskRemoveRetryInterval :: Int
uuidRegex :: String
luxiSocketPerms :: Int
luxiKeyMethod :: String
luxiKeyArgs :: String
luxiKeySuccess :: String
luxiKeyResult :: String
luxiKeyVersion :: String
luxiReqSubmitJob :: String
luxiReqSubmitJobToDrainedQueue :: String
luxiReqSubmitManyJobs :: String
luxiReqWaitForJobChange :: String
luxiReqPickupJob :: String
luxiReqCancelJob :: String
luxiReqArchiveJob :: String
luxiReqChangeJobPriority :: String
luxiReqAutoArchiveJobs :: String
luxiReqQuery :: String
luxiReqQueryFields :: String
luxiReqQueryJobs :: String
luxiReqQueryFilters :: String
luxiReqReplaceFilter :: String
luxiReqDeleteFilter :: String
luxiReqQueryInstances :: String
luxiReqQueryNodes :: String
luxiReqQueryGroups :: String
luxiReqQueryNetworks :: String
luxiReqQueryExports :: String
luxiReqQueryConfigValues :: String
luxiReqQueryClusterInfo :: String
luxiReqQueryTags :: String
luxiReqSetDrainFlag :: String
luxiReqSetWatcherPause :: String
luxiReqAll :: FrozenSet String
luxiDefCtmo :: Int
luxiDefRwto :: Int

-- | <tt>WaitForJobChange</tt> timeout
luxiWfjcTimeout :: Int

-- | The prefix of the LUXI livelock file name
luxiLivelockPrefix :: String

-- | The LUXI daemon waits this number of seconds for ensuring that a
--   canceled job terminates before giving up.
luxiCancelJobTimeout :: Int

-- | Number of retries to carry out if nodes do not answer
masterVotingRetries :: Int

-- | Retry interval (in seconds) in master voting, if not enough answers
--   could be gathered.
masterVotingRetryIntervall :: Int
qlangOpAnd :: String
qlangOpOr :: String
qlangOpNot :: String
qlangOpTrue :: String
qlangOpContains :: String
qlangOpEqual :: String
qlangOpEqualLegacy :: String
qlangOpGe :: String
qlangOpGt :: String
qlangOpLe :: String
qlangOpLt :: String
qlangOpNotEqual :: String
qlangOpRegexp :: String

-- | Characters used for detecting user-written filters (see
--   L{_CheckFilter})
qlangFilterDetectionChars :: FrozenSet String

-- | Characters used to detect globbing filters
qlangGlobDetectionChars :: FrozenSet String

-- | Environment error (e.g. node disk error)
errorsEcodeEnviron :: String

-- | Entity already exists
errorsEcodeExists :: String

-- | Internal cluster error
errorsEcodeFault :: String

-- | Wrong arguments (at syntax level)
errorsEcodeInval :: String

-- | Entity not found
errorsEcodeNoent :: String

-- | Not enough resources (iallocator failure, disk space, memory, etc)
errorsEcodeNores :: String

-- | Resource not unique (e.g. MAC or IP duplication)
errorsEcodeNotunique :: String

-- | Resolver errors
errorsEcodeResolver :: String

-- | Wrong entity state
errorsEcodeState :: String

-- | Temporarily out of resources; operation can be tried again
errorsEcodeTempNores :: String
errorsEcodeAll :: FrozenSet String
jstoreJobsPerArchiveDirectory :: Int

-- | Name of the Gluster host setting
glusterHost :: String

-- | Default value of the Gluster host setting
glusterHostDefault :: String

-- | Name of the Gluster volume setting
glusterVolume :: String

-- | Default value of the Gluster volume setting
glusterVolumeDefault :: String

-- | Name of the Gluster port setting
glusterPort :: String

-- | Default value of the Gluster port setting
glusterPortDefault :: Int
instanceCommunicationDoc :: String
instanceCommunicationMacPrefix :: String

-- | The instance communication network is a link-local IPv4/IPv6 network
--   because the communication is meant to be exclusive between the host
--   and the guest and not routed outside the node.
instanceCommunicationNetwork4 :: String

-- | See <a>instanceCommunicationNetwork4</a>.
instanceCommunicationNetwork6 :: String
instanceCommunicationNetworkLink :: String
instanceCommunicationNetworkMode :: String
instanceCommunicationNicPrefix :: String

-- | Parameters that should be protected
--   
--   Python does not have a type system and can't automatically infer what
--   should be the resulting type of a JSON request. As a result, it must
--   rely on this list of parameter names to protect values correctly.
--   
--   Names ending in _cluster will be treated as dicts of dicts of private
--   values. Otherwise they are considered dicts of private values.
privateParametersBlacklist :: [String]

-- | Warn the user that the logging level is too low for production use.
debugModeConfidentialityWarning :: String

-- | The size of the file
statSize :: String

-- | The default fixed timeout needed to startup the helper VM.
helperVmStartup :: Int

-- | The default fixed timeout needed until the helper VM is finally
--   shutdown, for example, after installing the OS.
helperVmShutdown :: Int

-- | The zeroing timeout per MiB of disks to zero
--   
--   Determined by estimating that a disk writes at a relatively slow speed
--   of 1/5 of the max speed of current drives.
zeroingTimeoutPerMib :: Double
ipv4NetworkMinSize :: Int
ipv4NetworkMaxSize :: Int
dataCollectorCPULoad :: String
dataCollectorDiskStats :: String
dataCollectorDrbd :: String
dataCollectorLv :: String
dataCollectorInstStatus :: String
dataCollectorParameterInterval :: String
dataCollectorNames :: FrozenSet String
dataCollectorStateActive :: String
dataCollectorsEnabledName :: String
dataCollectorsIntervalName :: String


-- | Base common functionality.
--   
--   This module holds common functionality shared across Ganeti daemons,
--   HTools and any other programs.
module Ganeti.Common

-- | Parameter type.
data OptCompletion

-- | No parameter to this option
OptComplNone :: OptCompletion

-- | An existing file
OptComplFile :: OptCompletion

-- | An existing directory
OptComplDir :: OptCompletion

-- | Host name
OptComplHost :: OptCompletion

-- | One ipv4/ipv6 address
OptComplInetAddr :: OptCompletion

-- | One node
OptComplOneNode :: OptCompletion

-- | Many nodes, comma-sep
OptComplManyNodes :: OptCompletion

-- | One instance
OptComplOneInstance :: OptCompletion

-- | Many instances, comma-sep
OptComplManyInstances :: OptCompletion

-- | One OS name
OptComplOneOs :: OptCompletion

-- | One iallocator
OptComplOneIallocator :: OptCompletion

-- | Either one or two nodes
OptComplInstAddNodes :: OptCompletion

-- | One group
OptComplOneGroup :: OptCompletion

-- | Integer values
OptComplInteger :: OptCompletion

-- | Float values
OptComplFloat :: OptCompletion

-- | Job Id
OptComplJobId :: OptCompletion

-- | Command (executable)
OptComplCommand :: OptCompletion

-- | Arbitrary string
OptComplString :: OptCompletion

-- | List of string choices
OptComplChoices :: [String] -> OptCompletion

-- | Suggested choices
OptComplSuggest :: [String] -> OptCompletion

-- | Argument type. This differs from (and wraps) an Option by the fact
--   that it can (and usually does) support multiple repetitions of the
--   same argument, via a min and max limit.
data ArgCompletion
ArgCompletion :: OptCompletion -> Int -> (Maybe Int) -> ArgCompletion
type Personality a = (a -> [String] -> IO (), IO [GenericOptType a], [ArgCompletion], String)

-- | Personality lists type, common across all binaries that expose
--   multiple personalities.
type PersonalityList a = [(String, Personality a)]

-- | Yes/no choices completion.
optComplYesNo :: OptCompletion
complToText :: OptCompletion -> String
argComplToText :: ArgCompletion -> String

-- | Abbreviation for the option type.
type GenericOptType a = (OptDescr (a -> Result a), OptCompletion)

-- | Type class for options which support help and version.
class StandardOptions a
helpRequested :: StandardOptions a => a -> Bool
verRequested :: StandardOptions a => a -> Bool
compRequested :: StandardOptions a => a -> Bool
requestHelp :: StandardOptions a => a -> a
requestVer :: StandardOptions a => a -> a
requestComp :: StandardOptions a => a -> a

-- | Option to request help output.
oShowHelp :: StandardOptions a => GenericOptType a

-- | Option to request version information.
oShowVer :: StandardOptions a => GenericOptType a

-- | Option to request completion information
oShowComp :: StandardOptions a => GenericOptType a

-- | Usage info.
usageHelp :: String -> [GenericOptType a] -> String

-- | Show the program version info.
versionInfo :: String -> String
completionInfo :: String -> [GenericOptType a] -> [ArgCompletion] -> String

-- | Helper for parsing a yes/no command line flag.
parseYesNo :: Bool -> Maybe String -> Result Bool

-- | Helper function for required arguments which need to be converted as
--   opposed to stored just as string.
reqWithConversion :: (String -> Result a) -> (a -> b -> Result b) -> String -> ArgDescr (b -> Result b)
maxCmdLen :: Int

-- | Formats the description of various commands.
formatCommands :: StandardOptions a => PersonalityList a -> [String]
formatCmdUsage :: StandardOptions a => String -> PersonalityList a -> String
showCmdUsage :: StandardOptions a => String -> PersonalityList a -> Bool -> IO b
multiCmdCompletion :: StandardOptions a => PersonalityList a -> String
showCmdCompletion :: StandardOptions a => PersonalityList a -> IO b

-- | Command line parser, using a generic <tt>Options</tt> structure.
parseOpts :: StandardOptions a => a -> [String] -> String -> [GenericOptType a] -> [ArgCompletion] -> IO (a, [String])

-- | Command line parser, for programs with sub-commands.
parseOptsCmds :: StandardOptions a => a -> [String] -> String -> PersonalityList a -> [GenericOptType a] -> IO (a, [String], a -> [String] -> IO ())

-- | Inner parse options. The arguments are similar to <a>parseOpts</a>,
--   but it returns either a <a>Left</a> composed of exit code and message,
--   or a <a>Right</a> for the success case.
parseOptsInner :: StandardOptions a => a -> [String] -> String -> [GenericOptType a] -> [ArgCompletion] -> Either (ExitCode, String) (a, [String])

-- | Parse command line options and execute the main function of a
--   multi-personality binary.
genericMainCmds :: StandardOptions a => a -> PersonalityList a -> [GenericOptType a] -> IO ()

-- | Order a list of pairs in the order of the given list and fill up the
--   list for elements that don't have a matching pair
fillUpList :: ([(a, b)] -> a -> (a, b)) -> [a] -> [(a, b)] -> [(a, b)]

-- | Fill up a pair with fillup element if no matching pair is present
fillPairFromMaybe :: (a -> (a, b)) -> (a -> [(a, b)] -> Maybe (a, b)) -> [(a, b)] -> a -> (a, b)
isMatchingPair :: Eq a => a -> (a, b) -> Bool

-- | Pick a specific element's pair from the list
pickPairUnique :: Eq a => a -> [(a, b)] -> Maybe (a, b)
instance Show OptCompletion
instance Eq OptCompletion
instance Show ArgCompletion
instance Eq ArgCompletion


-- | Implementation of the Ganeti confd utilities.
--   
--   This holds a few utility functions that could be useful in both
--   clients and servers.
module Ganeti.Confd.Utils
maxClockSkew :: Integer

-- | Returns the HMAC key.
getClusterHmac :: IO HashKey

-- | Parses a signed message.
parseSignedMessage :: JSON a => HashKey -> String -> Result (String, String, a)

-- | Message parsing. This can either result in a good, valid request
--   message, or fail in the Result monad.
parseRequest :: HashKey -> String -> Integer -> Result (String, ConfdRequest)

-- | Message parsing. This can either result in a good, valid reply
--   message, or fail in the Result monad. It also checks that the salt in
--   the message corresponds to the one that is expected
parseReply :: HashKey -> String -> String -> Result (String, ConfdReply)

-- | Signs a message with a given key and salt.
signMessage :: HashKey -> String -> String -> SignedMessage
data Pointer
Pointer :: [String] -> Pointer
readInteger :: String -> Result Int
pointerFromString :: String -> Result Pointer
extractValue :: JSON a => Pointer -> a -> Result JSValue

-- | Extract a <tt>JSValue</tt> from an object at the position defined by
--   the path.
--   
--   The path syntax follows RCF6901. Error is returned if the path doesn't
--   exist, Ok if the path leads to an valid value.
--   
--   JSON pointer syntax according to RFC6901:
--   
--   <pre>
--   "/path/0/x" =&gt; Pointer ["path", "0", "x"]
--   </pre>
--   
--   This accesses 1 in the following JSON:
--   
--   <pre>
--   { "path": { "0": { "x": 1 } } }
--   </pre>
--   
--   or the following:
--   
--   <pre>
--   { "path": [{"x": 1}] }
--   </pre>
extractJSONPath :: JSON a => String -> a -> Result JSValue
instance Show Pointer
instance Eq Pointer


-- | Implementation of the Ganeti Ssconf interface.
module Ganeti.Ssconf
maxFileSize :: Int

-- | ssconf file prefix, re-exported from Constants.
sSFilePrefix :: FilePath
data SSKey
SSClusterName :: SSKey
SSClusterTags :: SSKey
SSFileStorageDir :: SSKey
SSSharedFileStorageDir :: SSKey
SSGlusterStorageDir :: SSKey
SSMasterCandidates :: SSKey
SSMasterCandidatesIps :: SSKey
SSMasterCandidatesCerts :: SSKey
SSMasterIp :: SSKey
SSMasterNetdev :: SSKey
SSMasterNetmask :: SSKey
SSMasterNode :: SSKey
SSNodeList :: SSKey
SSNodePrimaryIps :: SSKey
SSNodeSecondaryIps :: SSKey
SSNodeVmCapable :: SSKey
SSOfflineNodes :: SSKey
SSOnlineNodes :: SSKey
SSPrimaryIpFamily :: SSKey
SSInstanceList :: SSKey
SSReleaseVersion :: SSKey
SSHypervisorList :: SSKey
SSMaintainNodeHealth :: SSKey
SSUidPool :: SSKey
SSNodegroups :: SSKey
SSNetworks :: SSKey
SSEnabledUserShutdown :: SSKey
SSSshPorts :: SSKey
SSHvparamsKvm :: SSKey
SSHvparamsXenPvm :: SSKey
SSHvparamsChroot :: SSKey
SSHvparamsXenHvm :: SSKey
SSHvparamsLxc :: SSKey
SSHvparamsFake :: SSKey
sSKeyFromRaw :: Monad m_a1TJE => String -> m_a1TJE SSKey
sSKeyToRaw :: SSKey -> String

-- | For a given hypervisor get the corresponding SSConf key that contains
--   its parameters.
--   
--   The corresponding SSKeys are generated automatically by TH, but since
--   we don't have convenient infrastructure for generating this function,
--   it's just manual. All constructors must be given explicitly so that
--   adding another hypervisor will trigger <a>incomplete pattern</a>
--   warning and force the corresponding addition.
hvparamsSSKey :: Hypervisor -> SSKey

-- | Convert a ssconf key into a (full) file path.
keyToFilename :: FilePath -> SSKey -> FilePath
catchIOErrors :: Maybe a -> IO a -> IO (Result a)
readSSConfFile :: Maybe FilePath -> Maybe String -> SSKey -> IO (Result String)
parseKeyValue :: Monad m => String -> String -> m (String, String)
parseIPFamily :: Int -> Result Family

-- | Read the primary IP family.
getPrimaryIPFamily :: Maybe FilePath -> IO (Result Family)

-- | Parse the nodes vm capable value from a <a>String</a>.
parseNodesVmCapable :: String -> Result [(String, Bool)]

-- | Read and parse the nodes vm capable.
getNodesVmCapable :: Maybe FilePath -> IO (Result [(String, Bool)])

-- | Read the list of IP addresses of the master candidates of the cluster.
getMasterCandidatesIps :: Maybe FilePath -> IO (Result [String])

-- | Read the name of the master node.
getMasterNode :: Maybe FilePath -> IO (Result String)

-- | Parse the list of enabled hypervisors from a <a>String</a>.
parseHypervisorList :: String -> Result [Hypervisor]

-- | Read and parse the list of enabled hypervisors.
getHypervisorList :: Maybe FilePath -> IO (Result [Hypervisor])

-- | Parse whether user shutdown is enabled from a <a>String</a>.
parseEnabledUserShutdown :: String -> Result Bool

-- | Read and parse whether user shutdown is enabled.
getEnabledUserShutdown :: Maybe FilePath -> IO (Result Bool)

-- | The data type used for representing the ssconf.
newtype SSConf
SSConf :: Map SSKey [String] -> SSConf
getSSConf :: SSConf -> Map SSKey [String]
emptySSConf :: SSConf
instance Show SSKey
instance Eq SSKey
instance Enum SSKey
instance Bounded SSKey
instance Ord SSKey
instance Eq SSConf
instance Ord SSConf
instance Show SSConf
instance JSON SSConf
instance HasStringRepr SSKey


-- | Implementation of the Ganeti Confd client functionality.
module Ganeti.Confd.Client

-- | Builds a properly initialized ConfdClient. The parameters (an IP
--   address and the port number for the Confd client to connect to) are
--   mainly meant for testing purposes. If they are not provided, the list
--   of master candidates and the default port number will be used.
getConfdClient :: Maybe String -> Maybe Int -> IO ConfdClient

-- | Sends a query to all the Confd servers the client is connected to.
--   Returns the most up-to-date result according to the serial number,
--   chosen between those received before the timeout.
query :: ConfdClient -> ConfdRequestType -> ConfdQuery -> IO (Maybe ConfdReply)
updateConfdReply :: ConfdReply -> Maybe ConfdReply -> Maybe ConfdReply
queryOneServer :: MVar () -> MVar (Maybe ConfdReply) -> ConfdRequestType -> ConfdQuery -> HashKey -> (String, PortNumber) -> IO ()


-- | Implementation of the Ganeti error types.
--   
--   This module implements our error hierarchy. Currently we implement one
--   identical to the Python one; later we might one to have separate ones
--   for frontend (clients), master and backend code.
module Ganeti.Errors

-- | Error code types for <a>OpPrereqError</a>.
data ErrorCode
ECodeResolver :: ErrorCode
ECodeNoRes :: ErrorCode
ECodeTempNoRes :: ErrorCode
ECodeInval :: ErrorCode
ECodeState :: ErrorCode
ECodeNoEnt :: ErrorCode
ECodeExists :: ErrorCode
ECodeNotUnique :: ErrorCode
ECodeFault :: ErrorCode
ECodeEnviron :: ErrorCode
errorCodeFromRaw :: Monad m_a1Wjm => String -> m_a1Wjm ErrorCode
errorCodeToRaw :: ErrorCode -> String
data GanetiException
GenericError :: String -> GanetiException
LockError :: String -> GanetiException
PidFileLockError :: String -> GanetiException
HypervisorError :: String -> GanetiException
ProgrammerError :: String -> GanetiException
BlockDeviceError :: String -> GanetiException
ConfigurationError :: String -> GanetiException
ConfigVerifyError :: String -> [String] -> GanetiException
ConfigVersionMismatch :: Int -> Int -> GanetiException
ReservationError :: String -> GanetiException
RemoteError :: String -> GanetiException
SignatureError :: String -> GanetiException
ParameterError :: String -> GanetiException
ResultValidationError :: String -> GanetiException
OpPrereqError :: String -> ErrorCode -> GanetiException
OpExecError :: String -> GanetiException
OpResultError :: String -> GanetiException
OpCodeUnknown :: String -> GanetiException
JobLost :: String -> GanetiException
JobFileCorrupted :: String -> GanetiException
ResolverError :: String -> Int -> String -> GanetiException
HooksFailure :: String -> GanetiException
HooksAbort :: [(String, String, String)] -> GanetiException
UnitParseError :: String -> GanetiException
ParseError :: String -> GanetiException
TypeEnforcementError :: String -> GanetiException
X509CertError :: String -> String -> GanetiException
TagError :: String -> GanetiException
CommandError :: String -> GanetiException
StorageError :: String -> GanetiException
InotifyError :: String -> GanetiException
JobQueueError :: String -> GanetiException
JobQueueDrainError :: String -> GanetiException
JobQueueFull :: GanetiException
ConfdMagicError :: String -> GanetiException
ConfdClientError :: String -> GanetiException
UdpDataSizeError :: String -> GanetiException
NoCtypesError :: String -> GanetiException
IPAddressError :: String -> GanetiException
LuxiError :: String -> GanetiException
QueryFilterParseError :: String -> GanetiException
RapiTestResult :: String -> GanetiException
FileStoragePathError :: String -> GanetiException
saveGanetiException :: GanetiException -> JSValue
loadGanetiException :: JSValue -> Result GanetiException

-- | Error monad using <a>GanetiException</a> type alias.
type ErrorResult = GenericResult GanetiException
excName :: GanetiException -> String

-- | Returns the exit code of a program that should be used if we got back
--   an exception from masterd.
errorExitCode :: GanetiException -> ExitCode

-- | Formats an exception.
formatError :: GanetiException -> String

-- | A type for IO actions with errors properly handled as
--   <a>GanetiException</a>s. TODO: Move to Errors.hs
type ResultG = ResultT GanetiException IO

-- | Convert from an <a>ErrorResult</a> to a standard <a>Result</a>.
errToResult :: ErrorResult a -> Result a

-- | Convert from a <a>Maybe</a> to a an <a>ErrorResult</a>.
maybeToError :: String -> Maybe a -> ErrorResult a
instance Show GanetiException
instance Eq GanetiException
instance JSON GanetiException
instance Error GanetiException
instance JSON ErrorCode
instance Show ErrorCode
instance Eq ErrorCode
instance Enum ErrorCode
instance Bounded ErrorCode
instance Ord ErrorCode


-- | Implementation of the generic daemon functionality.
module Ganeti.Daemon
devNull :: FilePath
daemonStartupErr :: String -> String

-- | Command line options structure.
data DaemonOptions
DaemonOptions :: Bool -> Bool -> Bool -> Bool -> Maybe Word16 -> Bool -> Bool -> Maybe String -> Maybe SyslogUsage -> Bool -> Bool -> Bool -> DaemonOptions

-- | Just show the help
optShowHelp :: DaemonOptions -> Bool

-- | Just show the program version
optShowVer :: DaemonOptions -> Bool

-- | Just show the completion info
optShowComp :: DaemonOptions -> Bool

-- | Whether to daemonize or not
optDaemonize :: DaemonOptions -> Bool

-- | Override for the network port
optPort :: DaemonOptions -> Maybe Word16

-- | Enable debug messages
optDebug :: DaemonOptions -> Bool

-- | Ignore user checks
optNoUserChecks :: DaemonOptions -> Bool

-- | Override for the bind address
optBindAddress :: DaemonOptions -> Maybe String

-- | Override for Syslog usage
optSyslogUsage :: DaemonOptions -> Maybe SyslogUsage

-- | Ignore node checks
optForceNode :: DaemonOptions -> Bool

-- | skip voting for master
optNoVoting :: DaemonOptions -> Bool

-- | force dangerous options
optYesDoIt :: DaemonOptions -> Bool

-- | Default values for the command line options.
defaultOptions :: DaemonOptions

-- | Abrreviation for the option type.
type OptType = GenericOptType DaemonOptions

-- | Check function type.
type CheckFn a = DaemonOptions -> IO (Either ExitCode a)

-- | Prepare function type.
type PrepFn a b = DaemonOptions -> a -> IO b

-- | Main execution function type.
type MainFn a b = DaemonOptions -> a -> b -> IO ()
oNoDaemonize :: OptType
oDebug :: OptType
oNoUserChecks :: OptType
oPort :: Int -> OptType
oBindAddress :: OptType
oSyslogUsage :: OptType
oForceNode :: OptType
oNoVoting :: OptType
oYesDoIt :: OptType
genericOpts :: [OptType]
ioErrorToResult :: String -> IOError -> IO (Result a)

-- | Small wrapper over getArgs and <a>parseOpts</a>.
parseArgs :: String -> [OptType] -> IO (DaemonOptions, [String])
pidFileMode :: FileMode
pidFileFlags :: OpenFileFlags
writePidFile :: FilePath -> IO Fd

-- | Helper function to ensure a socket doesn't exist. Should only be
--   called once we have locked the pid file successfully.
cleanupSocket :: FilePath -> IO ()
setupDaemonEnv :: FilePath -> FileMode -> IO ()
finalCleanup :: FilePath -> IO ()
handleSigTerm :: ThreadId -> IO ()
handleSigHup :: FilePath -> IO ()
setupDaemonFDs :: Maybe FilePath -> IO ()
defaultBindAddr :: Int -> Family -> Result (Family, SockAddr)

-- | Based on the options, compute the socket address to use for the
--   daemon.
parseAddress :: DaemonOptions -> Int -> IO (Result (Family, SockAddr))
vClusterHostNameEnvVar :: String
getFQDN' :: Maybe AddrInfo -> IO String
getFQDNwithHints :: Maybe AddrInfo -> IO String

-- | Return the full qualified host name, honoring the vcluster setup.
getFQDN :: IO String
isMaster :: IO Bool
ensureNode :: GanetiDaemon -> DaemonOptions -> IO ()

-- | Run an I/O action that might throw an I/O error, under a handler that
--   will simply annotate and re-throw the exception.
describeError :: String -> Maybe Handle -> Maybe FilePath -> IO a -> IO a
daemonize :: FilePath -> (Maybe Fd -> IO ()) -> IO ()

-- | Generic daemon startup.
genericMain :: GanetiDaemon -> [OptType] -> CheckFn a -> PrepFn a b -> MainFn a b -> IO ()
fullPrep :: GanetiDaemon -> DaemonOptions -> SyslogUsage -> a -> PrepFn a b -> IO (FilePath, b)
innerMain :: GanetiDaemon -> DaemonOptions -> SyslogUsage -> a -> PrepFn a b -> MainFn a b -> Maybe Fd -> IO ()
handlePrepErr :: Bool -> Maybe Fd -> IOError -> IO a
maybeCloseFd :: Maybe Fd -> IO ()
instance StandardOptions DaemonOptions


-- | Utilities for virtual clusters.
module Ganeti.VCluster
getRootDirectory :: IO (Maybe FilePath)
virtualPath :: FilePath -> FilePath -> FilePath

-- | Given a path, make it a virtual one, if in a vcluster environment.
--   Otherwise, return unchanged.
makeVirtualPath :: FilePath -> IO FilePath

module Ganeti.Metad.Config

-- | Merges two instance configurations into one.
--   
--   In the case where instance IPs (i.e., map keys) are repeated, the old
--   instance configuration is thrown away by <a>union</a> and replaced by
--   the new configuration. As a result, the old private and secret OS
--   parameters are completely lost.
mergeConfig :: InstanceParams -> InstanceParams -> InstanceParams

-- | Extracts the OS parameters (public, private, secret) from a JSON
--   object.
--   
--   This function checks whether the OS parameters are in fact a JSON
--   object.
getOsParams :: String -> String -> JSObject JSValue -> Result (JSObject JSValue)
getPublicOsParams :: JSObject JSValue -> Result (JSObject JSValue)
getPrivateOsParams :: JSObject JSValue -> Result (JSObject JSValue)
getSecretOsParams :: JSObject JSValue -> Result (JSObject JSValue)

-- | Merges the OS parameters (public, private, secret) in a single data
--   structure containing all parameters and their visibility.
--   
--   Example:
--   
--   <pre>
--   { "os-image": ["http://example.com/disk.img", "public"],
--     "os-password": ["mypassword", "secret"] }
--   </pre>
makeInstanceParams :: JSObject JSValue -> JSObject JSValue -> JSObject JSValue -> JSValue
getOsParamsWithVisibility :: JSValue -> Result JSValue

-- | Finds the IP address of the instance communication NIC in the
--   instance's NICs.
getInstanceCommunicationIp :: JSObject JSValue -> Result String

-- | Extracts the OS parameters from the instance's parameters and returns
--   a data structure containing all the OS parameters and their visibility
--   indexed by the instance's IP address which is used in the instance
--   communication NIC.
getInstanceParams :: JSValue -> Result (String, InstanceParams)


-- | Web server for the metadata daemon.
module Ganeti.Metad.WebServer
type MetaM = Snap ()
split :: String -> [String]
lookupInstanceParams :: MonadError String m => String -> Map String b -> m b
error404 :: MetaM
maybeResult :: MonadError String m => Result t -> (t -> m a) -> m a
serveOsParams :: String -> Map String JSValue -> MetaM
serveOsPackage :: String -> Map String JSValue -> String -> MetaM
serveOsScript :: String -> Map String JSValue -> String -> MetaM
handleMetadata :: MVar InstanceParams -> Method -> String -> String -> String -> MetaM
routeMetadata :: MVar InstanceParams -> MetaM
defaultHttpConf :: DaemonOptions -> FilePath -> FilePath -> Config Snap ()
start :: DaemonOptions -> MVar InstanceParams -> IO ()


-- | Unittests for constants
module Test.Ganeti.Constants
case_buildVersion :: Assertion
testConstants :: Test


-- | Module abstracting the node and instance container implementation.
--   
--   This is currently implemented on top of an <tt>IntMap</tt>, which
--   seems to give the best performance for our workload.
module Ganeti.HTools.Container

-- | Our key type.
type Key = Key

-- | Our container type.
type Container = IntMap

-- | Locate a key in the map (must exist).
find :: Key -> Container a -> a

-- | Add or update one element to the map.
add :: Key -> a -> Container a -> Container a

-- | Add or update two elements of the map.
addTwo :: Key -> a -> Key -> a -> Container a -> Container a

-- | Compute the name of an element in a container.
nameOf :: Element a => Container a -> Key -> String

-- | Find an element by name in a Container; this is a very slow function.
findByName :: (Element a, Monad m) => Container a -> String -> m a


-- | Module describing a node group.
module Ganeti.HTools.Group

-- | The node group type.
data Group
Group :: String -> GroupID -> Gdx -> AllocPolicy -> [NetworkID] -> IPolicy -> [String] -> Group

-- | The node name
name :: Group -> String

-- | The UUID of the group
uuid :: Group -> GroupID

-- | Internal index for book-keeping
idx :: Group -> Gdx

-- | The allocation policy for this group
allocPolicy :: Group -> AllocPolicy

-- | The networks connected to this group
networks :: Group -> [NetworkID]

-- | The instance policy for this group
iPolicy :: Group -> IPolicy

-- | The tags for this group
allTags :: Group -> [String]

-- | A simple name for the int, node association list.
type AssocList = [(Gdx, Group)]

-- | A simple name for a node map.
type List = Container Group

-- | Create a new group.
create :: String -> GroupID -> AllocPolicy -> [NetworkID] -> IPolicy -> [String] -> Group

-- | Sets the group index.
--   
--   This is used only during the building of the data structures.
setIdx :: Group -> Gdx -> Group
setName :: Group -> String -> Group

-- | Checks if a group is allocable.
isAllocable :: Group -> Bool

-- | Makes the group unallocatable
setUnallocable :: Group -> Group
instance Show Group
instance Eq Group
instance Element Group


-- | Module describing an NIC.
--   
--   The NIC data type only holds data about a NIC, but does not provide
--   any logic.
module Ganeti.HTools.Nic
data Mode
Bridged :: Mode
Routed :: Mode
OpenVSwitch :: Mode

-- | The NIC type.
--   
--   It holds the data for a NIC as it is provided via the IAllocator
--   protocol for an instance creation request. All data in those request
--   is optional, that's why all fields are Maybe's.
--   
--   TODO: Another name might be more appropriate for this type, as for
--   example RequestedNic. But this type is used as a field in the Instance
--   type, which is not named RequestedInstance, so such a name would be
--   weird. PartialNic already exists in Objects, but doesn't fit the bill
--   here, as it contains a required field (mac). Objects and the types
--   therein are subject to being reworked, so until then this type is left
--   as is.
data Nic
Nic :: Maybe String -> Maybe String -> Maybe Mode -> Maybe String -> Maybe String -> Maybe NetworkID -> Nic

-- | MAC address of the NIC
mac :: Nic -> Maybe String

-- | IP address of the NIC
ip :: Nic -> Maybe String

-- | the mode the NIC operates in
mode :: Nic -> Maybe Mode

-- | the link of the NIC
link :: Nic -> Maybe String

-- | the bridge this NIC is connected to if the mode is Bridged
bridge :: Nic -> Maybe String

-- | network UUID if this NIC is connected to a network
network :: Nic -> Maybe NetworkID

-- | A simple name for an instance map.
type List = Container Nic

-- | Create a NIC.
create :: Maybe String -> Maybe String -> Maybe Mode -> Maybe String -> Maybe String -> Maybe NetworkID -> Nic
instance Show Mode
instance Eq Mode
instance Show Nic
instance Eq Nic


-- | Module abstracting the peer map implementation.
--   
--   This is abstracted separately since the speed of peermap updates can
--   be a significant part of the total runtime, and as such changing the
--   implementation should be easy in case it's needed.
module Ganeti.HTools.PeerMap

-- | Our key type.
type Key = Ndx

-- | Our element type.
type Elem = Int

-- | The definition of a peer map.
type PeerMap = [(Key, Elem)]

-- | Create a new empty map.
empty :: PeerMap
pmCompare :: (Key, Elem) -> (Key, Elem) -> Ordering
addWith :: (Elem -> Elem -> Elem) -> Key -> Elem -> PeerMap -> PeerMap

-- | Create a PeerMap from an association list, with possible duplicates.
accumArray :: (Elem -> Elem -> Elem) -> [(Key, Elem)] -> PeerMap

-- | Returns either the value for a key or zero if not found.
find :: Key -> PeerMap -> Elem

-- | Add an element to a peermap, overwriting the previous value.
add :: Key -> Elem -> PeerMap -> PeerMap

-- | Remove an element from a peermap.
remove :: Key -> PeerMap -> PeerMap

-- | Find the maximum element.
--   
--   Since this is a sorted list, we just get the value at the head of the
--   list, or zero for a null list
maxElem :: PeerMap -> Elem


-- | CPUload data types
--   
--   This module holds the definition of the data types describing the CPU
--   load according to information collected periodically from
--   <tt><i>proc</i>stat</tt>.
module Ganeti.Cpu.Types

-- | This is the format of the report produced by the cpu load collector.
data CPUavgload
CPUavgload :: Int -> [Double] -> Double -> CPUavgload
cavCpuNumber :: CPUavgload -> Int
cavCpus :: CPUavgload -> [Double]
cavCpuTotal :: CPUavgload -> Double
loadCPUavgload :: JSValue -> Result CPUavgload
saveCPUavgload :: CPUavgload -> JSValue

-- | This is the format of the data parsed by the input file.
data CPUstat
CPUstat :: String -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> CPUstat
csName :: CPUstat -> String
csUser :: CPUstat -> Int
csNice :: CPUstat -> Int
csSystem :: CPUstat -> Int
csIdle :: CPUstat -> Int
csIowait :: CPUstat -> Int
csIrq :: CPUstat -> Int
csSoftirq :: CPUstat -> Int
csSteal :: CPUstat -> Int
csGuest :: CPUstat -> Int
csGuestNice :: CPUstat -> Int
loadCPUstat :: JSValue -> Result CPUstat
saveCPUstat :: CPUstat -> JSValue
instance Show CPUstat
instance Eq CPUstat
instance JSON CPUstat
instance ArrayObject CPUstat
instance DictObject CPUstat
instance Show CPUavgload
instance Eq CPUavgload
instance JSON CPUavgload
instance ArrayObject CPUavgload
instance DictObject CPUavgload


-- | <i>proc</i>stat file parser
--   
--   This module holds the definition of the parser that extracts
--   information about the CPU load of the system from the
--   <tt><i>proc</i>stat</tt> file.
module Ganeti.Cpu.LoadParser
oneCPUstatParser :: Parser CPUstat
intrFound :: Parser ()

-- | The parser for the fragment of CPU status file containing information
--   about the CPU load.
cpustatParser :: Parser [CPUstat]


-- | Helpers for creating various kinds of <a>Field</a>s.
--   
--   They aren't directly needed for the Template Haskell code in
--   Ganeti.THH, so better keep them in a separate module.
module Ganeti.THH.Field
numericalReadFn :: JSON a => (String -> Result a) -> [(String, JSValue)] -> JSValue -> Result a

-- | Sets the read function to also accept string parsable by the given
--   function.
specialNumericalField :: Name -> Field -> Field

-- | Creates a new mandatory field that reads time as the (floating point)
--   number of seconds since the standard UNIX epoch, and represents it in
--   Haskell as <a>ClockTime</a>.
timeAsDoubleField :: String -> Field
integralField :: Q Type -> String -> Field

-- | Timestamp fields description.
timeStampFields :: [Field]

-- | Serial number fields description.
serialFields :: [Field]

-- | UUID fields description.
uuidFields :: [Field]

-- | Tag set type alias.
type TagSet = Set String

-- | Tag field description.
tagsFields :: [Field]

-- | Creates a new mandatory field that reads a file mode in the standard
--   POSIX file mode representation. The Haskell type of the field is
--   <a>FileMode</a>.
fileModeAsIntField :: String -> Field

-- | Creates a new mandatory field that contains a POSIX process ID.
processIdField :: String -> Field


-- | LVM data types
--   
--   This module holds the definition of the data types describing the
--   status of the disks according to LVM (and particularly the lvs tool).
module Ganeti.Storage.Lvm.Types

-- | This is the format of the report produced by each data collector.
data LVInfo
LVInfo :: String -> String -> String -> Int -> Int -> Int -> Int -> Int -> Int -> String -> String -> String -> String -> String -> Int -> Int -> Int -> String -> String -> String -> Maybe String -> LVInfo
lviUuid :: LVInfo -> String
lviName :: LVInfo -> String
lviAttr :: LVInfo -> String
lviMajor :: LVInfo -> Int
lviMinor :: LVInfo -> Int
lviKernelMajor :: LVInfo -> Int
lviKernelMinor :: LVInfo -> Int
lviSize :: LVInfo -> Int
lviSegCount :: LVInfo -> Int
lviTags :: LVInfo -> String
lviModules :: LVInfo -> String
lviVgUuid :: LVInfo -> String
lviVgName :: LVInfo -> String
lviSegtype :: LVInfo -> String
lviSegStart :: LVInfo -> Int
lviSegStartPe :: LVInfo -> Int
lviSegSize :: LVInfo -> Int
lviSegTags :: LVInfo -> String
lviSegPeRanges :: LVInfo -> String
lviDevices :: LVInfo -> String
lviInstance :: LVInfo -> Maybe String
loadLVInfo :: JSValue -> Result LVInfo
saveLVInfo :: LVInfo -> JSValue
instance Show LVInfo
instance Eq LVInfo
instance JSON LVInfo
instance ArrayObject LVInfo
instance DictObject LVInfo


-- | Logical Volumer information parser
--   
--   This module holds the definition of the parser that extracts status
--   information about the logical volumes (LVs) of the system from the
--   output of the <tt>lvs</tt> command.
module Ganeti.Storage.Lvm.LVParser
lvsSeparator :: Char
skipSpaces :: Parser ()
bytesP :: Parser Int
intP :: Parser Int
stringP :: Parser String

-- | The command providing the data, in the format the parser expects
lvCommand :: String

-- | The parameters for getting the data in the format the parser expects
lvParams :: [String]
oneLvParser :: Parser LVInfo

-- | The parser for a whole diskstatus file.
lvParser :: Parser [LVInfo]


-- | Implementation of the Ganeti Query2 language.
module Ganeti.Query.Language

-- | Status of a query field.
data ResultStatus
RSNormal :: ResultStatus
RSUnknown :: ResultStatus
RSNoData :: ResultStatus
RSUnavail :: ResultStatus
RSOffline :: ResultStatus
resultStatusFromRaw :: Monad m_a2h3R => Int -> m_a2h3R ResultStatus
resultStatusToRaw :: ResultStatus -> Int

-- | Check that ResultStatus is success or fail with descriptive message.
checkRS :: Monad m => ResultStatus -> a -> m a

-- | Type of a query field.
data FieldType
QFTUnknown :: FieldType
QFTText :: FieldType
QFTBool :: FieldType
QFTNumber :: FieldType
QFTNumberFloat :: FieldType
QFTUnit :: FieldType
QFTTimestamp :: FieldType
QFTOther :: FieldType
fieldTypeFromRaw :: Monad m_a2h9T => String -> m_a2h9T FieldType
fieldTypeToRaw :: FieldType -> String

-- | Supported items on which Qlang works.
data QueryTypeOp
QRCluster :: QueryTypeOp
QRInstance :: QueryTypeOp
QRNode :: QueryTypeOp
QRGroup :: QueryTypeOp
QROs :: QueryTypeOp
QRExport :: QueryTypeOp
QRNetwork :: QueryTypeOp
queryTypeOpFromRaw :: Monad m_a2hfu => String -> m_a2hfu QueryTypeOp
queryTypeOpToRaw :: QueryTypeOp -> String

-- | Supported items on which Qlang works.
data QueryTypeLuxi
QRLock :: QueryTypeLuxi
QRJob :: QueryTypeLuxi
QRFilter :: QueryTypeLuxi
queryTypeLuxiFromRaw :: Monad m_a2hk1 => String -> m_a2hk1 QueryTypeLuxi
queryTypeLuxiToRaw :: QueryTypeLuxi -> String

-- | Overall query type.
data ItemType
ItemTypeLuxi :: QueryTypeLuxi -> ItemType
ItemTypeOpCode :: QueryTypeOp -> ItemType
decodeItemType :: Monad m => JSValue -> m ItemType
type RegexType = Regex

-- | List of requested fields.
type Fields = [String]

-- | Query2 filter expression. It's a parameteric type since we can filter
--   different "things"; e.g. field names, or actual field getters, etc.
data Filter a

-- | No filter at all
EmptyFilter :: Filter a

-- | <tt>&amp;</tt> [<i>expression</i>, ...]
AndFilter :: [Filter a] -> Filter a

-- | <tt>|</tt> [<i>expression</i>, ...]
OrFilter :: [Filter a] -> Filter a

-- | <tt>!</tt> <i>expression</i>
NotFilter :: (Filter a) -> Filter a

-- | <tt>?</tt> <i>field</i>
TrueFilter :: a -> Filter a

-- | <tt>(=|!=)</tt> <i>field</i> <i>value</i>
EQFilter :: a -> FilterValue -> Filter a

-- | <tt>&lt;</tt> <i>field</i> <i>value</i>
LTFilter :: a -> FilterValue -> Filter a

-- | <tt>&gt;</tt> <i>field</i> <i>value</i>
GTFilter :: a -> FilterValue -> Filter a

-- | <tt>&lt;=</tt> <i>field</i> <i>value</i>
LEFilter :: a -> FilterValue -> Filter a

-- | <tt>&gt;=</tt> <i>field</i> <i>value</i>
GEFilter :: a -> FilterValue -> Filter a

-- | <tt>=~</tt> <i>field</i> <i>regexp</i>
RegexpFilter :: a -> FilterRegex -> Filter a

-- | <tt>=[]</tt> <i>list-field</i> <i>value</i>
ContainsFilter :: a -> FilterValue -> Filter a

-- | Get the "things" a filter talks about. This is useful, e.g., to decide
--   which additional fields to fetch in a query depending on live data.
filterArguments :: Filter a -> [a]
showFilter :: JSON a => Filter a -> JSValue
readFilter :: JSON a => JSValue -> Result (Filter a)
readFilterArg :: JSON a => (Filter a -> Filter a) -> [JSValue] -> Result (Filter a)
readFilterField :: JSON a => (a -> Filter a) -> [JSValue] -> Result (Filter a)
readFilterFieldValue :: (JSON a, JSON b) => (a -> b -> Filter a) -> [JSValue] -> Result (Filter a)
readFilterArray :: JSON a => String -> [JSValue] -> Result (Filter a)

-- | Field name to filter on.
type FilterField = String

-- | Value to compare the field value to, for filtering purposes.
data FilterValue
QuotedString :: String -> FilterValue
NumericValue :: Integer -> FilterValue

-- | Serialiser for <a>FilterValue</a>. The Python code just sends this to
--   JSON as-is, so we'll do the same.
showFilterValue :: FilterValue -> JSValue
readFilterValue :: JSValue -> Result FilterValue

-- | Regexp to apply to the filter value, for filtering purposes. It holds
--   both the string format, and the "compiled" format, so that we don't
--   re-compile the regex at each match attempt.
data FilterRegex
FilterRegex :: String -> RegexType -> FilterRegex

-- | The string version of the regex
stringRegex :: FilterRegex -> String

-- | The compiled regex
compiledRegex :: FilterRegex -> RegexType

-- | Builder for <a>FilterRegex</a>. We always attempt to compile the
--   regular expression on the initialisation of the data structure; this
--   might fail, if the RE is not well-formed.
mkRegex :: Monad m => String -> m FilterRegex

-- | Name of a field.
type FieldName = String

-- | Title of a field, when represented in tabular format.
type FieldTitle = String

-- | Human redable description of a field.
type FieldDoc = String

-- | Definition of a field.
data FieldDefinition
FieldDefinition :: FieldName -> FieldTitle -> FieldType -> FieldDoc -> FieldDefinition
fdefName :: FieldDefinition -> FieldName
fdefTitle :: FieldDefinition -> FieldTitle
fdefKind :: FieldDefinition -> FieldType
fdefDoc :: FieldDefinition -> FieldDoc
loadFieldDefinition :: JSValue -> Result FieldDefinition
saveFieldDefinition :: FieldDefinition -> JSValue
data ResultEntry
ResultEntry :: ResultStatus -> Maybe ResultValue -> ResultEntry

-- | The result status
rentryStatus :: ResultEntry -> ResultStatus

-- | The (optional) result value
rentryValue :: ResultEntry -> Maybe ResultValue
type ResultRow = [ResultEntry]

-- | Value of a field, in json encoding. (its type will be depending on
--   ResultStatus and FieldType)
type ResultValue = JSValue

-- | Query2 query.
data Query
Query :: ItemType -> Fields -> (Filter FilterField) -> Query

-- | Query2 result.
data QueryResult
QueryResult :: [FieldDefinition] -> [ResultRow] -> QueryResult
qresFields :: QueryResult -> [FieldDefinition]
qresData :: QueryResult -> [ResultRow]
loadQueryResult :: JSValue -> Result QueryResult
saveQueryResult :: QueryResult -> JSValue

-- | Query2 Fields query. (to get supported fields names, descriptions, and
--   types)
data QueryFields
QueryFields :: ItemType -> Fields -> QueryFields

-- | Query2 Fields result.
data QueryFieldsResult
QueryFieldsResult :: [FieldDefinition] -> QueryFieldsResult
qfieldresFields :: QueryFieldsResult -> [FieldDefinition]
loadQueryFieldsResult :: JSValue -> Result QueryFieldsResult
saveQueryFieldsResult :: QueryFieldsResult -> JSValue
instance Show QueryFieldsResult
instance Eq QueryFieldsResult
instance JSON QueryFieldsResult
instance ArrayObject QueryFieldsResult
instance DictObject QueryFieldsResult
instance Show QueryResult
instance Eq QueryResult
instance JSON QueryResult
instance ArrayObject QueryResult
instance DictObject QueryResult
instance Show FieldDefinition
instance Eq FieldDefinition
instance Show ResultEntry
instance Eq ResultEntry
instance JSON ResultEntry
instance NFData ResultEntry
instance JSON FieldDefinition
instance ArrayObject FieldDefinition
instance DictObject FieldDefinition
instance Show ItemType
instance Eq ItemType
instance Show FilterValue
instance Eq FilterValue
instance Ord FilterValue
instance Show a => Show (Filter a)
instance Eq a => Eq (Filter a)
instance Ord a => Ord (Filter a)
instance Functor Filter
instance Foldable Filter
instance Traversable Filter
instance JSON FilterRegex
instance Ord FilterRegex
instance Eq FilterRegex
instance Show FilterRegex
instance JSON FilterValue
instance JSON a => JSON (Filter a)
instance JSON ItemType
instance JSON QueryTypeLuxi
instance Show QueryTypeLuxi
instance Eq QueryTypeLuxi
instance Enum QueryTypeLuxi
instance Bounded QueryTypeLuxi
instance Ord QueryTypeLuxi
instance JSON QueryTypeOp
instance Show QueryTypeOp
instance Eq QueryTypeOp
instance Enum QueryTypeOp
instance Bounded QueryTypeOp
instance Ord QueryTypeOp
instance JSON FieldType
instance Show FieldType
instance Eq FieldType
instance Enum FieldType
instance Bounded FieldType
instance Ord FieldType
instance NFData ResultStatus
instance JSON ResultStatus
instance Show ResultStatus
instance Eq ResultStatus
instance Enum ResultStatus
instance Bounded ResultStatus
instance Ord ResultStatus


-- | Template Haskell code for Haskell to Python constants.
module Ganeti.Hs2Py.GenConstants
fileFromModule :: Maybe String -> String
comment :: Name -> String
genList :: Name -> [Name] -> Q [Dec]
genPyConstants :: String -> [Name] -> Q [Dec]


-- | Implementation of the Ganeti Disk config object.
module Ganeti.Objects.Disk

-- | Constant for the dev_type key entry in the disk config.
devType :: String

-- | The disk parameters type.
type DiskParams = Container JSValue

-- | An alias for DRBD secrets
type DRBDSecret = String
data LogicalVolume
LogicalVolume :: String -> String -> LogicalVolume
lvGroup :: LogicalVolume -> String
lvVolume :: LogicalVolume -> String

-- | The disk configuration type. This includes the disk type itself, for a
--   more complete consistency. Note that since in the Python code-base
--   there's no authoritative place where we document the logical id, this
--   is probably a good reference point. There is a bijective
--   correspondence between the <a>DiskLogicalId</a> constructors and
--   <a>DiskTemplate</a>.
data DiskLogicalId

-- | Volume group, logical volume
LIDPlain :: LogicalVolume -> DiskLogicalId

-- | NodeA, NodeB, Port, MinorA, MinorB, Secret
LIDDrbd8 :: String -> String -> Int -> Int -> Int -> (Private DRBDSecret) -> DiskLogicalId

-- | Driver, path
LIDFile :: FileDriver -> String -> DiskLogicalId

-- | Driver, path
LIDSharedFile :: FileDriver -> String -> DiskLogicalId

-- | Driver, path
LIDGluster :: FileDriver -> String -> DiskLogicalId

-- | Driver, path (must be under /dev)
LIDBlockDev :: BlockDriver -> String -> DiskLogicalId

-- | Unused, path
LIDRados :: String -> String -> DiskLogicalId

-- | ExtProvider, unique name
LIDExt :: String -> String -> DiskLogicalId

-- | Mapping from a logical id to a disk type.
lidDiskType :: DiskLogicalId -> DiskTemplate

-- | Builds the extra disk_type field for a given logical id.
lidEncodeType :: DiskLogicalId -> [(String, JSValue)]

-- | Custom encoder for DiskLogicalId (logical id only).
encodeDLId :: DiskLogicalId -> JSValue

-- | Custom encoder for DiskLogicalId, composing both the logical id and
--   the extra disk_type field.
encodeFullDLId :: DiskLogicalId -> (JSValue, [(String, JSValue)])

-- | Custom decoder for DiskLogicalId. This is manual for now, since we
--   don't have yet automation for separate-key style fields.
decodeDLId :: [(String, JSValue)] -> JSValue -> Result DiskLogicalId

-- | Disk data structure.
data Disk
RealDisk :: RealDiskData -> Disk
ForthcomingDisk :: ForthcomingDiskData -> Disk
data ForthcomingDiskData
ForthcomingDiskData :: Maybe DiskLogicalId -> [Disk] -> [String] -> String -> Maybe Int -> DiskMode -> Maybe String -> Maybe Int -> Maybe DiskParams -> String -> Int -> ClockTime -> ClockTime -> ForthcomingDiskData
forthcomingDiskLogicalId :: ForthcomingDiskData -> Maybe DiskLogicalId
forthcomingDiskChildren :: ForthcomingDiskData -> [Disk]
forthcomingDiskNodes :: ForthcomingDiskData -> [String]
forthcomingDiskIvName :: ForthcomingDiskData -> String
forthcomingDiskSize :: ForthcomingDiskData -> Maybe Int
forthcomingDiskMode :: ForthcomingDiskData -> DiskMode
forthcomingDiskName :: ForthcomingDiskData -> Maybe String
forthcomingDiskSpindles :: ForthcomingDiskData -> Maybe Int
forthcomingDiskParams :: ForthcomingDiskData -> Maybe DiskParams
forthcomingDiskUuid :: ForthcomingDiskData -> String
forthcomingDiskSerial :: ForthcomingDiskData -> Int
forthcomingDiskCtime :: ForthcomingDiskData -> ClockTime
forthcomingDiskMtime :: ForthcomingDiskData -> ClockTime
data RealDiskData
RealDiskData :: DiskLogicalId -> [Disk] -> [String] -> String -> Int -> DiskMode -> Maybe String -> Maybe Int -> Maybe DiskParams -> String -> Int -> ClockTime -> ClockTime -> RealDiskData
realDiskLogicalId :: RealDiskData -> DiskLogicalId
realDiskChildren :: RealDiskData -> [Disk]
realDiskNodes :: RealDiskData -> [String]
realDiskIvName :: RealDiskData -> String
realDiskSize :: RealDiskData -> Int
realDiskMode :: RealDiskData -> DiskMode
realDiskName :: RealDiskData -> Maybe String
realDiskSpindles :: RealDiskData -> Maybe Int
realDiskParams :: RealDiskData -> Maybe DiskParams
realDiskUuid :: RealDiskData -> String
realDiskSerial :: RealDiskData -> Int
realDiskCtime :: RealDiskData -> ClockTime
realDiskMtime :: RealDiskData -> ClockTime
diskMtimeL :: Lens' Disk ClockTime
diskCtimeL :: Lens' Disk ClockTime
diskSerialL :: Lens' Disk Int
diskUuidL :: Lens' Disk String
diskParamsL :: Lens' Disk (Maybe DiskParams)
diskSpindlesL :: Lens' Disk (Maybe Int)
diskNameL :: Lens' Disk (Maybe String)
diskModeL :: Lens' Disk DiskMode
diskIvNameL :: Lens' Disk String
diskNodesL :: Lens' Disk [String]
diskChildrenL :: Lens' Disk [Disk]
diskMtime :: Disk -> ClockTime
diskCtime :: Disk -> ClockTime
diskSerial :: Disk -> Int
diskUuid :: Disk -> String
diskParams :: Disk -> Maybe DiskParams
diskSpindles :: Disk -> Maybe Int
diskName :: Disk -> Maybe String
diskMode :: Disk -> DiskMode
diskSize :: Disk -> Maybe Int
diskIvName :: Disk -> String
diskNodes :: Disk -> [String]
diskChildren :: Disk -> [Disk]
diskLogicalId :: Disk -> Maybe DiskLogicalId
diskForthcoming :: Disk -> Bool
loadForthcomingDiskData :: JSValue -> Result ForthcomingDiskData
saveForthcomingDiskData :: ForthcomingDiskData -> JSValue
loadRealDiskData :: JSValue -> Result RealDiskData
saveRealDiskData :: RealDiskData -> JSValue

-- | Determines whether a disk or one of his children has the given logical
--   id (determined by the volume group name and by the logical volume
--   name). This can be true only for DRBD or LVM disks.
includesLogicalId :: LogicalVolume -> Disk -> Bool
instance Show Disk
instance Eq Disk
instance Show ForthcomingDiskData
instance Eq ForthcomingDiskData
instance Show RealDiskData
instance Eq RealDiskData
instance ForthcomingObject Disk
instance UuidObject Disk
instance ArrayObject Disk
instance DictObject Disk
instance JSON Disk
instance JSON ForthcomingDiskData
instance ArrayObject ForthcomingDiskData
instance DictObject ForthcomingDiskData
instance JSON RealDiskData
instance ArrayObject RealDiskData
instance DictObject RealDiskData
instance Eq LogicalVolume
instance Ord LogicalVolume
instance Show DiskLogicalId
instance Eq DiskLogicalId
instance JSON LogicalVolume
instance Validatable LogicalVolume
instance Show LogicalVolume


-- | Implementation of the Ganeti Instance config object.
module Ganeti.Objects.Nic
data FilledNicParams
FilledNicParams :: NICMode -> String -> String -> FilledNicParams
nicpMode :: FilledNicParams -> NICMode
nicpLink :: FilledNicParams -> String
nicpVlan :: FilledNicParams -> String
data PartialNicParams
PartialNicParams :: Maybe NICMode -> Maybe String -> Maybe String -> PartialNicParams
nicpModeP :: PartialNicParams -> Maybe NICMode
nicpLinkP :: PartialNicParams -> Maybe String
nicpVlanP :: PartialNicParams -> Maybe String
allNicParamFields :: [String]
loadPartialNicParams :: JSValue -> Result PartialNicParams
savePartialNicParams :: PartialNicParams -> JSValue
loadFilledNicParams :: JSValue -> Result FilledNicParams
saveFilledNicParams :: FilledNicParams -> JSValue
data PartialNic
PartialNic :: String -> Maybe String -> PartialNicParams -> Maybe String -> Maybe String -> String -> PartialNic
nicMac :: PartialNic -> String
nicIp :: PartialNic -> Maybe String
nicNicparams :: PartialNic -> PartialNicParams
nicNetwork :: PartialNic -> Maybe String
nicName :: PartialNic -> Maybe String
nicUuid :: PartialNic -> String
loadPartialNic :: JSValue -> Result PartialNic
savePartialNic :: PartialNic -> JSValue
instance Show PartialNic
instance Eq PartialNic
instance UuidObject PartialNic
instance JSON PartialNic
instance ArrayObject PartialNic
instance DictObject PartialNic
instance Show FilledNicParams
instance Eq FilledNicParams
instance Show PartialNicParams
instance Eq PartialNicParams
instance Monoid PartialNicParams
instance PartialParams FilledNicParams PartialNicParams
instance JSON PartialNicParams
instance ArrayObject PartialNicParams
instance DictObject PartialNicParams
instance JSON FilledNicParams
instance ArrayObject FilledNicParams
instance DictObject FilledNicParams


-- | Implementation of the Ganeti Instance config object.
module Ganeti.Objects.Instance
data FilledBeParams
FilledBeParams :: Int -> Int -> Int -> Bool -> Bool -> Int -> FilledBeParams
bepMinmem :: FilledBeParams -> Int
bepMaxmem :: FilledBeParams -> Int
bepVcpus :: FilledBeParams -> Int
bepAutoBalance :: FilledBeParams -> Bool
bepAlwaysFailover :: FilledBeParams -> Bool
bepSpindleUse :: FilledBeParams -> Int
data PartialBeParams
PartialBeParams :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe Int -> PartialBeParams
bepMinmemP :: PartialBeParams -> Maybe Int
bepMaxmemP :: PartialBeParams -> Maybe Int
bepVcpusP :: PartialBeParams -> Maybe Int
bepAutoBalanceP :: PartialBeParams -> Maybe Bool
bepAlwaysFailoverP :: PartialBeParams -> Maybe Bool
bepSpindleUseP :: PartialBeParams -> Maybe Int
allBeParamFields :: [String]
loadPartialBeParams :: JSValue -> Result PartialBeParams
savePartialBeParams :: PartialBeParams -> JSValue
loadFilledBeParams :: JSValue -> Result FilledBeParams
saveFilledBeParams :: FilledBeParams -> JSValue
data RealInstanceData
RealInstanceData :: String -> String -> String -> Hypervisor -> HvParams -> PartialBeParams -> OsParams -> OsParamsPrivate -> AdminState -> AdminStateSource -> [PartialNic] -> [String] -> Bool -> Maybe Int -> ClockTime -> ClockTime -> String -> Int -> TagSet -> RealInstanceData
realInstName :: RealInstanceData -> String
realInstPrimaryNode :: RealInstanceData -> String
realInstOs :: RealInstanceData -> String
realInstHypervisor :: RealInstanceData -> Hypervisor
realInstHvparams :: RealInstanceData -> HvParams
realInstBeparams :: RealInstanceData -> PartialBeParams
realInstOsparams :: RealInstanceData -> OsParams
realInstOsparamsPrivate :: RealInstanceData -> OsParamsPrivate
realInstAdminState :: RealInstanceData -> AdminState
realInstAdminStateSource :: RealInstanceData -> AdminStateSource
realInstNics :: RealInstanceData -> [PartialNic]
realInstDisks :: RealInstanceData -> [String]
realInstDisksActive :: RealInstanceData -> Bool
realInstNetworkPort :: RealInstanceData -> Maybe Int
realInstCtime :: RealInstanceData -> ClockTime
realInstMtime :: RealInstanceData -> ClockTime
realInstUuid :: RealInstanceData -> String
realInstSerial :: RealInstanceData -> Int
realInstTags :: RealInstanceData -> TagSet
data ForthcomingInstanceData
ForthcomingInstanceData :: Maybe String -> Maybe String -> Maybe String -> Maybe Hypervisor -> HvParams -> PartialBeParams -> OsParams -> OsParamsPrivate -> Maybe AdminState -> Maybe AdminStateSource -> [PartialNic] -> [String] -> Maybe Bool -> Maybe Int -> ClockTime -> ClockTime -> String -> Int -> TagSet -> ForthcomingInstanceData
forthcomingInstName :: ForthcomingInstanceData -> Maybe String
forthcomingInstPrimaryNode :: ForthcomingInstanceData -> Maybe String
forthcomingInstOs :: ForthcomingInstanceData -> Maybe String
forthcomingInstHypervisor :: ForthcomingInstanceData -> Maybe Hypervisor
forthcomingInstHvparams :: ForthcomingInstanceData -> HvParams
forthcomingInstBeparams :: ForthcomingInstanceData -> PartialBeParams
forthcomingInstOsparams :: ForthcomingInstanceData -> OsParams
forthcomingInstOsparamsPrivate :: ForthcomingInstanceData -> OsParamsPrivate
forthcomingInstAdminState :: ForthcomingInstanceData -> Maybe AdminState
forthcomingInstAdminStateSource :: ForthcomingInstanceData -> Maybe AdminStateSource
forthcomingInstNics :: ForthcomingInstanceData -> [PartialNic]
forthcomingInstDisks :: ForthcomingInstanceData -> [String]
forthcomingInstDisksActive :: ForthcomingInstanceData -> Maybe Bool
forthcomingInstNetworkPort :: ForthcomingInstanceData -> Maybe Int
forthcomingInstCtime :: ForthcomingInstanceData -> ClockTime
forthcomingInstMtime :: ForthcomingInstanceData -> ClockTime
forthcomingInstUuid :: ForthcomingInstanceData -> String
forthcomingInstSerial :: ForthcomingInstanceData -> Int
forthcomingInstTags :: ForthcomingInstanceData -> TagSet
data Instance
RealInstance :: RealInstanceData -> Instance
ForthcomingInstance :: ForthcomingInstanceData -> Instance
instTagsL :: Lens' Instance TagSet
instSerialL :: Lens' Instance Int
instUuidL :: Lens' Instance String
instMtimeL :: Lens' Instance ClockTime
instCtimeL :: Lens' Instance ClockTime
instNetworkPortL :: Lens' Instance (Maybe Int)
instDisksL :: Lens' Instance [String]
instNicsL :: Lens' Instance [PartialNic]
instOsparamsPrivateL :: Lens' Instance OsParamsPrivate
instOsparamsL :: Lens' Instance OsParams
instBeparamsL :: Lens' Instance PartialBeParams
instHvparamsL :: Lens' Instance HvParams
instTags :: Instance -> TagSet
instSerial :: Instance -> Int
instUuid :: Instance -> String
instMtime :: Instance -> ClockTime
instCtime :: Instance -> ClockTime
instNetworkPort :: Instance -> Maybe Int
instDisksActive :: Instance -> Maybe Bool
instDisks :: Instance -> [String]
instNics :: Instance -> [PartialNic]
instAdminStateSource :: Instance -> Maybe AdminStateSource
instAdminState :: Instance -> Maybe AdminState
instOsparamsPrivate :: Instance -> OsParamsPrivate
instOsparams :: Instance -> OsParams
instBeparams :: Instance -> PartialBeParams
instHvparams :: Instance -> HvParams
instHypervisor :: Instance -> Maybe Hypervisor
instOs :: Instance -> Maybe String
instPrimaryNode :: Instance -> Maybe String
instName :: Instance -> Maybe String
instForthcoming :: Instance -> Bool
loadForthcomingInstanceData :: JSValue -> Result ForthcomingInstanceData
saveForthcomingInstanceData :: ForthcomingInstanceData -> JSValue
loadRealInstanceData :: JSValue -> Result RealInstanceData
saveRealInstanceData :: RealInstanceData -> JSValue
instance Show RealInstanceData
instance Eq RealInstanceData
instance Show ForthcomingInstanceData
instance Eq ForthcomingInstanceData
instance Show Instance
instance Eq Instance
instance ForthcomingObject Instance
instance TagsObject Instance
instance SerialNoObject Instance
instance UuidObject Instance
instance TimeStampObject Instance
instance ArrayObject Instance
instance DictObject Instance
instance JSON Instance
instance JSON ForthcomingInstanceData
instance ArrayObject ForthcomingInstanceData
instance DictObject ForthcomingInstanceData
instance JSON RealInstanceData
instance ArrayObject RealInstanceData
instance DictObject RealInstanceData
instance Show FilledBeParams
instance Eq FilledBeParams
instance Show PartialBeParams
instance Eq PartialBeParams
instance Monoid PartialBeParams
instance PartialParams FilledBeParams PartialBeParams
instance JSON PartialBeParams
instance ArrayObject PartialBeParams
instance DictObject PartialBeParams
instance JSON FilledBeParams
instance ArrayObject FilledBeParams
instance DictObject FilledBeParams


-- | Diskstats data types
--   
--   This module holds the definition of the data types describing the
--   status of the disks according to the information contained in
--   <tt><i>proc</i>diskstats</tt>.
module Ganeti.Storage.Diskstats.Types

-- | This is the format of the report produced by each data collector.
data Diskstats
Diskstats :: Int -> Int -> String -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Diskstats
dsMajor :: Diskstats -> Int
dsMinor :: Diskstats -> Int
dsName :: Diskstats -> String
dsReadsNum :: Diskstats -> Int
dsMergedReads :: Diskstats -> Int
dsSecRead :: Diskstats -> Int
dsTimeRead :: Diskstats -> Int
dsWrites :: Diskstats -> Int
dsMergedWrites :: Diskstats -> Int
dsSecWritten :: Diskstats -> Int
dsTimeWrite :: Diskstats -> Int
dsIos :: Diskstats -> Int
dsTimeIO :: Diskstats -> Int
dsWIOmillis :: Diskstats -> Int
loadDiskstats :: JSValue -> Result Diskstats
saveDiskstats :: Diskstats -> JSValue
instance Show Diskstats
instance Eq Diskstats
instance JSON Diskstats
instance ArrayObject Diskstats
instance DictObject Diskstats


-- | Diskstats proc file parser
--   
--   This module holds the definition of the parser that extracts status
--   information about the disks of the system from the
--   <tt><i>proc</i>diskstats</tt> file.
module Ganeti.Storage.Diskstats.Parser
oneDiskstatsParser :: Parser Diskstats

-- | The parser for a whole diskstatus file.
diskstatsParser :: Parser [Diskstats]


-- | Contains the list of the Haskell to Python constants.
--   
--   Note that this file is autogenerated by the Makefile with a header
--   from <tt>ListConstants.hs.in</tt>.
module Ganeti.Hs2Py.ListConstants
pyConstants :: [(String, String)]
putConstants :: IO ()


-- | Implementation of DataCollectors CLI functions.
--   
--   This module holds the common command-line related functions for the
--   collector binaries.
module Ganeti.DataCollectors.CLI

-- | Command line options structure.
data Options
Options :: Bool -> Bool -> Bool -> Maybe FilePath -> Maybe FilePath -> Maybe String -> Maybe String -> Maybe Int -> Maybe FilePath -> Maybe FilePath -> Options

-- | Just show the help
optShowHelp :: Options -> Bool

-- | Just show the completion info
optShowComp :: Options -> Bool

-- | Just show the program version
optShowVer :: Options -> Bool

-- | Path to the file containing DRBD status information
optDrbdStatus :: Options -> Maybe FilePath

-- | Path to the file containing pairings between instances and DRBD minors
optDrbdPairing :: Options -> Maybe FilePath

-- | Info are requested for this node
optNode :: Options -> Maybe String

-- | IP address of the Confd server
optConfdAddr :: Options -> Maybe String

-- | The port of the Confd server to connect to
optConfdPort :: Options -> Maybe Int

-- | Path to the file containing the information to be parsed
optInputFile :: Options -> Maybe FilePath

-- | Path to the file contained a serialized list of instances as in:
--   ([Primary], [Secondary])
optInstances :: Options -> Maybe FilePath

-- | Default values for the command line options.
defaultOptions :: Options

-- | Abbreviation for the option type.
type OptType = GenericOptType Options
oDrbdPairing :: OptType
oDrbdStatus :: OptType
oNode :: OptType
oConfdAddr :: OptType
oConfdPort :: OptType
oInputFile :: OptType
oInstances :: OptType

-- | Generic options.
genericOptions :: [GenericOptType Options]
instance Show Options
instance StandardOptions Options


-- | Data types for Xen-specific hypervisor functionalities.
module Ganeti.Hypervisor.Xen.Types

-- | Data type representing configuration data as produced by the <tt>xm
--   list --long</tt> command.
data LispConfig
LCList :: [LispConfig] -> LispConfig
LCString :: String -> LispConfig
LCDouble :: Double -> LispConfig

-- | Data type representing a Xen Domain.
data Domain
Domain :: Int -> String -> Double -> ActualState -> Maybe Bool -> Domain
domId :: Domain -> Int
domName :: Domain -> String
domCpuTime :: Domain -> Double
domState :: Domain -> ActualState
domIsHung :: Domain -> Maybe Bool

-- | Class representing all the types that can be extracted from
--   LispConfig.
class FromLispConfig a
fromLispConfig :: FromLispConfig a => LispConfig -> Result a
data UptimeInfo
UptimeInfo :: String -> Int -> String -> UptimeInfo
uInfoName :: UptimeInfo -> String
uInfoID :: UptimeInfo -> Int
uInfoUptime :: UptimeInfo -> String
data ActualState

-- | The instance is running
ActualRunning :: ActualState

-- | The instance is not running or runnable
ActualBlocked :: ActualState

-- | The instance has been paused
ActualPaused :: ActualState

-- | The instance is shut down
ActualShutdown :: ActualState

-- | The instance has crashed
ActualCrashed :: ActualState

-- | The instance is in process of dying
ActualDying :: ActualState

-- | The instance is hung
ActualHung :: ActualState

-- | Unknown state. Parsing error.
ActualUnknown :: ActualState
instance Eq LispConfig
instance Show LispConfig
instance Eq UptimeInfo
instance Show UptimeInfo
instance Show ActualState
instance Eq ActualState
instance Show Domain
instance Eq Domain
instance JSON ActualState
instance FromLispConfig [LispConfig]
instance FromLispConfig String
instance FromLispConfig Double
instance FromLispConfig Int


-- | Module describing an instance.
--   
--   The instance data type holds very few fields, the algorithm
--   intelligence is in the <a>Node</a> and <a>Cluster</a> modules.
module Ganeti.HTools.Instance
data Disk
Disk :: Int -> Maybe Int -> Disk

-- | Size in bytes
dskSize :: Disk -> Int

-- | Number of spindles
dskSpindles :: Disk -> Maybe Int

-- | The instance type.
data Instance
Instance :: String -> String -> Int -> Int -> [Disk] -> Int -> InstanceStatus -> Ndx -> Ndx -> Idx -> DynUtil -> Bool -> Bool -> DiskTemplate -> Int -> [String] -> [String] -> Int -> AutoRepairPolicy -> [Nic] -> Bool -> Instance

-- | The instance name
name :: Instance -> String

-- | The shortened name
alias :: Instance -> String

-- | Memory of the instance
mem :: Instance -> Int

-- | Total disk usage of the instance
dsk :: Instance -> Int

-- | Sizes of the individual disks
disks :: Instance -> [Disk]

-- | Number of VCPUs
vcpus :: Instance -> Int

-- | Original run status
runSt :: Instance -> InstanceStatus

-- | Original primary node
pNode :: Instance -> Ndx

-- | Original secondary node
sNode :: Instance -> Ndx

-- | Internal index
idx :: Instance -> Idx

-- | Dynamic resource usage
util :: Instance -> DynUtil

-- | Can and should the instance be moved?
movable :: Instance -> Bool

-- | Is the instance auto-balanced?
autoBalance :: Instance -> Bool

-- | The disk template of the instance
diskTemplate :: Instance -> DiskTemplate

-- | The numbers of used spindles
spindleUse :: Instance -> Int

-- | List of all instance tags
allTags :: Instance -> [String]

-- | List of instance exclusion tags
exclTags :: Instance -> [String]

-- | The number of common-failures between primary and secondary node of
--   the instance
locationScore :: Instance -> Int

-- | Instance's auto-repair policy
arPolicy :: Instance -> AutoRepairPolicy

-- | NICs of the instance
nics :: Instance -> [Nic]

-- | Is the instance is forthcoming?
forthcoming :: Instance -> Bool

-- | Check if instance is running.
isRunning :: Instance -> Bool

-- | Check if instance is offline.
isOffline :: Instance -> Bool

-- | Helper to check if the instance is not offline.
notOffline :: Instance -> Bool

-- | Check if instance is down.
instanceDown :: Instance -> Bool

-- | Apply the function if the instance is online. Otherwise use the
--   initial value
applyIfOnline :: Instance -> (a -> a) -> a -> a

-- | Helper for determining whether an instance's memory needs to be taken
--   into account for secondary memory reservation.
usesSecMem :: Instance -> Bool

-- | Constant holding the local storage templates.
--   
--   <i>Note:</i> Currently Ganeti only exports node total/free disk space
--   for LVM-based storage; file-based storage is ignored in this model, so
--   even though file-based storage uses in reality disk space on the node,
--   in our model it won't affect it and we can't compute whether there is
--   enough disk space for a file-based instance. Therefore we will treat
--   this template as 'foreign' storage.
localStorageTemplates :: [DiskTemplate]
movableDiskTemplates :: [DiskTemplate]

-- | A simple name for the int, instance association list.
type AssocList = [(Idx, Instance)]

-- | A simple name for an instance map.
type List = Container Instance

-- | Create an instance.
--   
--   Some parameters are not initialized by function, and must be set later
--   (via <a>setIdx</a> for example).
create :: String -> Int -> Int -> [Disk] -> Int -> InstanceStatus -> [String] -> Bool -> Ndx -> Ndx -> DiskTemplate -> Int -> [Nic] -> Bool -> Instance

-- | Changes the index.
--   
--   This is used only during the building of the data structures.
setIdx :: Instance -> Idx -> Instance

-- | Changes the name.
--   
--   This is used only during the building of the data structures.
setName :: Instance -> String -> Instance

-- | Changes the alias.
--   
--   This is used only during the building of the data structures.
setAlias :: Instance -> String -> Instance

-- | Changes the primary node of the instance.
setPri :: Instance -> Ndx -> Instance

-- | Changes the secondary node of the instance.
setSec :: Instance -> Ndx -> Instance

-- | Changes both nodes of the instance.
setBoth :: Instance -> Ndx -> Ndx -> Instance

-- | Sets the movable flag on an instance.
setMovable :: Instance -> Bool -> Instance

-- | Try to shrink the instance based on the reason why we can't allocate
--   it.
shrinkByType :: Instance -> FailMode -> Result Instance

-- | Get the number of disk spindles
getTotalSpindles :: Instance -> Maybe Int

-- | Return the spec of an instance.
specOf :: Instance -> RSpec
instCompareISpec :: Ordering -> Instance -> ISpec -> Bool -> OpResult ()

-- | Checks if an instance is smaller than a given spec.
instBelowISpec :: Instance -> ISpec -> Bool -> OpResult ()

-- | Checks if an instance is bigger than a given spec.
instAboveISpec :: Instance -> ISpec -> Bool -> OpResult ()
instMatchesMinMaxSpecs :: Instance -> MinMaxISpecs -> Bool -> OpResult ()
instMatchesSpecs :: Instance -> [MinMaxISpecs] -> Bool -> OpResult ()

-- | Checks if an instance matches a policy.
instMatchesPolicy :: Instance -> IPolicy -> Bool -> OpResult ()

-- | Checks whether the instance uses a secondary node.
--   
--   <i>Note:</i> This should be reconciled with <tt><a>sNode</a> ==
--   <a>noSecondary</a></tt>.
hasSecondary :: Instance -> Bool

-- | Computed the number of nodes for a given disk template.
requiredNodes :: DiskTemplate -> Int

-- | Computes all nodes of an instance.
allNodes :: Instance -> [Ndx]

-- | Checks whether a given disk template uses local storage.
usesLocalStorage :: Instance -> Bool
supportsMoves :: DiskTemplate -> Bool

-- | A simple wrapper over <a>templateMirrorType</a>.
mirrorType :: Instance -> MirrorType

-- | Whether the instance uses memory on its host node. Depends on the
--   <tt>InstanceStatus</tt> and on whether the instance is forthcoming;
--   instances that aren't running or existent don't use memory.
usesMemory :: Instance -> Bool
instance Show Disk
instance Eq Disk
instance Show Instance
instance Eq Instance
instance Element Instance


-- | Implementation of opcodes parameters.
--   
--   These are defined in a separate module only due to TemplateHaskell
--   stage restrictions - expressions defined in the current module can't
--   be passed to splices. So we have to either parameters/repeat each
--   parameter definition multiple times, or separate them into this
--   module.
module Ganeti.OpParams
booleanField :: String -> Field
defaultFalse :: String -> Field
defaultTrue :: String -> Field
stringField :: String -> Field
optionalStringField :: String -> Field
optionalNEStringField :: String -> Field
forceNonNeg :: (Num a, Ord a, Show a) => a -> NonNegative a

-- | Disk index type (embedding constraints on the index value via a smart
--   constructor).
newtype DiskIndex
DiskIndex :: Int -> DiskIndex
unDiskIndex :: DiskIndex -> Int

-- | Smart constructor for <a>DiskIndex</a>.
mkDiskIndex :: Monad m => Int -> m DiskIndex

-- | Type holding disk access modes.
data DiskAccess
DiskReadOnly :: DiskAccess
DiskReadWrite :: DiskAccess
diskAccessFromRaw :: Monad m_a3kL7 => String -> m_a3kL7 DiskAccess
diskAccessToRaw :: DiskAccess -> String

-- | NIC modification definition.
data INicParams
INicParams :: Maybe NonEmptyString -> Maybe String -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe String -> Maybe NonEmptyString -> Maybe NonEmptyString -> INicParams
inicMac :: INicParams -> Maybe NonEmptyString
inicIp :: INicParams -> Maybe String
inicMode :: INicParams -> Maybe NonEmptyString
inicLink :: INicParams -> Maybe NonEmptyString
inicName :: INicParams -> Maybe NonEmptyString
inicVlan :: INicParams -> Maybe String
inicBridge :: INicParams -> Maybe NonEmptyString
inicNetwork :: INicParams -> Maybe NonEmptyString
loadINicParams :: JSValue -> Result INicParams
saveINicParams :: INicParams -> JSValue

-- | Disk modification definition.
data IDiskParams
IDiskParams :: Maybe Int -> Maybe DiskAccess -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe Int -> Maybe NonEmptyString -> Map String JSValue -> IDiskParams
idiskSize :: IDiskParams -> Maybe Int
idiskMode :: IDiskParams -> Maybe DiskAccess
idiskAdopt :: IDiskParams -> Maybe NonEmptyString
idiskVg :: IDiskParams -> Maybe NonEmptyString
idiskMetavg :: IDiskParams -> Maybe NonEmptyString
idiskName :: IDiskParams -> Maybe NonEmptyString
idiskProvider :: IDiskParams -> Maybe NonEmptyString
idiskSpindles :: IDiskParams -> Maybe Int
idiskAccess :: IDiskParams -> Maybe NonEmptyString
idiskOpaque :: IDiskParams -> Map String JSValue
loadIDiskParams :: JSValue -> Result IDiskParams
saveIDiskParams :: IDiskParams -> JSValue

-- | Disk changes type for OpInstanceRecreateDisks. This is a bit strange,
--   because the type in Python is something like Either [DiskIndex]
--   [DiskChanges], but we can't represent the type of an empty list in
--   JSON, so we have to add a custom case for the empty list.
data RecreateDisksInfo
RecreateDisksAll :: RecreateDisksInfo
RecreateDisksIndices :: (NonEmpty DiskIndex) -> RecreateDisksInfo
RecreateDisksParams :: (NonEmpty (DiskIndex, IDiskParams)) -> RecreateDisksInfo
readRecreateDisks :: JSValue -> Result RecreateDisksInfo

-- | Simple type for old-style ddm changes.
data DdmOldChanges
DdmOldIndex :: (NonNegative Int) -> DdmOldChanges
DdmOldMod :: DdmSimple -> DdmOldChanges
readDdmOldChanges :: JSValue -> Result DdmOldChanges

-- | Instance disk or nic modifications.
data SetParamsMods a
SetParamsEmpty :: SetParamsMods a
SetParamsDeprecated :: (NonEmpty (DdmOldChanges, a)) -> SetParamsMods a
SetParamsNew :: (NonEmpty (DdmFull, Int, a)) -> SetParamsMods a
SetParamsNewName :: (NonEmpty (DdmFull, String, a)) -> SetParamsMods a
readSetParams :: JSON a => JSValue -> Result (SetParamsMods a)

-- | Custom type for target_node parameter of OpBackupExport, which varies
--   depending on mode. FIXME: this uses an [JSValue] since we don't care
--   about individual rows (just like the Python code tests). But the
--   proper type could be parsed if we wanted.
data ExportTarget
ExportTargetLocal :: NonEmptyString -> ExportTarget
ExportTargetRemote :: [JSValue] -> ExportTarget
readExportTarget :: JSValue -> Result ExportTarget
pDryRun :: Field
pDebugLevel :: Field
pOpPriority :: Field
pDependencies :: Field
pComment :: Field
pReason :: Field
pSequential :: Field
pDebugSimulateErrors :: Field
pErrorCodes :: Field
pSkipChecks :: Field
pIgnoreErrors :: Field
pVerbose :: Field
pDebug :: Field
pOptGroupName :: Field
pGroupName :: Field

-- | Whether to hotplug device.
pHotplug :: Field
pHotplugIfPossible :: Field
pInstances :: Field
pOutputFields :: Field
pName :: Field
pForce :: Field
pHvState :: Field
pDiskState :: Field

-- | Cluster-wide default directory for storing file-backed disks.
pClusterFileStorageDir :: Field

-- | Cluster-wide default directory for storing shared-file-backed disks.
pClusterSharedFileStorageDir :: Field

-- | Cluster-wide default directory for storing Gluster-backed disks.
pClusterGlusterStorageDir :: Field
pInstallImage :: Field
pInstanceCommunicationNetwork :: Field

-- | The OS to use when zeroing instance disks.
pZeroingImage :: Field

-- | The additional tools that can be used to compress data in transit
pCompressionTools :: Field

-- | Volume group name.
pVgName :: Field
pEnabledHypervisors :: Field
pClusterHvParams :: Field
pClusterBeParams :: Field
pOsHvp :: Field
pClusterOsParams :: Field
pClusterOsParamsPrivate :: Field
pGroupDiskParams :: Field
pCandidatePoolSize :: Field
pMaxRunningJobs :: Field
pMaxTrackedJobs :: Field
pUidPool :: Field
pAddUids :: Field
pRemoveUids :: Field
pMaintainNodeHealth :: Field

-- | Whether to modify and keep in sync the <tt><i>etc</i>hosts</tt> files
--   of nodes.
pModifyEtcHosts :: Field

-- | Whether to wipe disks before allocating them to instances.
pPreallocWipeDisks :: Field
pNicParams :: Field
pIpolicy :: Field
pDrbdHelper :: Field
pDefaultIAllocator :: Field
pDefaultIAllocatorParams :: Field
pMasterNetdev :: Field
pMasterNetmask :: Field
pReservedLvs :: Field
pHiddenOs :: Field
pBlacklistedOs :: Field
pUseExternalMipScript :: Field
pEnabledDiskTemplates :: Field
pEnabledUserShutdown :: Field
pQueryWhat :: Field
pUseLocking :: Field
pQueryFields :: Field
pQueryFilter :: Field
pQueryFieldsFields :: Field
pNodeNames :: Field
pNodeUuids :: Field
pOobCommand :: Field
pOobTimeout :: Field
pIgnoreStatus :: Field
pPowerDelay :: Field
pRequiredNodes :: Field
pRequiredNodeUuids :: Field
pRestrictedCommand :: Field
pNodeName :: Field
pNodeUuid :: Field
pPrimaryIp :: Field
pSecondaryIp :: Field
pReadd :: Field
pNodeGroup :: Field
pMasterCapable :: Field
pVmCapable :: Field
pNdParams :: Field
pNames :: Field
pNodes :: Field
pStorageType :: Field
pOptStorageType :: Field
pStorageName :: Field
pStorageChanges :: Field
pIgnoreConsistency :: Field
pIgnoreHVVersions :: Field
pMasterCandidate :: Field
pOffline :: Field
pDrained :: Field
pAutoPromote :: Field
pPowered :: Field
pMigrationMode :: Field
pMigrationLive :: Field
pMigrationTargetNode :: Field
pMigrationTargetNodeUuid :: Field
pAllowRuntimeChgs :: Field
pIgnoreIpolicy :: Field
pIallocator :: Field
pEarlyRelease :: Field
pRemoteNode :: Field
pRemoteNodeUuid :: Field
pEvacMode :: Field
pIgnoreSoftErrors :: Field
pInstanceName :: Field
pInstanceCommunication :: Field
pOptInstanceCommunication :: Field
pForceVariant :: Field
pWaitForSync :: Field
pNameCheck :: Field
pInstBeParams :: Field
pInstDisks :: Field
pDiskTemplate :: Field
pExtParams :: Field
pFileDriver :: Field
pFileStorageDir :: Field
pInstHvParams :: Field
pHypervisor :: Field
pResetDefaults :: Field
pIpCheck :: Field
pIpConflictsCheck :: Field
pInstCreateMode :: Field
pInstNics :: Field
pNoInstall :: Field
pInstOs :: Field
pInstOsParams :: Field
pInstOsParamsPrivate :: Field
pInstOsParamsSecret :: Field
pPrimaryNode :: Field
pPrimaryNodeUuid :: Field
pSecondaryNode :: Field
pSecondaryNodeUuid :: Field
pSourceHandshake :: Field
pSourceInstance :: Field
pSourceShutdownTimeout :: Field
pSourceX509Ca :: Field
pSrcNode :: Field
pSrcNodeUuid :: Field
pSrcPath :: Field
pStartInstance :: Field
pForthcoming :: Field
pCommit :: Field
pInstTags :: Field
pMultiAllocInstances :: Field
pOpportunisticLocking :: Field
pInstanceUuid :: Field
pTempOsParams :: Field
pTempOsParamsPrivate :: Field
pTempOsParamsSecret :: Field
pShutdownTimeout :: Field

-- | Another name for the shutdown timeout, because we like to be
--   inconsistent.
pShutdownTimeout' :: Field
pIgnoreFailures :: Field
pNewName :: Field
pIgnoreOfflineNodes :: Field
pTempHvParams :: Field
pTempBeParams :: Field
pNoRemember :: Field
pStartupPaused :: Field
pIgnoreSecondaries :: Field
pRebootType :: Field
pReplaceDisksMode :: Field
pReplaceDisksList :: Field
pMigrationCleanup :: Field
pAllowFailover :: Field
pForceFailover :: Field
pMoveTargetNode :: Field
pMoveTargetNodeUuid :: Field
pMoveCompress :: Field
pBackupCompress :: Field
pIgnoreDiskSize :: Field
pWaitForSyncFalse :: Field
pRecreateDisksInfo :: Field
pStatic :: Field
pInstParamsNicChanges :: Field
pInstParamsDiskChanges :: Field
pRuntimeMem :: Field
pOptDiskTemplate :: Field
pOsNameChange :: Field
pDiskIndex :: Field
pDiskChgAmount :: Field
pDiskChgAbsolute :: Field
pTargetGroups :: Field
pNodeGroupAllocPolicy :: Field
pGroupNodeParams :: Field
pExportMode :: Field
pExportTargetNode :: Field
pExportTargetNodeUuid :: Field
pShutdownInstance :: Field
pRemoveInstance :: Field
pIgnoreRemoveFailures :: Field
pX509KeyName :: Field
pX509DestCA :: Field
pZeroFreeSpace :: Field
pHelperStartupTimeout :: Field
pHelperShutdownTimeout :: Field
pZeroingTimeoutFixed :: Field
pZeroingTimeoutPerMiB :: Field
pTagsObject :: Field
pTagsName :: Field
pTagsList :: Field
pTagSearchPattern :: Field
pDelayDuration :: Field
pDelayOnMaster :: Field
pDelayOnNodes :: Field
pDelayOnNodeUuids :: Field
pDelayRepeat :: Field
pDelayInterruptible :: Field
pDelayNoLocks :: Field
pIAllocatorDirection :: Field
pIAllocatorMode :: Field
pIAllocatorReqName :: Field
pIAllocatorNics :: Field
pIAllocatorDisks :: Field
pIAllocatorMemory :: Field
pIAllocatorVCpus :: Field
pIAllocatorOs :: Field
pIAllocatorInstances :: Field
pIAllocatorEvacMode :: Field
pIAllocatorSpindleUse :: Field
pIAllocatorCount :: Field
pJQueueNotifyWaitLock :: Field
pJQueueNotifyExec :: Field
pJQueueLogMessages :: Field
pJQueueFail :: Field
pTestDummyResult :: Field
pTestDummyMessages :: Field
pTestDummyFail :: Field
pTestDummySubmitJobs :: Field
pNetworkName :: Field
pNetworkAddress4 :: Field
pNetworkGateway4 :: Field
pNetworkAddress6 :: Field
pNetworkGateway6 :: Field
pNetworkMacPrefix :: Field
pNetworkAddRsvdIps :: Field
pNetworkRemoveRsvdIps :: Field
pNetworkMode :: Field
pNetworkLink :: Field
pAdminStateSource :: Field
pNetworkVlan :: Field
pEnabledDataCollectors :: Field
pDataCollectorInterval :: Field
pNodeSslCerts :: Field
pSshKeys :: Field
pNodeSetup :: Field
pVerifyClutter :: Field
pLongSleep :: Field
instance Ord IDiskParams
instance Show IDiskParams
instance Eq IDiskParams
instance Eq RecreateDisksInfo
instance Show RecreateDisksInfo
instance Ord RecreateDisksInfo
instance Eq DdmOldChanges
instance Show DdmOldChanges
instance Ord DdmOldChanges
instance Eq a => Eq (SetParamsMods a)
instance Show a => Show (SetParamsMods a)
instance Ord a => Ord (SetParamsMods a)
instance Eq ExportTarget
instance Show ExportTarget
instance Ord ExportTarget
instance JSON ExportTarget
instance JSON a => JSON (SetParamsMods a)
instance JSON DdmOldChanges
instance JSON RecreateDisksInfo
instance JSON IDiskParams
instance ArrayObject IDiskParams
instance DictObject IDiskParams
instance Ord INicParams
instance Show INicParams
instance Eq INicParams
instance JSON INicParams
instance ArrayObject INicParams
instance DictObject INicParams
instance JSON DiskAccess
instance Show DiskAccess
instance Eq DiskAccess
instance Enum DiskAccess
instance Bounded DiskAccess
instance Ord DiskAccess
instance Show DiskIndex
instance Eq DiskIndex
instance Ord DiskIndex
instance JSON DiskIndex


-- | Implementation of the opcodes.
module Ganeti.OpCodes
type JobIdListOnly = Map String [(Bool, Either String JobId)]
type InstanceMultiAllocResponse = ([(Bool, Either String JobId)], NonEmptyString)
type QueryFieldDef = (NonEmptyString, NonEmptyString, TagKind, NonEmptyString)
type QueryResponse = ([QueryFieldDef], [[(QueryResultCode, JSValue)]])
type QueryFieldsResponse = [QueryFieldDef]

-- | OpCode representation.
--   
--   We only implement a subset of Ganeti opcodes: those which are actually
--   used in the htools codebase.
data OpCode
OpClusterPostInit :: OpCode
OpClusterDestroy :: OpCode
OpClusterQuery :: OpCode
OpClusterVerify :: Bool -> Bool -> ListSet VerifyOptionalChecks -> ListSet CVErrorCode -> Bool -> Maybe NonEmptyString -> Bool -> OpCode
opDebugSimulateErrors :: OpCode -> Bool
opErrorCodes :: OpCode -> Bool
opSkipChecks :: OpCode -> ListSet VerifyOptionalChecks
opIgnoreErrors :: OpCode -> ListSet CVErrorCode
opVerbose :: OpCode -> Bool
opOptGroupName :: OpCode -> Maybe NonEmptyString
opVerifyClutter :: OpCode -> Bool
OpClusterVerifyConfig :: Bool -> Bool -> ListSet CVErrorCode -> Bool -> OpCode
opDebugSimulateErrors :: OpCode -> Bool
opErrorCodes :: OpCode -> Bool
opIgnoreErrors :: OpCode -> ListSet CVErrorCode
opVerbose :: OpCode -> Bool
OpClusterVerifyGroup :: NonEmptyString -> Bool -> Bool -> ListSet VerifyOptionalChecks -> ListSet CVErrorCode -> Bool -> Bool -> OpCode
opGroupName :: OpCode -> NonEmptyString
opDebugSimulateErrors :: OpCode -> Bool
opErrorCodes :: OpCode -> Bool
opSkipChecks :: OpCode -> ListSet VerifyOptionalChecks
opIgnoreErrors :: OpCode -> ListSet CVErrorCode
opVerbose :: OpCode -> Bool
opVerifyClutter :: OpCode -> Bool
OpClusterVerifyDisks :: OpCode
OpGroupVerifyDisks :: NonEmptyString -> OpCode
opGroupName :: OpCode -> NonEmptyString
OpClusterRepairDiskSizes :: [NonEmptyString] -> OpCode
opInstances :: OpCode -> [NonEmptyString]
OpClusterConfigQuery :: [NonEmptyString] -> OpCode
opOutputFields :: OpCode -> [NonEmptyString]
OpClusterRename :: NonEmptyString -> OpCode
opName :: OpCode -> NonEmptyString
OpClusterSetParams :: Bool -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe String -> Maybe [Hypervisor] -> Maybe (GenericContainer String (JSObject JSValue)) -> Maybe (JSObject JSValue) -> Maybe (GenericContainer String (JSObject JSValue)) -> Maybe (GenericContainer String (JSObject JSValue)) -> Maybe (GenericContainer String (JSObject (Private JSValue))) -> Maybe (GenericContainer DiskTemplate (JSObject JSValue)) -> Maybe (Positive Int) -> Maybe (Positive Int) -> Maybe (Positive Int) -> Maybe [(Int, Int)] -> Maybe [(Int, Int)] -> Maybe [(Int, Int)] -> Maybe Bool -> Maybe Bool -> Maybe INicParams -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe String -> Maybe String -> Maybe (JSObject JSValue) -> Maybe NonEmptyString -> Maybe String -> Maybe (NonNegative Int) -> Maybe [NonEmptyString] -> Maybe [(DdmSimple, NonEmptyString)] -> Maybe [(DdmSimple, NonEmptyString)] -> Maybe Bool -> Maybe [DiskTemplate] -> Maybe Bool -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe [NonEmptyString] -> Maybe Bool -> Maybe (GenericContainer String Bool) -> Maybe (GenericContainer String Int) -> OpCode
opForce :: OpCode -> Bool
opHvState :: OpCode -> Maybe (JSObject JSValue)
opDiskState :: OpCode -> Maybe (JSObject JSValue)
opVgName :: OpCode -> Maybe String
opEnabledHypervisors :: OpCode -> Maybe [Hypervisor]
opClusterHvParams :: OpCode -> Maybe (GenericContainer String (JSObject JSValue))
opClusterBeParams :: OpCode -> Maybe (JSObject JSValue)
opOsHvp :: OpCode -> Maybe (GenericContainer String (JSObject JSValue))
opClusterOsParams :: OpCode -> Maybe (GenericContainer String (JSObject JSValue))
opClusterOsParamsPrivate :: OpCode -> Maybe (GenericContainer String (JSObject (Private JSValue)))
opDiskparams :: OpCode -> Maybe (GenericContainer DiskTemplate (JSObject JSValue))
opCandidatePoolSize :: OpCode -> Maybe (Positive Int)
opMaxRunningJobs :: OpCode -> Maybe (Positive Int)
opMaxTrackedJobs :: OpCode -> Maybe (Positive Int)
opUidPool :: OpCode -> Maybe [(Int, Int)]
opAddUids :: OpCode -> Maybe [(Int, Int)]
opRemoveUids :: OpCode -> Maybe [(Int, Int)]
opMaintainNodeHealth :: OpCode -> Maybe Bool
opPreallocWipeDisks :: OpCode -> Maybe Bool
opNicparams :: OpCode -> Maybe INicParams
opgenericNdParams :: OpCode -> Maybe (JSObject JSValue)
opIpolicy :: OpCode -> Maybe (JSObject JSValue)
opDrbdHelper :: OpCode -> Maybe String
opDefaultIallocator :: OpCode -> Maybe String
opDefaultIallocatorParams :: OpCode -> Maybe (JSObject JSValue)
opNetMacPrefix :: OpCode -> Maybe NonEmptyString
opMasterNetdev :: OpCode -> Maybe String
opMasterNetmask :: OpCode -> Maybe (NonNegative Int)
opReservedLvs :: OpCode -> Maybe [NonEmptyString]
opHiddenOs :: OpCode -> Maybe [(DdmSimple, NonEmptyString)]
opBlacklistedOs :: OpCode -> Maybe [(DdmSimple, NonEmptyString)]
opUseExternalMipScript :: OpCode -> Maybe Bool
opEnabledDiskTemplates :: OpCode -> Maybe [DiskTemplate]
opModifyEtcHosts :: OpCode -> Maybe Bool
opClusterFileStorageDir :: OpCode -> Maybe String
opClusterSharedFileStorageDir :: OpCode -> Maybe String
opClusterGlusterStorageDir :: OpCode -> Maybe String
opInstallImage :: OpCode -> Maybe String
opInstanceCommunicationNetwork :: OpCode -> Maybe String
opZeroingImage :: OpCode -> Maybe String
opCompressionTools :: OpCode -> Maybe [NonEmptyString]
opEnabledUserShutdown :: OpCode -> Maybe Bool
opEnabledDataCollectors :: OpCode -> Maybe (GenericContainer String Bool)
opDataCollectorInterval :: OpCode -> Maybe (GenericContainer String Int)
OpClusterRedistConf :: OpCode
OpClusterActivateMasterIp :: OpCode
OpClusterDeactivateMasterIp :: OpCode
OpClusterRenewCrypto :: Bool -> Bool -> Bool -> Bool -> OpCode
opNodeCertificates :: OpCode -> Bool
opSshKeys :: OpCode -> Bool
opVerbose :: OpCode -> Bool
opDebug :: OpCode -> Bool
OpQuery :: QueryTypeOp -> Bool -> [NonEmptyString] -> Maybe [JSValue] -> OpCode
opWhat :: OpCode -> QueryTypeOp
opUseLocking :: OpCode -> Bool
opFields :: OpCode -> [NonEmptyString]
opQfilter :: OpCode -> Maybe [JSValue]
OpQueryFields :: QueryTypeOp -> Maybe [NonEmptyString] -> OpCode
opWhat :: OpCode -> QueryTypeOp
opQueryFieldsFields :: OpCode -> Maybe [NonEmptyString]
OpOobCommand :: [NonEmptyString] -> Maybe [NonEmptyString] -> OobCommand -> Int -> Bool -> Double -> OpCode
opNodeNames :: OpCode -> [NonEmptyString]
opNodeUuids :: OpCode -> Maybe [NonEmptyString]
opOobCommand :: OpCode -> OobCommand
opOobTimeout :: OpCode -> Int
opIgnoreStatus :: OpCode -> Bool
opPowerDelay :: OpCode -> Double
OpRestrictedCommand :: Bool -> [NonEmptyString] -> Maybe [NonEmptyString] -> NonEmptyString -> OpCode
opUseLocking :: OpCode -> Bool
opReqNodes  :: OpCode -> [NonEmptyString]
opReqNodeUuids  :: OpCode -> Maybe [NonEmptyString]
opRestrictedCommand :: OpCode -> NonEmptyString
OpNodeRemove :: NonEmptyString -> Maybe NonEmptyString -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
OpNodeAdd :: NonEmptyString -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe NonEmptyString -> Maybe NonEmptyString -> Bool -> Maybe NonEmptyString -> Maybe Bool -> Maybe Bool -> Maybe (JSObject JSValue) -> Bool -> OpCode
opNodeName :: OpCode -> NonEmptyString
opHvState :: OpCode -> Maybe (JSObject JSValue)
opDiskState :: OpCode -> Maybe (JSObject JSValue)
opPrimaryIp :: OpCode -> Maybe NonEmptyString
opSecondaryIp :: OpCode -> Maybe NonEmptyString
opReadd :: OpCode -> Bool
opGroup :: OpCode -> Maybe NonEmptyString
opMasterCapable :: OpCode -> Maybe Bool
opVmCapable :: OpCode -> Maybe Bool
opgenericNdParams :: OpCode -> Maybe (JSObject JSValue)
opNodeSetup :: OpCode -> Bool
OpNodeQueryvols :: [NonEmptyString] -> [NonEmptyString] -> OpCode
opOutputFields :: OpCode -> [NonEmptyString]
opNodes :: OpCode -> [NonEmptyString]
OpNodeQueryStorage :: [NonEmptyString] -> Maybe StorageType -> [NonEmptyString] -> Maybe NonEmptyString -> OpCode
opOutputFields :: OpCode -> [NonEmptyString]
opOptStorageType :: OpCode -> Maybe StorageType
opNodes :: OpCode -> [NonEmptyString]
opStorageName :: OpCode -> Maybe NonEmptyString
OpNodeModifyStorage :: NonEmptyString -> Maybe NonEmptyString -> StorageType -> Maybe NonEmptyString -> JSObject JSValue -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opStorageType :: OpCode -> StorageType
opStorageName :: OpCode -> Maybe NonEmptyString
opChanges :: OpCode -> JSObject JSValue
OpRepairNodeStorage :: NonEmptyString -> Maybe NonEmptyString -> StorageType -> Maybe NonEmptyString -> Bool -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opStorageType :: OpCode -> StorageType
opStorageName :: OpCode -> Maybe NonEmptyString
opIgnoreConsistency :: OpCode -> Bool
OpNodeSetParams :: NonEmptyString -> Maybe NonEmptyString -> Bool -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Bool -> Maybe Bool -> Maybe Bool -> Maybe NonEmptyString -> Maybe (JSObject JSValue) -> Maybe Bool -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
opHvState :: OpCode -> Maybe (JSObject JSValue)
opDiskState :: OpCode -> Maybe (JSObject JSValue)
opMasterCandidate :: OpCode -> Maybe Bool
opOffline :: OpCode -> Maybe Bool
opDrained :: OpCode -> Maybe Bool
opAutoPromote :: OpCode -> Bool
opMasterCapable :: OpCode -> Maybe Bool
opVmCapable :: OpCode -> Maybe Bool
opSecondaryIp :: OpCode -> Maybe NonEmptyString
opgenericNdParams :: OpCode -> Maybe (JSObject JSValue)
opPowered :: OpCode -> Maybe Bool
OpNodePowercycle :: NonEmptyString -> Maybe NonEmptyString -> Bool -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
OpNodeMigrate :: NonEmptyString -> Maybe NonEmptyString -> Maybe MigrationMode -> Maybe Bool -> Maybe NonEmptyString -> Maybe NonEmptyString -> Bool -> Bool -> Maybe NonEmptyString -> OpCode
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opMigrationMode :: OpCode -> Maybe MigrationMode
opOldLiveMode :: OpCode -> Maybe Bool
opTargetNode :: OpCode -> Maybe NonEmptyString
opTargetNodeUuid :: OpCode -> Maybe NonEmptyString
opAllowRuntimeChanges :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
OpNodeEvacuate :: Bool -> NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> EvacMode -> Maybe Bool -> OpCode
opEarlyRelease :: OpCode -> Bool
opNodeName :: OpCode -> NonEmptyString
opNodeUuid :: OpCode -> Maybe NonEmptyString
opRemoteNode :: OpCode -> Maybe NonEmptyString
opRemoteNodeUuid :: OpCode -> Maybe NonEmptyString
opIallocator :: OpCode -> Maybe NonEmptyString
opEvacMode :: OpCode -> EvacMode
opIgnoreSoftErrors :: OpCode -> Maybe Bool
OpInstanceCreate :: String -> Bool -> Bool -> Bool -> Bool -> Bool -> JSObject JSValue -> [IDiskParams] -> Maybe DiskTemplate -> Maybe NonEmptyString -> Maybe FileDriver -> Maybe NonEmptyString -> JSObject JSValue -> Maybe Hypervisor -> Maybe NonEmptyString -> Bool -> Bool -> Bool -> InstCreateMode -> [INicParams] -> Maybe Bool -> JSObject JSValue -> Maybe (JSObject (Private JSValue)) -> Maybe (JSObject (Private JSValue)) -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe [JSValue] -> Maybe NonEmptyString -> NonNegative Int -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> String -> Bool -> Bool -> Bool -> [NonEmptyString] -> Bool -> Maybe Int -> Maybe Int -> OpCode
opInstanceName :: OpCode -> String
opForceVariant :: OpCode -> Bool
opWaitForSync :: OpCode -> Bool
opNameCheck :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
opOpportunisticLocking :: OpCode -> Bool
opInstBeParams :: OpCode -> JSObject JSValue
opinstDisks :: OpCode -> [IDiskParams]
opOptDiskTemplate :: OpCode -> Maybe DiskTemplate
opOptGroupName :: OpCode -> Maybe NonEmptyString
opFileDriver :: OpCode -> Maybe FileDriver
opFileStorageDir :: OpCode -> Maybe NonEmptyString
opInstHvParams :: OpCode -> JSObject JSValue
opHypervisor :: OpCode -> Maybe Hypervisor
opIallocator :: OpCode -> Maybe NonEmptyString
opIdentifyDefaults :: OpCode -> Bool
opIpCheck :: OpCode -> Bool
opConflictsCheck :: OpCode -> Bool
opInstCreateMode :: OpCode -> InstCreateMode
opNics :: OpCode -> [INicParams]
opNoInstall :: OpCode -> Maybe Bool
opInstOsParams :: OpCode -> JSObject JSValue
opOsparamsPrivate :: OpCode -> Maybe (JSObject (Private JSValue))
opOsparamsSecret :: OpCode -> Maybe (JSObject (Private JSValue))
opOsType :: OpCode -> Maybe NonEmptyString
opPnode :: OpCode -> Maybe NonEmptyString
opPnodeUuid :: OpCode -> Maybe NonEmptyString
opSnode :: OpCode -> Maybe NonEmptyString
opSnodeUuid :: OpCode -> Maybe NonEmptyString
opSourceHandshake :: OpCode -> Maybe [JSValue]
opSourceInstanceName :: OpCode -> Maybe NonEmptyString
opSourceShutdownTimeout :: OpCode -> NonNegative Int
opSourceX509Ca :: OpCode -> Maybe NonEmptyString
opSrcNode :: OpCode -> Maybe NonEmptyString
opSrcNodeUuid :: OpCode -> Maybe NonEmptyString
opSrcPath :: OpCode -> Maybe NonEmptyString
opCompress :: OpCode -> String
opStart :: OpCode -> Bool
opForthcoming :: OpCode -> Bool
opCommit :: OpCode -> Bool
opInstTags :: OpCode -> [NonEmptyString]
opInstanceCommunication :: OpCode -> Bool
opHelperStartupTimeout :: OpCode -> Maybe Int
opHelperShutdownTimeout :: OpCode -> Maybe Int
OpInstanceMultiAlloc :: Bool -> Maybe NonEmptyString -> [JSValue] -> OpCode
opOpportunisticLocking :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
opInstMultiAlloc :: OpCode -> [JSValue]
OpInstanceReinstall :: String -> Maybe NonEmptyString -> Bool -> Maybe NonEmptyString -> Maybe (JSObject JSValue) -> Maybe (JSObject (Private JSValue)) -> Maybe (JSObject (Private JSValue)) -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opForceVariant :: OpCode -> Bool
opOsType :: OpCode -> Maybe NonEmptyString
opTempOsParams :: OpCode -> Maybe (JSObject JSValue)
opOsparamsPrivate :: OpCode -> Maybe (JSObject (Private JSValue))
opOsparamsSecret :: OpCode -> Maybe (JSObject (Private JSValue))
OpInstanceRemove :: String -> Maybe NonEmptyString -> NonNegative Int -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opShutdownTimeout :: OpCode -> NonNegative Int
opIgnoreFailures :: OpCode -> Bool
OpInstanceRename :: String -> Maybe NonEmptyString -> NonEmptyString -> Bool -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opNewName :: OpCode -> NonEmptyString
opNameCheck :: OpCode -> Bool
opIpCheck :: OpCode -> Bool
OpInstanceStartup :: String -> Maybe NonEmptyString -> Bool -> Bool -> JSObject JSValue -> JSObject JSValue -> Bool -> Bool -> NonNegative Int -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
opIgnoreOfflineNodes :: OpCode -> Bool
opTempHvParams :: OpCode -> JSObject JSValue
opTempBeParams :: OpCode -> JSObject JSValue
opNoRemember :: OpCode -> Bool
opStartupPaused :: OpCode -> Bool
opShutdownTimeout :: OpCode -> NonNegative Int
OpInstanceShutdown :: String -> Maybe NonEmptyString -> Bool -> Bool -> NonNegative Int -> Bool -> Maybe AdminStateSource -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
opIgnoreOfflineNodes :: OpCode -> Bool
opInstShutdownTimeout :: OpCode -> NonNegative Int
opNoRemember :: OpCode -> Bool
opAdminStateSource :: OpCode -> Maybe AdminStateSource
OpInstanceReboot :: String -> Maybe NonEmptyString -> NonNegative Int -> Bool -> RebootType -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opShutdownTimeout :: OpCode -> NonNegative Int
opIgnoreSecondaries :: OpCode -> Bool
opRebootType :: OpCode -> RebootType
OpInstanceReplaceDisks :: String -> Maybe NonEmptyString -> Bool -> Bool -> ReplaceDisksMode -> [DiskIndex] -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opEarlyRelease :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
opReplaceDisksMode :: OpCode -> ReplaceDisksMode
opReplaceDisksList :: OpCode -> [DiskIndex]
opRemoteNode :: OpCode -> Maybe NonEmptyString
opRemoteNodeUuid :: OpCode -> Maybe NonEmptyString
opIallocator :: OpCode -> Maybe NonEmptyString
OpInstanceFailover :: String -> Maybe NonEmptyString -> NonNegative Int -> Bool -> Maybe NonEmptyString -> Maybe NonEmptyString -> Bool -> Bool -> Maybe NonEmptyString -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opShutdownTimeout :: OpCode -> NonNegative Int
opIgnoreConsistency :: OpCode -> Bool
opTargetNode :: OpCode -> Maybe NonEmptyString
opTargetNodeUuid :: OpCode -> Maybe NonEmptyString
opIgnoreIpolicy :: OpCode -> Bool
opMigrationCleanup :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
OpInstanceMigrate :: String -> Maybe NonEmptyString -> Maybe MigrationMode -> Maybe Bool -> Maybe NonEmptyString -> Maybe NonEmptyString -> Bool -> Bool -> Bool -> Maybe NonEmptyString -> Bool -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opMigrationMode :: OpCode -> Maybe MigrationMode
opOldLiveMode :: OpCode -> Maybe Bool
opTargetNode :: OpCode -> Maybe NonEmptyString
opTargetNodeUuid :: OpCode -> Maybe NonEmptyString
opAllowRuntimeChanges :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
opMigrationCleanup :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
opAllowFailover :: OpCode -> Bool
opIgnoreHvversions :: OpCode -> Bool
OpInstanceMove :: String -> Maybe NonEmptyString -> NonNegative Int -> Bool -> NonEmptyString -> Maybe NonEmptyString -> String -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opShutdownTimeout :: OpCode -> NonNegative Int
opIgnoreIpolicy :: OpCode -> Bool
opMoveTargetNode :: OpCode -> NonEmptyString
opMoveTargetNodeUuid :: OpCode -> Maybe NonEmptyString
opCompress :: OpCode -> String
opIgnoreConsistency :: OpCode -> Bool
OpInstanceConsole :: String -> Maybe NonEmptyString -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
OpInstanceActivateDisks :: String -> Maybe NonEmptyString -> Bool -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opIgnoreSize :: OpCode -> Bool
opWaitForSync :: OpCode -> Bool
OpInstanceDeactivateDisks :: String -> Maybe NonEmptyString -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
OpInstanceRecreateDisks :: String -> Maybe NonEmptyString -> RecreateDisksInfo -> [NonEmptyString] -> Maybe [NonEmptyString] -> Maybe NonEmptyString -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opRecreateDisksInfo :: OpCode -> RecreateDisksInfo
opNodes :: OpCode -> [NonEmptyString]
opNodeUuids :: OpCode -> Maybe [NonEmptyString]
opIallocator :: OpCode -> Maybe NonEmptyString
OpInstanceQueryData :: Bool -> [NonEmptyString] -> Bool -> OpCode
opUseLocking :: OpCode -> Bool
opInstances :: OpCode -> [NonEmptyString]
opStatic :: OpCode -> Bool
OpInstanceSetParams :: String -> Maybe NonEmptyString -> Bool -> Bool -> Bool -> SetParamsMods INicParams -> SetParamsMods IDiskParams -> JSObject JSValue -> Maybe (Positive Int) -> JSObject JSValue -> Maybe DiskTemplate -> JSObject JSValue -> Maybe FileDriver -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> Maybe NonEmptyString -> JSObject JSValue -> Maybe (JSObject (Private JSValue)) -> Bool -> Maybe Bool -> Bool -> Bool -> Bool -> Maybe Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opForce :: OpCode -> Bool
opForceVariant :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
opInstNicChanges :: OpCode -> SetParamsMods INicParams
opInstDiskChanges :: OpCode -> SetParamsMods IDiskParams
opInstBeParams :: OpCode -> JSObject JSValue
opRuntimeMem :: OpCode -> Maybe (Positive Int)
opInstHvParams :: OpCode -> JSObject JSValue
opOptDiskTemplate :: OpCode -> Maybe DiskTemplate
opInstExtParams :: OpCode -> JSObject JSValue
opFileDriver :: OpCode -> Maybe FileDriver
opFileStorageDir :: OpCode -> Maybe NonEmptyString
opPnode :: OpCode -> Maybe NonEmptyString
opPnodeUuid :: OpCode -> Maybe NonEmptyString
opRemoteNode :: OpCode -> Maybe NonEmptyString
opRemoteNodeUuid :: OpCode -> Maybe NonEmptyString
opOsName :: OpCode -> Maybe NonEmptyString
opInstOsParams :: OpCode -> JSObject JSValue
opOsparamsPrivate :: OpCode -> Maybe (JSObject (Private JSValue))
opWaitForSync :: OpCode -> Bool
opOffline :: OpCode -> Maybe Bool
opConflictsCheck :: OpCode -> Bool
opHotplug :: OpCode -> Bool
opHotplugIfPossible :: OpCode -> Bool
opOptInstanceCommunication :: OpCode -> Maybe Bool
OpInstanceGrowDisk :: String -> Maybe NonEmptyString -> Bool -> DiskIndex -> NonNegative Int -> Bool -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opWaitForSync :: OpCode -> Bool
opDiskIndex  :: OpCode -> DiskIndex
opDiskChgAmount :: OpCode -> NonNegative Int
opDiskChkAbsolute :: OpCode -> Bool
opIgnoreIpolicy :: OpCode -> Bool
OpInstanceChangeGroup :: String -> Maybe NonEmptyString -> Bool -> Maybe NonEmptyString -> Maybe [NonEmptyString] -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opEarlyRelease :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
opTargetGroups :: OpCode -> Maybe [NonEmptyString]
OpGroupAdd :: NonEmptyString -> Maybe AllocPolicy -> Maybe (JSObject JSValue) -> Maybe (GenericContainer DiskTemplate (JSObject JSValue)) -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> OpCode
opGroupName :: OpCode -> NonEmptyString
opAllocPolicy :: OpCode -> Maybe AllocPolicy
opNdparams :: OpCode -> Maybe (JSObject JSValue)
opDiskparams :: OpCode -> Maybe (GenericContainer DiskTemplate (JSObject JSValue))
opHvState :: OpCode -> Maybe (JSObject JSValue)
opDiskState :: OpCode -> Maybe (JSObject JSValue)
opIpolicy :: OpCode -> Maybe (JSObject JSValue)
OpGroupAssignNodes :: NonEmptyString -> Bool -> [NonEmptyString] -> Maybe [NonEmptyString] -> OpCode
opGroupName :: OpCode -> NonEmptyString
opForce :: OpCode -> Bool
opReqNodes  :: OpCode -> [NonEmptyString]
opReqNodeUuids  :: OpCode -> Maybe [NonEmptyString]
OpGroupSetParams :: NonEmptyString -> Maybe AllocPolicy -> Maybe (JSObject JSValue) -> Maybe (GenericContainer DiskTemplate (JSObject JSValue)) -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> Maybe (JSObject JSValue) -> OpCode
opGroupName :: OpCode -> NonEmptyString
opAllocPolicy :: OpCode -> Maybe AllocPolicy
opNdparams :: OpCode -> Maybe (JSObject JSValue)
opDiskparams :: OpCode -> Maybe (GenericContainer DiskTemplate (JSObject JSValue))
opHvState :: OpCode -> Maybe (JSObject JSValue)
opDiskState :: OpCode -> Maybe (JSObject JSValue)
opIpolicy :: OpCode -> Maybe (JSObject JSValue)
OpGroupRemove :: NonEmptyString -> OpCode
opGroupName :: OpCode -> NonEmptyString
OpGroupRename :: NonEmptyString -> NonEmptyString -> OpCode
opGroupName :: OpCode -> NonEmptyString
opNewName :: OpCode -> NonEmptyString
OpGroupEvacuate :: NonEmptyString -> Bool -> Maybe NonEmptyString -> Maybe [NonEmptyString] -> Bool -> Bool -> OpCode
opGroupName :: OpCode -> NonEmptyString
opEarlyRelease :: OpCode -> Bool
opIallocator :: OpCode -> Maybe NonEmptyString
opTargetGroups :: OpCode -> Maybe [NonEmptyString]
opSequential :: OpCode -> Bool
opForceFailover :: OpCode -> Bool
OpOsDiagnose :: [NonEmptyString] -> [NonEmptyString] -> OpCode
opOutputFields :: OpCode -> [NonEmptyString]
opNames :: OpCode -> [NonEmptyString]
OpExtStorageDiagnose :: [NonEmptyString] -> [NonEmptyString] -> OpCode
opOutputFields :: OpCode -> [NonEmptyString]
opNames :: OpCode -> [NonEmptyString]
OpBackupPrepare :: String -> Maybe NonEmptyString -> ExportMode -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opExportMode :: OpCode -> ExportMode
OpBackupExport :: String -> Maybe NonEmptyString -> String -> NonNegative Int -> ExportTarget -> Maybe NonEmptyString -> Bool -> Bool -> Bool -> ExportMode -> Maybe [JSValue] -> Maybe NonEmptyString -> Bool -> Maybe Int -> Maybe Double -> Bool -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
opCompress :: OpCode -> String
opShutdownTimeout :: OpCode -> NonNegative Int
opExportTarget :: OpCode -> ExportTarget
opExportTargetNodeUuid :: OpCode -> Maybe NonEmptyString
opShutdown :: OpCode -> Bool
opRemoveInstance :: OpCode -> Bool
opIgnoreRemoveFailures :: OpCode -> Bool
opExportMode :: OpCode -> ExportMode
opX509KeyName :: OpCode -> Maybe [JSValue]
opDestinationX509Ca :: OpCode -> Maybe NonEmptyString
opZeroFreeSpace :: OpCode -> Bool
opZeroingTimeoutFixed :: OpCode -> Maybe Int
opZeroingTimeoutPerMib :: OpCode -> Maybe Double
opLongSleep :: OpCode -> Bool
OpBackupRemove :: String -> Maybe NonEmptyString -> OpCode
opInstanceName :: OpCode -> String
opInstanceUuid :: OpCode -> Maybe NonEmptyString
OpTagsGet :: TagKind -> Bool -> Maybe String -> OpCode
opKind :: OpCode -> TagKind
opUseLocking :: OpCode -> Bool
opTagsGetName :: OpCode -> Maybe String
OpTagsSearch :: NonEmptyString -> OpCode
opTagSearchPattern :: OpCode -> NonEmptyString
OpTagsSet :: TagKind -> [String] -> Maybe String -> OpCode
opKind :: OpCode -> TagKind
opTagsList :: OpCode -> [String]
opTagsGetName :: OpCode -> Maybe String
OpTagsDel :: TagKind -> [String] -> Maybe String -> OpCode
opKind :: OpCode -> TagKind
opTagsList :: OpCode -> [String]
opTagsGetName :: OpCode -> Maybe String
OpTestDelay :: Double -> Bool -> [NonEmptyString] -> Maybe [NonEmptyString] -> NonNegative Int -> Bool -> Bool -> OpCode
opDelayDuration :: OpCode -> Double
opDelayOnMaster :: OpCode -> Bool
opDelayOnNodes :: OpCode -> [NonEmptyString]
opDelayOnNodeUuids :: OpCode -> Maybe [NonEmptyString]
opDelayRepeat :: OpCode -> NonNegative Int
opDelayInterruptible :: OpCode -> Bool
opDelayNoLocks :: OpCode -> Bool
OpTestAllocator :: IAllocatorTestDir -> IAllocatorMode -> NonEmptyString -> Maybe [INicParams] -> Maybe [JSValue] -> Maybe Hypervisor -> Maybe NonEmptyString -> [NonEmptyString] -> Maybe (NonNegative Int) -> Maybe (NonNegative Int) -> Maybe NonEmptyString -> Maybe DiskTemplate -> Maybe [NonEmptyString] -> Maybe EvacMode -> Maybe [NonEmptyString] -> NonNegative Int -> NonNegative Int -> Maybe NonEmptyString -> OpCode
opIAllocatorDirection :: OpCode -> IAllocatorTestDir
opIAllocatorMode :: OpCode -> IAllocatorMode
opIAllocatorReqName :: OpCode -> NonEmptyString
opIAllocatorNics :: OpCode -> Maybe [INicParams]
opIAllocatorDisks :: OpCode -> Maybe [JSValue]
opHypervisor :: OpCode -> Maybe Hypervisor
opIallocator :: OpCode -> Maybe NonEmptyString
opInstTags :: OpCode -> [NonEmptyString]
opIAllocatorMem :: OpCode -> Maybe (NonNegative Int)
opIAllocatorVCpus :: OpCode -> Maybe (NonNegative Int)
opIAllocatorOs :: OpCode -> Maybe NonEmptyString
opOptDiskTemplate :: OpCode -> Maybe DiskTemplate
opIAllocatorInstances  :: OpCode -> Maybe [NonEmptyString]
opIAllocatorEvacMode :: OpCode -> Maybe EvacMode
opTargetGroups :: OpCode -> Maybe [NonEmptyString]
opIAllocatorSpindleUse :: OpCode -> NonNegative Int
opIAllocatorCount :: OpCode -> NonNegative Int
opOptGroupName :: OpCode -> Maybe NonEmptyString
OpTestJqueue :: Bool -> Bool -> [String] -> Bool -> OpCode
opNotifyWaitlock :: OpCode -> Bool
opNotifyExec :: OpCode -> Bool
opLogMessages :: OpCode -> [String]
opJQueueFail :: OpCode -> Bool
OpTestDummy :: JSValue -> JSValue -> JSValue -> JSValue -> OpCode
opTestDummyResult :: OpCode -> JSValue
opTestDummyMessages :: OpCode -> JSValue
opTestDummyFail :: OpCode -> JSValue
opTestDummySubmitJobs :: OpCode -> JSValue
OpNetworkAdd :: NonEmptyString -> IPv4Network -> Maybe IPv4Address -> Maybe IPv6Network -> Maybe IPv6Address -> Maybe NonEmptyString -> Maybe [IPv4Address] -> Bool -> [NonEmptyString] -> OpCode
opNetworkName :: OpCode -> NonEmptyString
opNetworkAddress4 :: OpCode -> IPv4Network
opNetworkGateway4 :: OpCode -> Maybe IPv4Address
opNetworkAddress6 :: OpCode -> Maybe IPv6Network
opNetworkGateway6 :: OpCode -> Maybe IPv6Address
opNetMacPrefix :: OpCode -> Maybe NonEmptyString
opNetworkAddRsvdIps :: OpCode -> Maybe [IPv4Address]
opConflictsCheck :: OpCode -> Bool
opInstTags :: OpCode -> [NonEmptyString]
OpNetworkRemove :: NonEmptyString -> Bool -> OpCode
opNetworkName :: OpCode -> NonEmptyString
opForce :: OpCode -> Bool
OpNetworkSetParams :: NonEmptyString -> Maybe IPv4Address -> Maybe IPv6Network -> Maybe IPv6Address -> Maybe NonEmptyString -> Maybe [IPv4Address] -> Maybe [IPv4Address] -> OpCode
opNetworkName :: OpCode -> NonEmptyString
opNetworkGateway4 :: OpCode -> Maybe IPv4Address
opNetworkAddress6 :: OpCode -> Maybe IPv6Network
opNetworkGateway6 :: OpCode -> Maybe IPv6Address
opNetMacPrefix :: OpCode -> Maybe NonEmptyString
opNetworkAddRsvdIps :: OpCode -> Maybe [IPv4Address]
opNetworkRemoveRsvdIps :: OpCode -> Maybe [IPv4Address]
OpNetworkConnect :: NonEmptyString -> NonEmptyString -> NICMode -> NonEmptyString -> String -> Bool -> OpCode
opGroupName :: OpCode -> NonEmptyString
opNetworkName :: OpCode -> NonEmptyString
opNetworkMode :: OpCode -> NICMode
opNetworkLink :: OpCode -> NonEmptyString
opNetworkVlan :: OpCode -> String
opConflictsCheck :: OpCode -> Bool
OpNetworkDisconnect :: NonEmptyString -> NonEmptyString -> OpCode
opGroupName :: OpCode -> NonEmptyString
opNetworkName :: OpCode -> NonEmptyString
pyClasses :: [OpCodeDescriptor]
allOpFields :: String -> [String]

-- | Returns the OP_ID for a given opcode value.
opID :: OpCode -> String

-- | A list of all defined/supported opcode IDs.
allOpIDs :: [String]

-- | Convert the opcode name to lowercase with underscores and strip the
--   <tt>Op</tt> prefix.
opReasonSrcID :: OpCode -> String
opSummaryVal :: OpCode -> Maybe String

-- | Computes the summary of the opcode.
opSummary :: OpCode -> String

-- | Generic/common opcode parameters.
data CommonOpParams
CommonOpParams :: Maybe Bool -> Maybe (NonNegative Int) -> OpSubmitPriority -> Maybe [JobDependency] -> Maybe String -> ReasonTrail -> CommonOpParams
opDryRun :: CommonOpParams -> Maybe Bool
opDebugLevel :: CommonOpParams -> Maybe (NonNegative Int)
opPriority :: CommonOpParams -> OpSubmitPriority
opDepends :: CommonOpParams -> Maybe [JobDependency]
opComment :: CommonOpParams -> Maybe String
opReason :: CommonOpParams -> ReasonTrail
loadCommonOpParams :: JSValue -> Result CommonOpParams
saveCommonOpParams :: CommonOpParams -> JSValue

-- | Default common parameter values.
defOpParams :: CommonOpParams
resolveDependsCommon :: Monad m => CommonOpParams -> JobId -> m CommonOpParams

-- | The top-level opcode type.
data MetaOpCode
MetaOpCode :: CommonOpParams -> OpCode -> MetaOpCode
metaParams :: MetaOpCode -> CommonOpParams
metaOpCode :: MetaOpCode -> OpCode

-- | Resolve relative dependencies to absolute ones, given the job Id.
resolveDependencies :: Monad m => MetaOpCode -> JobId -> m MetaOpCode

-- | Wraps an <a>OpCode</a> with the default parameters to build a
--   <a>MetaOpCode</a>.
wrapOpCode :: OpCode -> MetaOpCode

-- | Sets the comment on a meta opcode.
setOpComment :: String -> MetaOpCode -> MetaOpCode

-- | Sets the priority on a meta opcode.
setOpPriority :: OpSubmitPriority -> MetaOpCode -> MetaOpCode
instance Ord CommonOpParams
instance Show CommonOpParams
instance Eq CommonOpParams
instance Show MetaOpCode
instance Eq MetaOpCode
instance Ord MetaOpCode
instance JSON MetaOpCode
instance DictObject MetaOpCode
instance JSON CommonOpParams
instance ArrayObject CommonOpParams
instance DictObject CommonOpParams
instance JSON OpCode
instance Ord OpCode
instance Show OpCode
instance Eq OpCode
instance DictObject OpCode
instance PyValue JSValue
instance PyValue a => PyValue (JSObject a)
instance PyValue INicParams
instance PyValue VerifyOptionalChecks
instance PyValue CVErrorCode
instance PyValue ExportMode
instance PyValue a => PyValue (NonEmpty a)
instance PyValue a => PyValue (NonNegative a)
instance PyValue a => PyValue (SetParamsMods a)
instance PyValue RecreateDisksInfo
instance PyValue IDiskParams
instance PyValue DiskIndex


-- | Module describing a node.
--   
--   All updates are functional (copy-based) and return a new node with
--   updated value.
module Ganeti.HTools.Node
type TagMap = Map String Int

-- | The node type.
data Node
Node :: String -> String -> Double -> Int -> Int -> Int -> Int -> Double -> Int -> Int -> Double -> Double -> Int -> Int -> Int -> Int -> Int -> Int -> [Idx] -> [Idx] -> [Idx] -> [Idx] -> Ndx -> PeerMap -> Bool -> Bool -> Int -> Int -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Int -> Int -> Double -> Double -> Double -> Bool -> Bool -> [String] -> DynUtil -> DynUtil -> DynUtil -> TagMap -> Gdx -> IPolicy -> Bool -> Set String -> Set String -> Set String -> Int -> Node

-- | The node name
name :: Node -> String

-- | The shortened name (for display purposes)
alias :: Node -> String

-- | Total memory (MiB)
tMem :: Node -> Double

-- | Node memory (MiB)
nMem :: Node -> Int

-- | Free memory (MiB)
fMem :: Node -> Int

-- | Free memory (MiB) including forthcoming instances
fMemForth :: Node -> Int

-- | Unaccounted memory (MiB)
xMem :: Node -> Int

-- | Total disk space (MiB)
tDsk :: Node -> Double

-- | Free disk space (MiB)
fDsk :: Node -> Int

-- | Free disk space (MiB) including forthcoming instances
fDskForth :: Node -> Int

-- | Total CPU count
tCpu :: Node -> Double

-- | Relative CPU speed
tCpuSpeed :: Node -> Double

-- | VCPUs used by the node OS
nCpu :: Node -> Int

-- | Used VCPU count
uCpu :: Node -> Int

-- | Used VCPU count including forthcoming instances
uCpuForth :: Node -> Int

-- | Node spindles (spindle_count node parameter, or actual spindles, see
--   note below)
tSpindles :: Node -> Int

-- | Free spindles (see note below)
fSpindles :: Node -> Int

-- | Free spindles (see note below) including forthcoming instances
fSpindlesForth :: Node -> Int

-- | List of primary instance indices
pList :: Node -> [Idx]

-- | List of primary instance indices including forthcoming instances
pListForth :: Node -> [Idx]

-- | List of secondary instance indices
sList :: Node -> [Idx]

-- | List of secondary instance indices including forthcoming instances
sListForth :: Node -> [Idx]

-- | Internal index for book-keeping
idx :: Node -> Ndx

-- | Pnode to instance mapping
peers :: Node -> PeerMap

-- | Whether the node has failed n1
failN1 :: Node -> Bool

-- | Whether the node has failed n1, including forthcoming instances
failN1Forth :: Node -> Bool

-- | Maximum memory needed for failover by primaries of this node
rMem :: Node -> Int

-- | Maximum memory needed for failover by primaries of this node,
--   including forthcoming instances
rMemForth :: Node -> Int

-- | Percent of free memory
pMem :: Node -> Double

-- | Percent of free memory including forthcoming instances
pMemForth :: Node -> Double

-- | Percent of free disk
pDsk :: Node -> Double

-- | Percent of free disk including forthcoming instances
pDskForth :: Node -> Double

-- | Percent of reserved memory
pRem :: Node -> Double

-- | Percent of reserved memory including forthcoming instances
pRemForth :: Node -> Double

-- | Ratio of virtual to physical CPUs
pCpu :: Node -> Double

-- | Ratio of virtual to physical CPUs including forthcoming instances
pCpuForth :: Node -> Double

-- | Minimum free disk ratio
mDsk :: Node -> Double

-- | Autocomputed from mDsk low disk threshold
loDsk :: Node -> Int

-- | Autocomputed from mCpu high cpu threshold
hiCpu :: Node -> Int

-- | Limit auto-computed from policy spindle_ratio and the node spindle
--   count (see note below)
hiSpindles :: Node -> Double

-- | Spindles used by instances (see note below)
instSpindles :: Node -> Double

-- | Spindles used by instances (see note below) including forthcoming
--   instances
instSpindlesForth :: Node -> Double

-- | Whether the node should not be used for allocations and skipped from
--   score computations
offline :: Node -> Bool

-- | Whether the node is the master node
isMaster :: Node -> Bool

-- | The node tags for this node
nTags :: Node -> [String]

-- | Total utilisation capacity
utilPool :: Node -> DynUtil

-- | Sum of instance utilisation
utilLoad :: Node -> DynUtil

-- | Sum of instance utilisation, including forthcoming instances
utilLoadForth :: Node -> DynUtil

-- | Primary instance exclusion tags and their count, including forthcoming
--   instances
pTags :: Node -> TagMap

-- | The node's group (index)
group :: Node -> Gdx

-- | The instance policy (of the node's group)
iPolicy :: Node -> IPolicy

-- | Effective value of exclusive_storage
exclStorage :: Node -> Bool

-- | migration-relevant tags
migTags :: Node -> Set String

-- | migration tags able to receive
rmigTags :: Node -> Set String

-- | common-failure domains the node belongs to
locationTags :: Node -> Set String
locationScore :: Node -> Int

-- | Derived parameter: ratio of virutal to physical CPUs, weighted by CPU
--   speed.
pCpuEff :: Node -> Double

-- | Derived parameter: ratio of virutal to physical CPUs, weighted by CPU
--   speed and taking forthcoming instances into account.
pCpuEffForth :: Node -> Double

-- | A simple name for the int, node association list.
type AssocList = [(Ndx, Node)]

-- | A simple name for a node map.
type List = Container Node

-- | A simple name for an allocation element (here just for logistic
--   reasons).
type AllocElement = (List, Instance, [Node], Score)

-- | Constant node index for a non-moveable instance.
noSecondary :: Ndx
addTag :: TagMap -> String -> TagMap

-- | Add multiple tags.
addTags :: TagMap -> [String] -> TagMap
delTag :: TagMap -> String -> TagMap

-- | Remove multiple tags.
delTags :: TagMap -> [String] -> TagMap

-- | Check if we can add a list of tags to a tagmap.
rejectAddTags :: TagMap -> [String] -> Bool

-- | Check how many primary instances have conflicting tags. The algorithm
--   to compute this is to sum the count of all tags, then subtract the
--   size of the tag map (since each tag has at least one, non-conflicting
--   instance); this is equivalent to summing the values in the tag map
--   minus one.
conflictingPrimaries :: Node -> Int
incIf :: Num a => Bool -> a -> a -> a
decIf :: Num a => Bool -> a -> a -> a

-- | Is exclusive storage enabled on any node?
haveExclStorage :: List -> Bool

-- | Create a new node.
--   
--   The index and the peers maps are empty, and will be need to be update
--   later via the <a>setIdx</a> and <a>buildPeers</a> functions.
create :: String -> Double -> Int -> Int -> Double -> Int -> Double -> Int -> Bool -> Int -> Int -> Gdx -> Bool -> Node
mDskToloDsk :: Double -> Double -> Int
mCpuTohiCpu :: Double -> Double -> Int
computeHiSpindles :: Double -> Int -> Double

-- | Changes the index.
--   
--   This is used only during the building of the data structures.
setIdx :: Node -> Ndx -> Node

-- | Changes the alias.
--   
--   This is used only during the building of the data structures.
setAlias :: Node -> String -> Node

-- | Sets the offline attribute.
setOffline :: Node -> Bool -> Node

-- | Sets the master attribute
setMaster :: Node -> Bool -> Node

-- | Sets the node tags attribute
setNodeTags :: Node -> [String] -> Node

-- | Set migration tags
setMigrationTags :: Node -> Set String -> Node

-- | Set the migration tags a node is able to receive
setRecvMigrationTags :: Node -> Set String -> Node

-- | Set the location tags
setLocationTags :: Node -> Set String -> Node

-- | Sets the unnaccounted memory.
setXmem :: Node -> Int -> Node

-- | Sets the max disk usage ratio.
setMdsk :: Node -> Double -> Node

-- | Sets the max cpu usage ratio. This will update the node's ipolicy,
--   losing sharing (but it should be a seldomly done operation).
setMcpu :: Node -> Double -> Node

-- | Sets the policy.
setPolicy :: IPolicy -> Node -> Node
computeMaxRes :: PeerMap -> Elem

-- | Builds the peer map for a given node.
buildPeers :: Node -> List -> Node
calcSpindleUse :: Bool -> Node -> Instance -> Double
calcSpindleUseForth :: Bool -> Node -> Instance -> Double
calcNewFreeSpindles :: Bool -> Node -> Instance -> Int
calcNewFreeSpindlesForth :: Bool -> Node -> Instance -> Int
calcFmemOfflineOrForthcoming :: Node -> Container Instance -> Int

-- | Assigns an instance to a node as primary and update the used VCPU
--   count, utilisation data and tags map.
setPri :: Node -> Instance -> Node

-- | Assigns an instance to a node as secondary and updates disk
--   utilisation.
setSec :: Node -> Instance -> Node
computePDsk :: Int -> Double -> Double
computeNewPDsk :: Node -> Int -> Int -> Double

-- | For a node diagnose whether it conforms with all policies. The type is
--   chosen to represent that of a no-op node operation.
getPolicyHealth :: Node -> OpResult ()

-- | Set the CPU speed
setCpuSpeed :: Node -> Double -> Node

-- | Removes a primary instance.
removePri :: Node -> Instance -> Node

-- | Removes a secondary instance.
removeSec :: Node -> Instance -> Node

-- | Adds a primary instance (basic version).
addPri :: Node -> Instance -> OpResult Node

-- | Adds a primary instance (extended version).
addPriEx :: Bool -> Node -> Instance -> OpResult Node

-- | Adds a secondary instance (basic version).
addSec :: Node -> Instance -> Ndx -> OpResult Node

-- | Adds a secondary instance (extended version).
addSecEx :: Bool -> Node -> Instance -> Ndx -> OpResult Node

-- | Adds a secondary instance (doubly extended version). The first
--   parameter tells <a>addSecExEx</a> to ignore disks completly. There is
--   only one legitimate use case for this, and this is failing over a DRBD
--   instance where the primary node is offline (and hence will become the
--   secondary afterwards).
addSecExEx :: Bool -> Bool -> Node -> Instance -> Ndx -> OpResult Node

-- | Predicate on whether migration is supported between two nodes.
checkMigration :: Node -> Node -> OpResult ()

-- | Computes the amount of available disk on a given node.
availDisk :: Node -> Int

-- | Computes the amount of used disk on a given node.
iDsk :: Node -> Int

-- | Computes the amount of available memory on a given node.
availMem :: Node -> Int

-- | Computes the amount of available memory on a given node.
availCpu :: Node -> Int

-- | The memory used by instances on a given node.
iMem :: Node -> Int
instanceToEdges :: Instance -> [Edge]
instancesToEdges :: List -> [Edge]
nodesToBounds :: List -> Maybe Bounds
nodeToSharedSecondaryEdge :: List -> Node -> [Edge]
filterValid :: List -> [Edge] -> [Edge]

-- | Transform a Node + Instance list into a NodeGraph type. Returns
--   Nothing if the node list is empty.
mkNodeGraph :: List -> List -> Maybe Graph

-- | Transform a Nodes + Instances into a NodeGraph with all reboot
--   exclusions. This includes edges between nodes that are the primary
--   nodes of instances that have the same secondary node. Nodes not in the
--   node list will not be part of the graph, but they are still considered
--   for the edges arising from two instances having the same secondary
--   node. Return Nothing if the node list is empty.
mkRebootNodeGraph :: List -> List -> List -> Maybe Graph

-- | Return a field for a given node.
showField :: Node -> String -> String

-- | Returns the header and numeric propery of a field.
showHeader :: String -> (String, Bool)

-- | String converter for the node list functionality.
list :: [String] -> Node -> [String]
genOpSetOffline :: Monad m => Node -> Bool -> m OpCode
genOobCommand :: Monad m => [Node] -> OobCommand -> m OpCode

-- | Generate OpCode for powering on a list of nodes
genPowerOnOpCodes :: Monad m => [Node] -> m [OpCode]

-- | Generate OpCodes for powering off a list of nodes
genPowerOffOpCodes :: Monad m => [Node] -> m [OpCode]

-- | Generate OpCodes for adding tags to a node
genAddTagsOpCode :: Node -> [String] -> OpCode

-- | Constant holding the fields we're displaying by default.
defaultFields :: [String]

-- | Split a list of nodes into a list of (node group UUID, list of
--   associated nodes).
computeGroups :: [Node] -> [(Gdx, [Node])]
instance Show Node
instance Eq Node
instance Element Node


-- | Implementation of command-line functions.
--   
--   This module holds the common command-line related functions for the
--   binaries, separated into this module since <a>Ganeti.Utils</a> is used
--   in many other places and this is more IO oriented.
module Ganeti.HTools.CLI

-- | Command line options structure.
data Options
Options :: Maybe FilePath -> Bool -> Bool -> Maybe DiskTemplate -> Maybe Int -> Maybe FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe FilePath -> Bool -> Bool -> [String] -> Maybe [String] -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe FilePath -> Bool -> [String] -> Maybe FilePath -> Double -> Bool -> String -> Int -> Maybe Double -> Double -> Score -> Score -> Double -> Score -> Bool -> Bool -> [String] -> Maybe [String] -> [String] -> Bool -> Bool -> FilePath -> Bool -> Maybe FilePath -> Maybe FilePath -> Bool -> Bool -> Bool -> Maybe [String] -> Bool -> Bool -> Maybe RSpec -> Double -> Maybe Int -> Maybe RSpec -> Maybe String -> Int -> Maybe OpSubmitPriority -> Options

-- | Path to the cluster data file
optDataFile :: Options -> Maybe FilePath

-- | Allow disk moves
optDiskMoves :: Options -> Bool

-- | Allow instance moves
optInstMoves :: Options -> Bool

-- | Override for the disk template
optDiskTemplate :: Options -> Maybe DiskTemplate

-- | Override for the spindle usage
optSpindleUse :: Options -> Maybe Int

-- | Optional file with dynamic use data
optDynuFile :: Options -> Maybe FilePath

-- | Do not use dynamic use data
optIgnoreDynu :: Options -> Bool

-- | Ignore soft errors in balancing moves
optIgnoreSoftErrors :: Options -> Bool

-- | consider groups independently
optIndependentGroups :: Options -> Bool

-- | accept existing N+1 violations
optAcceptExisting :: Options -> Bool

-- | Query MonDs
optMonD :: Options -> Bool

-- | Optional file with data provided by MonDs
optMonDFile :: Options -> Maybe FilePath

-- | Enable evacuation mode
optEvacMode :: Options -> Bool

-- | Disallow replace-primary moves
optRestrictedMigrate :: Options -> Bool

-- | Instances to be excluded
optExInst :: Options -> [String]

-- | Tags to use for exclusion
optExTags :: Options -> Maybe [String]

-- | Execute the commands via Luxi
optExecJobs :: Options -> Bool

-- | Force the execution
optForce :: Options -> Bool

-- | Fully evacuate nodes to be rebooted
optFullEvacuation :: Options -> Bool

-- | The UUID of the group to process
optGroup :: Options -> Maybe GroupID

-- | The iallocation spec
optIAllocSrc :: Options -> Maybe FilePath

-- | Ignore non-redundant instances
optIgnoreNonRedundant :: Options -> Bool

-- | Instances to be excluded
optSelInst :: Options -> [String]

-- | Collect data from Luxi
optLuxi :: Options -> Maybe FilePath

-- | Delay before executing first job
optJobDelay :: Options -> Double

-- | Output machine-readable format
optMachineReadable :: Options -> Bool

-- | Collect data from RAPI
optMaster :: Options -> String

-- | Stop after this many steps
optMaxLength :: Options -> Int

-- | Override max cpu ratio for nodes
optMcpu :: Options -> Maybe Double

-- | Max disk usage ratio for nodes
optMdsk :: Options -> Double

-- | Min gain we aim for in a step
optMinGain :: Options -> Score

-- | Limit below which we apply mingain
optMinGainLim :: Options -> Score

-- | Minimal resources for hsqueeze
optMinResources :: Options -> Double

-- | The minimum score we aim for
optMinScore :: Options -> Score

-- | Do not show a header line
optNoHeaders :: Options -> Bool

-- | Skip the rebalancing dry-run
optNoSimulation :: Options -> Bool

-- | Cluster simulation mode
optNodeSim :: Options -> [String]

-- | List of node tags to restrict to
optNodeTags :: Options -> Maybe [String]

-- | Names of offline nodes
optOffline :: Options -> [String]

-- | Pretend all instances are offline
optOfflineMaintenance :: Options -> Bool

-- | Only do the first step
optOneStepOnly :: Options -> Bool

-- | Path to the output directory
optOutPath :: Options -> FilePath

-- | Whether to show the instance moves
optPrintMoves :: Options -> Bool

-- | Save cluster state to this file
optSaveCluster :: Options -> Maybe FilePath

-- | Whether to show the command list
optShowCmds :: Options -> Maybe FilePath

-- | Just show the help
optShowHelp :: Options -> Bool

-- | Just show the completion info
optShowComp :: Options -> Bool

-- | Whether to show the instance map
optShowInsts :: Options -> Bool

-- | Whether to show node status
optShowNodes :: Options -> Maybe [String]

-- | Just show the program version
optShowVer :: Options -> Bool

-- | Skip nodes with non-redundant instance
optSkipNonRedundant :: Options -> Bool

-- | Requested standard specs
optStdSpec :: Options -> Maybe RSpec

-- | Target resources for squeezing
optTargetResources :: Options -> Double

-- | Optional test count override
optTestCount :: Options -> Maybe Int

-- | Requested specs for tiered mode
optTieredSpec :: Options -> Maybe RSpec

-- | Unittests: RNG state
optReplay :: Options -> Maybe String

-- | Verbosity level
optVerbose :: Options -> Int

-- | OpCode submit priority
optPriority :: Options -> Maybe OpSubmitPriority

-- | Default values for the command line options.
defaultOptions :: Options

-- | Abbreviation for the option type.
type OptType = GenericOptType Options
parseISpecString :: String -> String -> Result RSpec
optComplDiskTemplate :: OptCompletion
oDataFile :: OptType
oDiskMoves :: OptType
oMonD :: OptType
oMonDDataFile :: OptType
oDiskTemplate :: OptType
oSpindleUse :: OptType
oSelInst :: OptType
oInstMoves :: OptType
oDynuFile :: OptType
oIgnoreDyn :: OptType
oIgnoreSoftErrors :: OptType
oIndependentGroups :: OptType
oAcceptExisting :: OptType
oEvacMode :: OptType
oRestrictedMigrate :: OptType
oExInst :: OptType
oExTags :: OptType
oExecJobs :: OptType
oForce :: OptType
oFullEvacuation :: OptType
oGroup :: OptType
oIAllocSrc :: OptType
oIgnoreNonRedundant :: OptType
oJobDelay :: OptType
genOLuxiSocket :: String -> OptType
oLuxiSocket :: IO OptType
oMachineReadable :: OptType
oMaxCpu :: OptType
oMaxSolLength :: OptType
oMinDisk :: OptType
oMinGain :: OptType
oMinGainLim :: OptType
oMinResources :: OptType
oMinScore :: OptType
oNoHeaders :: OptType
oNoSimulation :: OptType
oNodeSim :: OptType
oNodeTags :: OptType
oOfflineMaintenance :: OptType
oOfflineNode :: OptType
oOneStepOnly :: OptType
oOutputDir :: OptType
oPrintCommands :: OptType
oPrintInsts :: OptType
oPrintMoves :: OptType
oPrintNodes :: OptType
oQuiet :: OptType
oRapiMaster :: OptType
oSaveCluster :: OptType
oSkipNonRedundant :: OptType
oStdSpec :: OptType
oTargetResources :: OptType
oTieredSpec :: OptType
oVerbose :: OptType
oPriority :: OptType

-- | Generic options.
genericOpts :: [GenericOptType Options]

-- | Wrapper over <a>parseOpts</a> with our custom options.
parseOpts :: [String] -> String -> [OptType] -> [ArgCompletion] -> IO (Options, [String])

-- | A shell script template for autogenerated scripts.
shTemplate :: String

-- | Optionally show or save a list of commands
maybeSaveCommands :: String -> Options -> String -> IO ()

-- | Optionally print the node list.
maybePrintNodes :: Maybe [String] -> String -> ([String] -> String) -> IO ()

-- | Optionally print the instance list.
maybePrintInsts :: Bool -> String -> String -> IO ()

-- | Function to display warning messages from parsing the cluster state.
maybeShowWarnings :: [String] -> IO ()

-- | Format a list of key, value as a shell fragment.
printKeys :: String -> [(String, String)] -> IO ()

-- | Prints the final <tt>OK</tt> marker in machine readable output.
printFinal :: String -> Bool -> IO ()
setNodeOffline :: [Ndx] -> Node -> Node

-- | Set node properties based on command line options.
setNodeStatus :: Options -> List -> IO List
instance Show Options
instance StandardOptions Options


-- | Algorithm Options for HTools
--   
--   This module describes the parameters that influence the balancing
--   algorithm in htools.
module Ganeti.HTools.AlgorithmParams
data AlgorithmOptions
AlgorithmOptions :: Bool -> Bool -> Bool -> Bool -> Bool -> Double -> Double -> AlgorithmOptions

-- | Whether disk moves are allowed
algDiskMoves :: AlgorithmOptions -> Bool

-- | Whether instance moves are allowed
algInstanceMoves :: AlgorithmOptions -> Bool

-- | Whether migration is restricted
algRestrictedMigration :: AlgorithmOptions -> Bool

-- | Whether to always ignore soft errors
algIgnoreSoftErrors :: AlgorithmOptions -> Bool

-- | Consider only eavacation moves
algEvacMode :: AlgorithmOptions -> Bool

-- | Minimal gain per balancing step
algMinGain :: AlgorithmOptions -> Double

-- | Limit below which minimal gain is used
algMinGainLimit :: AlgorithmOptions -> Double

-- | Obtain the relevant algorithmic option from the commandline options
fromCLIOptions :: Options -> AlgorithmOptions

-- | Default options for the balancing algorithm
defaultOptions :: AlgorithmOptions


-- | Implementation of cluster-wide logic.
--   
--   This module holds all pure cluster-logic; I/O related functionality
--   goes into the <i>Main</i> module for the individual binaries.
module Ganeti.HTools.Cluster

-- | Allocation details for an instance, specifying required number of
--   nodes, and an optional group (name) to allocate to
data AllocDetails
AllocDetails :: Int -> (Maybe String) -> AllocDetails

-- | Allocation/relocation solution.
data AllocSolution
AllocSolution :: [FailMode] -> Int -> Maybe AllocElement -> [String] -> AllocSolution

-- | Failure counts
asFailures :: AllocSolution -> [FailMode]

-- | Good allocation count
asAllocs :: AllocSolution -> Int

-- | The actual allocation result
asSolution :: AllocSolution -> Maybe AllocElement

-- | Informational messages
asLog :: AllocSolution -> [String]

-- | Node evacuation/group change iallocator result type. This result type
--   consists of actual opcodes (a restricted subset) that are transmitted
--   back to Ganeti.
data EvacSolution
EvacSolution :: [(Idx, Gdx, [Ndx])] -> [(Idx, String)] -> [[OpCode]] -> EvacSolution

-- | Instances moved successfully
esMoved :: EvacSolution -> [(Idx, Gdx, [Ndx])]

-- | Instances which were not relocated
esFailed :: EvacSolution -> [(Idx, String)]

-- | List of jobs
esOpCodes :: EvacSolution -> [[OpCode]]

-- | Allocation results, as used in <a>iterateAlloc</a> and
--   <a>tieredAlloc</a>.
type AllocResult = (FailStats, List, List, [Instance], [CStats])

-- | Type alias for easier handling.
type AllocSolutionList = [(Instance, AllocSolution)]

-- | A type denoting the valid allocation mode/pairs.
--   
--   For a one-node allocation, this will be a <tt>Left [<a>Ndx</a>]</tt>,
--   whereas for a two-node allocation, this will be a <tt>Right
--   [(<a>Ndx</a>, [<a>Ndx</a>])]</tt>. In the latter case, the list is
--   basically an association list, grouped by primary node and holding the
--   potential secondary nodes in the sub-list.
type AllocNodes = Either [Ndx] [(Ndx, [Ndx])]
emptyAllocSolution :: AllocSolution
emptyEvacSolution :: EvacSolution

-- | The complete state for the balancing solution.
data Table
Table :: List -> List -> Score -> [Placement] -> Table

-- | Cluster statistics data type.
data CStats
CStats :: Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Double -> Double -> Double -> Double -> Integer -> Double -> Integer -> Integer -> Score -> Int -> CStats

-- | Cluster free mem
csFmem :: CStats -> Integer

-- | Cluster free disk
csFdsk :: CStats -> Integer

-- | Cluster free spindles
csFspn :: CStats -> Integer

-- | Cluster allocatable mem
csAmem :: CStats -> Integer

-- | Cluster allocatable disk
csAdsk :: CStats -> Integer

-- | Cluster allocatable cpus
csAcpu :: CStats -> Integer

-- | Max node allocatable mem
csMmem :: CStats -> Integer

-- | Max node allocatable disk
csMdsk :: CStats -> Integer

-- | Max node allocatable cpu
csMcpu :: CStats -> Integer

-- | Instance used mem
csImem :: CStats -> Integer

-- | Instance used disk
csIdsk :: CStats -> Integer

-- | Instance used spindles
csIspn :: CStats -> Integer

-- | Instance used cpu
csIcpu :: CStats -> Integer

-- | Cluster total mem
csTmem :: CStats -> Double

-- | Cluster total disk
csTdsk :: CStats -> Double

-- | Cluster total spindles
csTspn :: CStats -> Double

-- | Cluster total cpus
csTcpu :: CStats -> Double

-- | Cluster total virtual cpus
csVcpu :: CStats -> Integer

-- | Equivalent to <a>csIcpu</a> but in terms of physical CPUs, i.e.
--   normalised used phys CPUs
csNcpu :: CStats -> Double

-- | Unnacounted for mem
csXmem :: CStats -> Integer

-- | Node own memory
csNmem :: CStats -> Integer

-- | The cluster score
csScore :: CStats -> Score

-- | The total number of instances
csNinst :: CStats -> Int

-- | A simple type for allocation functions.
type AllocMethod = List -> List -> Maybe Int -> Instance -> AllocNodes -> [Instance] -> [CStats] -> Result AllocResult
type EvacInnerState = Either String (List, Instance, Score, Ndx)
verifyN1 :: [Node] -> [Node]

-- | Computes the pair of bad nodes and instances.
--   
--   The bad node list is computed via a simple <a>verifyN1</a> check, and
--   the bad instance list is the list of primary and secondary instances
--   of those nodes.
computeBadItems :: List -> List -> ([Node], [Instance])
instanceNodes :: List -> Instance -> (Ndx, Ndx, Node, Node)
emptyCStats :: CStats
updateCStats :: CStats -> Node -> CStats

-- | Compute the total free disk and memory in the cluster.
totalResources :: List -> CStats

-- | Compute the delta between two cluster state.
--   
--   This is used when doing allocations, to understand better the
--   available cluster resources. The return value is a triple of the
--   current used values, the delta that was still allocated, and what was
--   left unallocated.
computeAllocationDelta :: CStats -> CStats -> AllocStats
detailedCVInfoExt :: [((Double, String), ([Double] -> Statistics, Bool))]
detailedCVInfo :: [(Double, String)]
detailedCVWeights :: [Double]
detailedCVAggregation :: [([Double] -> Statistics, Bool)]
detailedCVOnlineStatus :: [Bool]
compDetailedCVNode :: Node -> [Double]
compClusterStatistics :: [Node] -> [Statistics]
updateClusterStatistics :: [Statistics] -> (Node, Node) -> [Statistics]
updateClusterStatisticsTwice :: [Statistics] -> (Node, Node) -> (Node, Node) -> [Statistics]

-- | Compute cluster statistics
compDetailedCV :: [Node] -> [Double]
compCVfromStats :: [Statistics] -> Double

-- | Compute the <i>total</i> variance.
compCVNodes :: [Node] -> Double

-- | Wrapper over <a>compCVNodes</a> for callers that have a <a>List</a>.
compCV :: List -> Double
getOnline :: List -> [Node]

-- | Sets the location score of an instance, given its primary and
--   secondary node.
setInstanceLocationScore :: Instance -> Node -> Node -> Instance
compareTables :: Table -> Table -> Table
applyMoveEx :: Bool -> List -> Instance -> IMove -> OpResult (List, Instance, Ndx, Ndx)
allocateOnSingle :: AlgorithmOptions -> List -> Instance -> Ndx -> OpResult AllocElement
allocateOnPair :: AlgorithmOptions -> [Statistics] -> List -> Instance -> Ndx -> Ndx -> OpResult AllocElement
checkSingleStep :: Bool -> Table -> Instance -> Table -> IMove -> Table
possibleMoves :: MirrorType -> Bool -> Bool -> Bool -> (Bool, Bool) -> Ndx -> [IMove]
checkInstanceMove :: AlgorithmOptions -> [Ndx] -> Table -> Instance -> Table
checkMove :: AlgorithmOptions -> [Ndx] -> Table -> [Instance] -> Table

-- | Check if we are allowed to go deeper in the balancing.
doNextBalance :: Table -> Int -> Score -> Bool

-- | Run a balance move.
tryBalance :: AlgorithmOptions -> Table -> Maybe Table

-- | Build failure stats out of a list of failures.
collapseFailures :: [FailMode] -> FailStats
bestAllocElement :: Maybe AllocElement -> Maybe AllocElement -> Maybe AllocElement
concatAllocs :: AllocSolution -> OpResult AllocElement -> AllocSolution
sumAllocs :: AllocSolution -> AllocSolution -> AllocSolution
describeSolution :: AllocSolution -> String
annotateSolution :: AllocSolution -> AllocSolution
reverseEvacSolution :: EvacSolution -> EvacSolution

-- | Generate the valid node allocation singles or pairs for a new
--   instance.
genAllocNodes :: List -> List -> Int -> Bool -> Result AllocNodes

-- | Try to allocate an instance on the cluster.
tryAlloc :: Monad m => AlgorithmOptions -> List -> List -> Instance -> AllocNodes -> m AllocSolution
solutionDescription :: (Group, Result AllocSolution) -> [String]
filterMGResults :: [(Group, Result AllocSolution)] -> [(Group, AllocSolution)]
sortMGResults :: [(Group, AllocSolution)] -> [(Group, AllocSolution)]
hasRequiredNetworks :: Group -> Instance -> Bool
filterValidGroups :: [(Group, (List, List))] -> Instance -> ([(Group, (List, List))], [String])
findAllocation :: AlgorithmOptions -> List -> List -> List -> Gdx -> Instance -> Int -> Result (AllocSolution, [String])
findBestAllocGroup :: AlgorithmOptions -> List -> List -> List -> Maybe [Gdx] -> Instance -> Int -> Result (Group, AllocSolution, [String])

-- | Try to allocate an instance on a multi-group cluster.
tryMGAlloc :: AlgorithmOptions -> List -> List -> List -> Instance -> Int -> Result AllocSolution

-- | Try to allocate an instance to a group.
tryGroupAlloc :: AlgorithmOptions -> List -> List -> List -> String -> Instance -> Int -> Result AllocSolution
updateIl :: List -> Maybe AllocElement -> List
extractNl :: List -> Maybe AllocElement -> List

-- | Try to allocate a list of instances on a multi-group cluster.
allocList :: AlgorithmOptions -> List -> List -> List -> [(Instance, AllocDetails)] -> AllocSolutionList -> Result (List, List, AllocSolutionList)
failOnSecondaryChange :: Monad m => EvacMode -> DiskTemplate -> m ()
nodeEvacInstance :: AlgorithmOptions -> List -> List -> EvacMode -> Instance -> Gdx -> [Ndx] -> Result (List, List, [OpCode])
evacOneNodeOnly :: AlgorithmOptions -> List -> List -> Instance -> Gdx -> [Ndx] -> Result (List, List, [OpCode])
evacOneNodeInner :: AlgorithmOptions -> List -> Instance -> Gdx -> (Ndx -> IMove) -> EvacInnerState -> Ndx -> EvacInnerState
evacDrbdAllInner :: AlgorithmOptions -> List -> List -> Instance -> Gdx -> (Ndx, Ndx) -> Result (List, List, [OpCode], Score)
availableGroupNodes :: [(Gdx, [Ndx])] -> IntSet -> Gdx -> Result [Ndx]
updateEvacSolution :: (List, List, EvacSolution) -> Idx -> Result (List, List, [OpCode]) -> (List, List, EvacSolution)

-- | Node-evacuation IAllocator mode main function.
tryNodeEvac :: AlgorithmOptions -> List -> List -> List -> EvacMode -> [Idx] -> Result (List, List, EvacSolution)

-- | Change-group IAllocator mode main function.
--   
--   This is very similar to <a>tryNodeEvac</a>, the only difference is
--   that we don't choose as target group the current instance group, but
--   instead:
--   
--   <ol>
--   <li>at the start of the function, we compute which are the target
--   groups; either no groups were passed in, in which case we choose all
--   groups out of which we don't evacuate instance, or there were some
--   groups passed, in which case we use those</li>
--   <li>for each instance, we use <a>findBestAllocGroup</a> to choose the
--   best group to hold the instance, and then we do what
--   <a>tryNodeEvac</a> does, except for this group instead of the current
--   instance group.</li>
--   </ol>
--   
--   Note that the correct behaviour of this function relies on the
--   function <a>nodeEvacInstance</a> to be able to do correctly both
--   intra-group and inter-group moves when passed the <a>ChangeAll</a>
--   mode.
tryChangeGroup :: AlgorithmOptions -> List -> List -> List -> [Gdx] -> [Idx] -> Result (List, List, EvacSolution)

-- | Standard-sized allocation method.
--   
--   This places instances of the same size on the cluster until we're out
--   of space. The result will be a list of identically-sized instances.
iterateAlloc :: AlgorithmOptions -> AllocMethod
sufficesShrinking :: (Instance -> AllocSolution) -> Instance -> FailMode -> Maybe Instance

-- | Tiered allocation method.
--   
--   This places instances on the cluster, and decreases the spec until we
--   can allocate again. The result will be a list of decreasing instance
--   specs.
tieredAlloc :: AlgorithmOptions -> AllocMethod
computeMoves :: Instance -> String -> IMove -> String -> String -> (String, [String])

-- | Converts a placement to string format.
printSolutionLine :: List -> List -> Int -> Int -> Placement -> Int -> (String, [String])

-- | Return the instance and involved nodes in an instance move.
--   
--   Note that the output list length can vary, and is not required nor
--   guaranteed to be of any specific length.
involvedNodes :: List -> Placement -> [Ndx]

-- | From two adjacent cluster tables get the list of moves that
--   transitions from to the other
getMoves :: (Table, Table) -> [MoveJob]
mergeJobs :: ([JobSet], [Ndx]) -> MoveJob -> ([JobSet], [Ndx])

-- | Break a list of moves into independent groups. Note that this will
--   reverse the order of jobs.
splitJobs :: [MoveJob] -> [JobSet]
formatJob :: Int -> Int -> (Int, MoveJob) -> [String]

-- | Given a list of commands, prefix them with <tt>gnt-instance</tt> and
--   also beautify the display a little.
formatCmds :: [JobSet] -> String

-- | Print the node list.
printNodes :: List -> [String] -> String

-- | Print the instance list.
printInsts :: List -> List -> String

-- | Shows statistics for a given node list.
printStats :: String -> List -> String

-- | Convert a placement into a list of OpCodes (basically a job).
iMoveToJob :: List -> List -> Idx -> IMove -> [OpCode]

-- | Computes the group of an instance.
instanceGroup :: List -> Instance -> Result Gdx
instancePriGroup :: List -> Instance -> Gdx

-- | Compute the list of badly allocated instances (split across node
--   groups).
findSplitInstances :: List -> List -> [Instance]

-- | Splits a cluster into the component node groups.
splitCluster :: List -> List -> [(Gdx, (List, List))]
nodesToEvacuate :: List -> EvacMode -> [Idx] -> IntSet
instance Show AllocDetails
instance Show EvacSolution
instance Show Table
instance Show CStats


-- | Tags
--   
--   This module holds all the tag interpretation done by htools.
module Ganeti.HTools.Tags

-- | The exclusion tag prefix. Instance tags starting with this prefix
--   describe a service provided by the instance. Instances providing the
--   same service at not places on the same node.
exTagsPrefix :: String
standbyPrefix :: String
migrationPrefix :: String
allowMigrationPrefix :: String
locationPrefix :: String

-- | The tag to be added to nodes that were shutdown by hsqueeze.
standbyAuto :: String

-- | Auto-repair tag prefix
autoRepairTagPrefix :: String
autoRepairTagEnabled :: String
autoRepairTagPending :: String
autoRepairTagResult :: String
autoRepairTagSuspended :: String

-- | Predicate of having a standby tag.
hasStandbyTag :: Node -> Bool
getTags :: String -> [String] -> [String] -> Set String

-- | Given the cluster tags extract the migration restrictions from a node
--   tag.
getMigRestrictions :: [String] -> [String] -> Set String
splitAtColons :: String -> Maybe (String, String)
migrations :: [String] -> [(String, String)]

-- | Given the cluster tags, extract the set of migration restrictions a
--   node is able to receive from its node tags.
getRecvMigRestrictions :: [String] -> [String] -> Set String

-- | Given the cluster tags, extract the node location tags from the node
--   tags.
getLocations :: [String] -> [String] -> Set String


-- | Generic data loader.
--   
--   This module holds the common code for parsing the input data after it
--   has been loaded from external sources.
module Ganeti.HTools.Loader

-- | The iallocator request type.
--   
--   This type denotes what request we got from Ganeti and also holds
--   request-specific fields.
data RqType

-- | A new instance allocation
Allocate :: Instance -> AllocDetails -> RqType

-- | Choose a new secondary node
Relocate :: Idx -> Int -> [Ndx] -> RqType

-- | node-evacuate mode
NodeEvacuate :: [Idx] -> EvacMode -> RqType

-- | Multi-relocate mode
ChangeGroup :: [Gdx] -> [Idx] -> RqType

-- | Multi-allocate mode
MultiAllocate :: [(Instance, AllocDetails)] -> RqType

-- | A complete request, as received from Ganeti.
data Request
Request :: RqType -> ClusterData -> Request

-- | The cluster state.
data ClusterData
ClusterData :: List -> List -> List -> [String] -> IPolicy -> ClusterData

-- | The node group list
cdGroups :: ClusterData -> List

-- | The node list
cdNodes :: ClusterData -> List

-- | The instance list
cdInstances :: ClusterData -> List

-- | The cluster tags
cdTags :: ClusterData -> [String]

-- | The cluster instance policy
cdIPolicy :: ClusterData -> IPolicy

-- | An empty cluster.
emptyCluster :: ClusterData

-- | Lookups a node into an assoc list.
lookupNode :: Monad m => NameAssoc -> String -> String -> m Ndx

-- | Lookups an instance into an assoc list.
lookupInstance :: Monad m => NameAssoc -> String -> m Idx

-- | Lookups a group into an assoc list.
lookupGroup :: Monad m => NameAssoc -> String -> String -> m Gdx

-- | Given a list of elements (and their names), assign indices to them.
assignIndices :: Element a => [(String, a)] -> (NameAssoc, Container a)

-- | Given am indexed node list, and the name of the master, mark it as
--   such.
setMaster :: Monad m => NameAssoc -> List -> String -> m List
setLocationScore :: List -> Instance -> Instance
fixNodes :: List -> Instance -> List
setNodePolicy :: List -> Node -> Node

-- | Update instance with exclusion tags list.
updateExclTags :: [String] -> Instance -> Instance
updateMovable :: [String] -> [String] -> Instance -> Instance
disableSplitMoves :: List -> Instance -> Instance
setArPolicy :: [String] -> List -> List -> List -> ClockTime -> List
getArPolicy :: [String] -> ClockTime -> Maybe AutoRepairPolicy
longestDomain :: [String] -> String

-- | Extracts the exclusion tags from the cluster configuration.
extractExTags :: [String] -> [String]

-- | Extracts the common suffix from node/instance names.
commonSuffix :: List -> List -> String
addMigrationTags :: [String] -> Node -> Node
addLocationTags :: [String] -> Node -> Node

-- | Initializer function that loads the data from a node and instance list
--   and massages it into the correct format.
mergeData :: [(String, DynUtil)] -> [String] -> [String] -> [String] -> ClockTime -> ClusterData -> Result ClusterData

-- | In a cluster description, clear dynamic utilisation information.
clearDynU :: ClusterData -> Result ClusterData

-- | Checks the cluster data for consistency.
checkData :: List -> List -> ([String], List)
nodeImem :: Node -> List -> Int
nodeIdsk :: Node -> List -> Int

-- | Get live information or a default value
eitherLive :: Monad m => Bool -> a -> m a -> m a
instance Show RqType
instance Show ClusterData
instance Eq ClusterData
instance Show Request


-- | Implementation of the iallocator interface.
module Ganeti.HTools.Backend.IAlloc
type IAllocResult = (String, JSValue, List, List)
parseNic :: String -> JSRecord -> Result Nic
parseBaseInstance :: String -> JSRecord -> Result (String, Instance)
parseInstance :: NameAssoc -> String -> JSRecord -> Result (String, Instance)
parseNode :: NameAssoc -> String -> JSRecord -> Result (String, Node)
parseGroup :: String -> JSRecord -> Result (String, Group)
parseData :: ClockTime -> String -> Result ([String], Request)
formatResponse :: Bool -> String -> JSValue -> String
describeSolution :: AllocSolution -> String
formatAllocate :: List -> AllocSolution -> Result IAllocResult
formatMultiAlloc :: (List, List, AllocSolutionList) -> Result IAllocResult
formatNodeEvac :: List -> List -> List -> (List, List, EvacSolution) -> Result IAllocResult

-- | Runs relocate for a single instance.
--   
--   This is wrapper over the <a>tryNodeEvac</a> function that is run with
--   a single instance (ours), and further it checks that the result it got
--   (in the nodes field) is actually consistent, as tryNodeEvac is
--   designed to output primarily an opcode list, not a node list.
processRelocate :: AlgorithmOptions -> List -> List -> List -> Idx -> Int -> [Ndx] -> Result (List, List, [Ndx])
formatRelocate :: (List, List, [Ndx]) -> Result IAllocResult
processRequest :: AlgorithmOptions -> Request -> Result IAllocResult

-- | Reads the request from the data file(s).
readRequest :: FilePath -> IO Request

-- | Main iallocator pipeline.
runIAllocator :: AlgorithmOptions -> Request -> (Maybe (List, List), String)

-- | Load the data from an iallocation request file
loadData :: FilePath -> IO (Result ClusterData)


-- | Implementation of the RAPI client interface.
module Ganeti.HTools.Backend.Rapi
filePrefix :: String
getUrl :: Monad m => String -> IO (m String)
connTimeout :: Long
queryTimeout :: Long
curlOpts :: [CurlOption]
ioErrToResult :: IO a -> IO (Result a)
formatHost :: String -> String
getInstances :: NameAssoc -> String -> Result [(String, Instance)]
getNodes :: NameAssoc -> String -> Result [(String, Node)]
getGroups :: String -> Result [(String, Group)]
parseInstance :: NameAssoc -> JSRecord -> Result (String, Instance)
parseNode :: NameAssoc -> JSRecord -> Result (String, Node)
parseGroup :: JSRecord -> Result (String, Group)
parseCluster :: JSObject JSValue -> Result ([String], IPolicy, String)
readDataHttp :: String -> IO (Result String, Result String, Result String, Result String)
readDataFile :: String -> IO (Result String, Result String, Result String, Result String)
readData :: String -> IO (Result String, Result String, Result String, Result String)

-- | Builds the cluster data from the raw Rapi content.
parseData :: (Result String, Result String, Result String, Result String) -> Result ClusterData

-- | Top level function for data loading.
loadData :: String -> IO (Result ClusterData)


-- | Parsing data from a simulated description of the cluster.
--   
--   This module holds the code for parsing a cluster description.
module Ganeti.HTools.Backend.Simu
apolAbbrev :: String -> Result AllocPolicy
parseDesc :: String -> [String] -> Result (AllocPolicy, Int, Int, Int, Int, Int, Bool)
createGroup :: Int -> String -> Result (Group, [Node])

-- | Builds the cluster data from node/instance files.
parseData :: [String] -> Result ClusterData

-- | Builds the cluster data from node/instance files.
loadData :: [String] -> IO (Result ClusterData)


-- | Parsing data from text-files.
--   
--   This module holds the code for loading the cluster state from text
--   files, as produced by <tt>gnt-node</tt> and <tt>gnt-instance</tt>
--   <tt>list</tt> command.
module Ganeti.HTools.Backend.Text
commaSplit :: String -> [String]

-- | Serialize a single group.
serializeGroup :: Group -> String
serializeGroups :: List -> String

-- | Serialize a single node.
serializeNode :: List -> Node -> String

-- | Generate node file data from node objects.
serializeNodes :: List -> List -> String

-- | Serialize a single instance.
serializeInstance :: List -> Instance -> String

-- | Generate instance file data from instance objects.
serializeInstances :: List -> List -> String
iSpecsSeparator :: Char

-- | Generate a spec data from a given ISpec object.
serializeISpec :: ISpec -> String
serializeDiskTemplates :: [DiskTemplate] -> String

-- | Generate min/max instance specs data.
serializeMultipleMinMaxISpecs :: [MinMaxISpecs] -> String

-- | Generate policy data from a given policy object.
serializeIPolicy :: String -> IPolicy -> String
serializeAllIPolicies :: IPolicy -> List -> String

-- | Generate complete cluster data from node and instance lists.
serializeCluster :: ClusterData -> String
loadGroup :: Monad m => [String] -> m (String, Group)

-- | Load a node from a field list.
loadNode :: Monad m => NameAssoc -> [String] -> m (String, Node)

-- | Load an instance from a field list.
loadInst :: NameAssoc -> [String] -> Result (String, Instance)

-- | Loads a spec from a field list.
loadISpec :: String -> [String] -> Result ISpec
loadMinMaxISpecs :: String -> String -> String -> Result MinMaxISpecs
breakISpecsPairs :: String -> [String] -> Result [(String, String)]

-- | Load a list of min/max ispecs pairs
loadMultipleMinMaxISpecs :: String -> [String] -> Result [MinMaxISpecs]

-- | Loads an ipolicy from a field list.
loadIPolicy :: [String] -> Result (String, IPolicy)
loadOnePolicy :: (IPolicy, List) -> String -> Result (IPolicy, List)
loadAllIPolicies :: List -> [String] -> Result (IPolicy, List)
loadTabular :: (Monad m, Element a) => [String] -> ([String] -> m (String, a)) -> m (NameAssoc, Container a)
readData :: String -> IO String

-- | Builds the cluster data from text input.
parseData :: String -> Result ClusterData

-- | Top level function for data loading.
loadData :: String -> IO (Result ClusterData)


-- | Lenses for OpCodes
module Ganeti.OpCodes.Lens
metaParamsL :: Lens' MetaOpCode CommonOpParams
metaOpCodeL :: Lens' MetaOpCode OpCode
opReasonL :: Lens' CommonOpParams ReasonTrail
opPriorityL :: Lens' CommonOpParams OpSubmitPriority
opDryRunL :: Lens' CommonOpParams (Maybe Bool)
opDependsL :: Lens' CommonOpParams (Maybe [JobDependency])
opDebugLevelL :: Lens' CommonOpParams (Maybe (NonNegative Int))
opCommentL :: Lens' CommonOpParams (Maybe String)


-- | Objects in the job queue.
module Ganeti.JQueue.Objects

-- | The ganeti queue timestamp type. It represents the time as the pair of
--   seconds since the epoch and microseconds since the beginning of the
--   second.
type Timestamp = (Int, Int)

-- | An input opcode.
data InputOpCode

-- | OpCode was parsed successfully
ValidOpCode :: MetaOpCode -> InputOpCode

-- | Invalid opcode
InvalidOpCode :: JSValue -> InputOpCode
data QueuedOpCode
QueuedOpCode :: InputOpCode -> OpStatus -> JSValue -> [(Int, Timestamp, ELogType, JSValue)] -> Int -> Maybe Timestamp -> Maybe Timestamp -> Maybe Timestamp -> QueuedOpCode
qoInput :: QueuedOpCode -> InputOpCode
qoStatus :: QueuedOpCode -> OpStatus
qoResult :: QueuedOpCode -> JSValue
qoLog :: QueuedOpCode -> [(Int, Timestamp, ELogType, JSValue)]
qoPriority :: QueuedOpCode -> Int
qoStartTimestamp :: QueuedOpCode -> Maybe Timestamp
qoExecTimestamp :: QueuedOpCode -> Maybe Timestamp
qoEndTimestamp :: QueuedOpCode -> Maybe Timestamp
loadQueuedOpCode :: JSValue -> Result QueuedOpCode
saveQueuedOpCode :: QueuedOpCode -> JSValue
data QueuedJob
QueuedJob :: JobId -> [QueuedOpCode] -> Maybe Timestamp -> Maybe Timestamp -> Maybe Timestamp -> Maybe FilePath -> Maybe ProcessID -> QueuedJob
qjId :: QueuedJob -> JobId
qjOps :: QueuedJob -> [QueuedOpCode]
qjReceivedTimestamp :: QueuedJob -> Maybe Timestamp
qjStartTimestamp :: QueuedJob -> Maybe Timestamp
qjEndTimestamp :: QueuedJob -> Maybe Timestamp
qjLivelock :: QueuedJob -> Maybe FilePath
qjProcessId :: QueuedJob -> Maybe ProcessID
loadQueuedJob :: JSValue -> Result QueuedJob
saveQueuedJob :: QueuedJob -> JSValue
instance Ord QueuedJob
instance Show QueuedJob
instance Eq QueuedJob
instance JSON QueuedJob
instance ArrayObject QueuedJob
instance DictObject QueuedJob
instance Ord QueuedOpCode
instance Show QueuedOpCode
instance Eq QueuedOpCode
instance JSON QueuedOpCode
instance ArrayObject QueuedOpCode
instance DictObject QueuedOpCode
instance Show InputOpCode
instance Eq InputOpCode
instance Ord InputOpCode
instance JSON InputOpCode


-- | GenOpCodes handles Python opcode generation.
--   
--   GenOpCodes contains the helper functions that generate the Python
--   opcodes as strings from the Haskell opcode description.
module Ganeti.Hs2Py.GenOpCodes
pyClassDoc :: String -> String
pyClassField :: OpCodeField -> String
intercalateIndent :: [String] -> String
showPyClass :: OpCodeDescriptor -> String

-- | Generates all opcodes as Python classes.
showPyClasses :: String


-- | Lenses for job-queue objects
module Ganeti.JQueue.Lens
validOpCodeL :: Prism' InputOpCode MetaOpCode
qoStatusL :: Lens' QueuedOpCode OpStatus
qoStartTimestampL :: Lens' QueuedOpCode (Maybe Timestamp)
qoResultL :: Lens' QueuedOpCode JSValue
qoPriorityL :: Lens' QueuedOpCode Int
qoLogL :: Lens' QueuedOpCode [(Int, Timestamp, ELogType, JSValue)]
qoInputL :: Lens' QueuedOpCode InputOpCode
qoExecTimestampL :: Lens' QueuedOpCode (Maybe Timestamp)
qoEndTimestampL :: Lens' QueuedOpCode (Maybe Timestamp)
qjStartTimestampL :: Lens' QueuedJob (Maybe Timestamp)
qjReceivedTimestampL :: Lens' QueuedJob (Maybe Timestamp)
qjProcessIdL :: Lens' QueuedJob (Maybe ProcessID)
qjOpsL :: Lens' QueuedJob [QueuedOpCode]
qjLivelockL :: Lens' QueuedJob (Maybe FilePath)
qjIdL :: Lens' QueuedJob JobId
qjEndTimestampL :: Lens' QueuedJob (Maybe Timestamp)


-- | Parser for the output of the <tt>xm list --long</tt> command of Xen
module Ganeti.Hypervisor.Xen.XmParser

-- | A parser for parsing generic config files written in the (LISP-like)
--   format that is the output of the <tt>xm list --long</tt> command. This
--   parser only takes care of the syntactic parse, but does not care about
--   the semantics. Note: parsing the double requires checking for the next
--   character in order to prevent string like <a>9a</a> to be recognized
--   as the number 9.
lispConfigParser :: Parser LispConfig
findConf :: String -> [LispConfig] -> Result LispConfig
getValue :: FromLispConfig a => String -> [LispConfig] -> Result a
extractValues :: LispConfig -> Result [LispConfig]
isNamed :: String -> LispConfig -> Bool
parseState :: String -> ActualState
getDomainConfig :: LispConfig -> Result Domain

-- | A parser for parsing the output of the <tt>xm list --long</tt>
--   command. It adds the semantic layer on top of lispConfigParser. It
--   returns a map of domains, with their name as the key. FIXME: This is
--   efficient under the assumption that only a few fields of the domain
--   configuration are actually needed. If many of them are required, a
--   parser able to directly extract the domain config would actually be
--   better.
xmListParser :: Parser (Map String Domain)

-- | A parser for parsing the output of the <tt>xm uptime</tt> command.
xmUptimeParser :: Parser (Map Int UptimeInfo)

-- | A helper for parsing a single line of the <tt>xm uptime</tt> output.
uptimeLineParser :: Parser UptimeInfo


-- | Module to access the information provided by the Xen hypervisor.
module Ganeti.Hypervisor.Xen

-- | Get information about the current Xen domains as a map where the
--   domain name is the key. This only includes the information made
--   available by Xen itself.
getDomainsInfo :: IO (Result (Map String Domain))
inferDomInfos :: Map String Domain -> Domain -> Domain

-- | Get information about the current Xen domains as a map where the
--   domain name is the key. This includes information made available by
--   Xen itself as well as further information that can be inferred by
--   querying Xen multiple times and comparing the results.
getInferredDomInfo :: IO (Result (Map String Domain))

-- | Get information about the uptime of domains, as a map where the domain
--   ID is the key.
getUptimeInfo :: IO (Map Int UptimeInfo)


-- | Utilities related to livelocks and death detection
module Ganeti.Utils.Livelock
type Livelock = FilePath

-- | Appends the current time to the given prefix, creates the lockfile in
--   the appropriate directory, and locks it. Returns its full path and the
--   file's file descriptor.
mkLivelockFile :: (Error e, MonadError e m, MonadIO m) => FilePath -> m (Fd, Livelock)

-- | List currently existing livelocks. Underapproximate if some error
--   occurs.
listLiveLocks :: IO [FilePath]

-- | Detect whether a the process identified by the given path does not
--   exist any more. This function never fails and only returns True if it
--   has positive knowledge that the process does not exist any more (i.e.,
--   if it managed successfully obtain a shared lock on the file).
isDead :: Livelock -> IO Bool


-- | Implementation of the Ganeti Unix Domain Socket JSON server interface.
module Ganeti.UDSServer
withTimeout :: Int -> String -> IO a -> IO a

-- | Result of receiving a message from the socket.
data RecvResult

-- | Connection closed
RecvConnClosed :: RecvResult

-- | Any other error
RecvError :: String -> RecvResult

-- | Successfull receive
RecvOk :: String -> RecvResult
eOM :: Word8
bEOM :: ByteString

-- | Valid keys in the requests and responses.
data MsgKeys
Method :: MsgKeys
Args :: MsgKeys
Success :: MsgKeys
Result :: MsgKeys

-- | The serialisation of MsgKeys into strings in messages.
strOfKey :: MsgKeys -> String
data ServerConfig
ServerConfig :: FilePermissions -> ConnectConfig -> ServerConfig
connPermissions :: ServerConfig -> FilePermissions
connConfig :: ServerConfig -> ConnectConfig
data ConnectConfig
ConnectConfig :: Int -> Int -> ConnectConfig
recvTmo :: ConnectConfig -> Int
sendTmo :: ConnectConfig -> Int

-- | A client encapsulation. Note that it has separate read and write
--   handle. For sockets it is the same handle. It is required for
--   bi-directional inter-process pipes though.
data Client
Client :: Handle -> Handle -> IORef ByteString -> ConnectConfig -> Client
rsocket :: Client -> Handle
wsocket :: Client -> Handle
rbuf :: Client -> IORef ByteString
clientConfig :: Client -> ConnectConfig

-- | A server encapsulation.
data Server
Server :: Socket -> FilePath -> ConnectConfig -> Server
sSocket :: Server -> Socket
sPath :: Server -> FilePath
serverConfig :: Server -> ConnectConfig

-- | Creates a Unix socket and connects it to the specified <tt>path</tt>,
--   where <tt>timeout</tt> specifies the connection timeout.
openClientSocket :: Int -> FilePath -> IO Handle

-- | Closes the handle. Performing the operation on a handle that has
--   already been closed has no effect; doing so is not an error. All other
--   operations on a closed handle will fail.
closeClientSocket :: Handle -> IO ()

-- | Creates a Unix socket and binds it to the specified <tt>path</tt>.
openServerSocket :: FilePath -> IO Socket
closeServerSocket :: Socket -> FilePath -> IO ()
acceptSocket :: Socket -> IO Handle

-- | Connects to the master daemon and returns a Client.
connectClient :: ConnectConfig -> Int -> FilePath -> IO Client

-- | Creates and returns a server endpoint.
connectServer :: ServerConfig -> Bool -> FilePath -> IO Server

-- | Creates a new bi-directional client pipe. The two returned clients
--   talk to each other through the pipe.
pipeClient :: ConnectConfig -> IO (Client, Client)

-- | Closes a server endpoint.
closeServer :: MonadBase IO m => Server -> m ()

-- | Accepts a client
acceptClient :: Server -> IO Client

-- | Closes the client socket. Performing the operation on a client that
--   has already been closed has no effect; doing so is not an error. All
--   other operations on a closed client will fail with an exception.
closeClient :: Client -> IO ()

-- | Extracts the read (the first) and the write (the second) file
--   descriptor of a client. This closes the underlying <a>Handle</a>s,
--   therefore the original client is closed and unusable after the call.
--   
--   The purpose of this function is to keep the communication channel
--   open, while replacing a <a>Client</a> with some other means.
clientToFd :: Client -> IO (Fd, Fd)

-- | Sends a message over a transport.
sendMsg :: Client -> String -> IO ()
recvUpdate :: ConnectConfig -> Handle -> ByteString -> IO (ByteString, ByteString)

-- | Waits for a message over a transport.
recvMsg :: Client -> IO String

-- | Extended wrapper over recvMsg.
recvMsgExt :: Client -> IO RecvResult

-- | Serialize a request to String.
buildCall :: (JSON mth, JSON args) => mth -> args -> String

-- | Parse the required keys out of a call.
parseCall :: (JSON mth, JSON args) => String -> Result (mth, args)

-- | Serialize the response to String.
buildResponse :: Bool -> JSValue -> String
decodeError :: JSValue -> ErrorResult JSValue

-- | Check that luxi responses contain the required keys and that the call
--   was successful.
parseResponse :: String -> ErrorResult JSValue
logMsg :: (Show e, JSON e, MonadLog m) => Handler i m o -> i -> GenericResult e JSValue -> m ()
prepareMsg :: JSON e => GenericResult e JSValue -> (Bool, JSValue)
type HandlerResult m o = m (Bool, GenericResult GanetiException o)
data Handler i m o
Handler :: (JSValue -> JSValue -> Result i) -> (i -> String) -> (i -> String) -> (i -> HandlerResult m o) -> Handler i m o

-- | parses method and its arguments into the input type
hParse :: Handler i m o -> JSValue -> JSValue -> Result i

-- | short description of an input, for the INFO logging level
hInputLogShort :: Handler i m o -> i -> String

-- | long description of an input, for the DEBUG logging level
hInputLogLong :: Handler i m o -> i -> String

-- | executes the handler on an input
hExec :: Handler i m o -> i -> HandlerResult m o
handleJsonMessage :: (JSON o, Monad m) => Handler i m o -> i -> HandlerResult m JSValue
handleRawMessage :: (JSON o, MonadLog m) => Handler i m o -> String -> m (Bool, String)
isRisky :: RecvResult -> Bool
handleClient :: (JSON o, MonadBase IO m, MonadLog m) => Handler i m o -> Client -> m Bool
clientLoop :: (JSON o, MonadBase IO m, MonadLog m) => Handler i m o -> Client -> m ()

-- | Main listener loop: accepts clients, forks an I/O thread to handle
--   that client.
listener :: (JSON o, MonadBaseControl IO m, MonadLog m) => Handler i m o -> Server -> m ()
instance Show RecvResult
instance Eq RecvResult


-- | Executing jobs as processes
--   
--   The protocol works as follows (MP = master process, FP = forked
--   process):
--   
--   <ul>
--   <li>MP sets its own livelock as the livelock of the job to be
--   executed.</li>
--   <li>FP creates its own lock file and sends its name to the MP.</li>
--   <li>MP updates the lock file name in the job file and confirms the FP
--   it can start.</li>
--   <li>FP calls <a>executeFile</a> and replaces the process with a Python
--   process</li>
--   <li>FP sends an empty message to the MP to signal it's ready to
--   receive the necessary information.</li>
--   <li>MP sends the FP its job ID.</li>
--   <li>FP sends an empty message to the MP again.</li>
--   <li>MP sends the FP its live lock file name (since it was known only
--   to the Haskell process, but not the Python process).</li>
--   <li>Both MP and FP close the communication channel.</li>
--   </ul>
module Ganeti.Query.Exec
isForkSupported :: IO Bool
connectConfig :: ConnectConfig
listOpenFds :: Error e => ResultT e IO [Fd]
rethrowAnnotateIOError :: String -> IO a -> IO a
runJobProcess :: JobId -> Client -> IO ()
forkWithPipe :: ConnectConfig -> (Client -> IO ()) -> IO (ProcessID, Client)

-- | Forks the job process and starts processing of the given job. Returns
--   the livelock of the job and its process ID.
forkJobProcess :: (Error e, Show e) => JobId -> FilePath -> (FilePath -> ResultT e IO ()) -> ResultT e IO (FilePath, ProcessID)


-- | KVM daemon
--   
--   The KVM daemon is responsible for determining whether a given KVM
--   instance was shutdown by an administrator or a user. For more
--   information read the design document on the KVM daemon.
--   
--   The KVM daemon design is split in 2 parts, namely, monitors for Qmp
--   sockets and directory/file watching.
--   
--   The monitors are spawned in lightweight Haskell threads and are
--   reponsible for handling the communication between the KVM daemon and
--   the KVM instance using the Qmp protocol. During the communcation, the
--   monitor parses the Qmp messages and if powerdown or shutdown is
--   received, then the shutdown file is written in the KVM control
--   directory. Otherwise, when the communication terminates, that same
--   file is removed. The communication terminates when the KVM instance
--   stops or crashes.
--   
--   The directory and file watching uses inotify to track down events on
--   the KVM control directory and its parents. There is a directory
--   crawler that will try to add a watch to the KVM control directory if
--   available or its parents, thus replacing watches until the KVM control
--   directory becomes available. When this happens, a monitor for the Qmp
--   socket is spawned. Given that the KVM daemon might stop or crash, the
--   directory watching also simulates events for the Qmp sockets that
--   already exist in the KVM control directory when the KVM daemon starts.
module Ganeti.Kvmd
type Lock = MVar ()
type Monitors = MVar (Set FilePath)

-- | <tt>isPrefixPath x y</tt> determines whether <tt>x</tt> is a
--   <a>FilePath</a> prefix of <a>FilePath</a> <tt>y</tt>.
isPrefixPath :: FilePath -> FilePath -> Bool
monitorGreeting :: String

-- | KVM control directory containing the Qmp sockets.
monitorDir :: String
monitorExtension :: String
isMonitorPath :: FilePath -> Bool
shutdownExtension :: String
shutdownPath :: String -> String
touchFile :: FilePath -> IO ()

-- | <tt>parseQmp isPowerdown isShutdown isStop str</tt> parses the packet
--   <tt>str</tt> and returns whether a powerdown, shutdown, or stop event
--   is contained in that packet, defaulting to the values
--   <tt>isPowerdown</tt>, <tt>isShutdown</tt>, and <tt>isStop</tt>,
--   otherwise.
parseQmp :: Bool -> Bool -> Bool -> String -> (Bool, Bool, Bool)

-- | <tt>receiveQmp handle</tt> listens for Qmp events on <tt>handle</tt>
--   and, when <tt>handle</tt> is closed, it returns <a>True</a> if a user
--   shutdown event was received, and <a>False</a> otherwise.
receiveQmp :: Handle -> IO Bool

-- | <tt>detectMonitor monitorFile handle</tt> listens for Qmp events on
--   <tt>handle</tt> for Qmp socket <tt>monitorFile</tt> and, when
--   communcation terminates, it either creates the shutdown file, if a
--   user shutdown was detected, or it deletes that same file, if an
--   administrator shutdown was detected.
detectMonitor :: FilePath -> Handle -> IO ()

-- | <tt>runMonitor monitorFile</tt> creates a monitor for the Qmp socket
--   <tt>monitorFile</tt> and calls <a>detectMonitor</a>.
runMonitor :: FilePath -> IO ()

-- | <tt>ensureMonitor monitors monitorFile</tt> ensures that there is
--   exactly one monitor running for the Qmp socket <tt>monitorFile</tt>,
--   given the existing set of monitors <tt>monitors</tt>.
ensureMonitor :: Monitors -> FilePath -> IO ()

-- | Handles an inotify event outside the target directory.
--   
--   Tracks events on the parent directory of the KVM control directory
--   until one of its parents becomes available.
handleGenericEvent :: Lock -> String -> String -> Event -> IO ()

-- | Handles an inotify event in the target directory.
--   
--   Upon a create or open event inside the KVM control directory, it
--   ensures that there is a monitor running for the new Qmp socket.
handleTargetEvent :: Lock -> Monitors -> String -> Event -> IO ()

-- | Dispatches inotify events depending on the directory they occur in.
handleDir :: Lock -> Monitors -> String -> String -> Event -> IO ()

-- | Simulates file creation events for the Qmp sockets that already exist
--   in <tt>dir</tt>.
recapDir :: Lock -> Monitors -> FilePath -> IO ()

-- | Crawls <tt>tarDir</tt>, or its parents until <tt>tarDir</tt> becomes
--   available, always listening for inotify events.
--   
--   Used for crawling the KVM control directory and its parents, as well
--   as simulating file creation events.
watchDir :: Lock -> FilePath -> INotify -> IO ()
rewatchDir :: Lock -> FilePath -> INotify -> IO ()
startWith :: FilePath -> IO ()
start :: IO ()


-- | Configuration server for the metadata daemon.
module Ganeti.Metad.ConfigServer

-- | Update the configuration with the received instance parameters.
updateConfig :: MVar InstanceParams -> String -> IO ()

-- | Reads messages from clients and update the configuration according to
--   these messages.
acceptConfig :: MVar InstanceParams -> Client -> IO ()

-- | Loop that accepts clients and dispatches them to an isolated thread
--   that will handle the client's requests.
acceptClients :: MVar InstanceParams -> Server -> IO ()
start :: DaemonOptions -> MVar InstanceParams -> IO ()


-- | Metadata daemon server, which controls the configuration and web
--   servers.
module Ganeti.Metad.Server
start :: DaemonOptions -> IO ()


-- | Implementation of lock allocation.
module Ganeti.Locking.Allocation

-- | Data type describing the way a lock can be owned.
data OwnerState
OwnShared :: OwnerState
OwnExclusive :: OwnerState
type IndirectOwners a b = Map (a, b) OwnerState
data AllocationState a b
Exclusive :: b -> (IndirectOwners a b) -> AllocationState a b
Shared :: (Set b) -> (IndirectOwners a b) -> AllocationState a b
indirectOwners :: (Ord a, Ord b) => Map (a, b) OwnerState -> Set b
indirectExclusives :: (Ord a, Ord b) => Map (a, b) OwnerState -> Set b

-- | Representation of a Lock allocation
--   
--   To keep queries for locks efficient, we keep two associations, with
--   the invariant that they fit together: the association from locks to
--   their allocation state, and the association from an owner to the set
--   of locks owned. As we do not export the constructor, the problem of
--   keeping this invariant reduces to only exporting functions that keep
--   the invariant.
data LockAllocation a b
LockAllocation :: Map a (AllocationState a b) -> Map b (Map a OwnerState) -> LockAllocation a b
laLocks :: LockAllocation a b -> Map a (AllocationState a b)
laOwned :: LockAllocation a b -> Map b (Map a OwnerState)

-- | A state with all locks being free.
emptyAllocation :: (Ord a, Ord b) => LockAllocation a b

-- | Obtain the list of all owners holding at least a single lock.
lockOwners :: Ord b => LockAllocation a b -> [b]

-- | Obtain the locks held by a given owner. The locks are reported as a
--   map from the owned locks to the form of ownership (OwnShared or
--   OwnExclusive).
listLocks :: Ord b => b -> LockAllocation a b -> Map a OwnerState

-- | List all locks currently (directly or indirectly) owned by someone.
listAllLocks :: Ord b => LockAllocation a b -> [a]
toOwnersList :: AllocationState a b -> [(b, OwnerState)]

-- | List all locks currently (directly of indirectly) in use together with
--   the direct owners.
listAllLocksOwners :: LockAllocation a b -> [(a, [(b, OwnerState)])]

-- | Returns <a>True</a> if the given owner holds the given lock at the
--   given ownership level or higher. This means that querying for a shared
--   lock returns <a>True</a> of the owner holds the lock in shared or
--   exlusive mode.
holdsLock :: (Ord a, Ord b) => b -> a -> OwnerState -> LockAllocation a b -> Bool

-- | Data Type describing a change request on a single lock.
data LockRequest a
LockRequest :: a -> Maybe OwnerState -> LockRequest a
lockAffected :: LockRequest a -> a
lockRequestType :: LockRequest a -> Maybe OwnerState

-- | Lock request for an exclusive lock.
requestExclusive :: a -> LockRequest a

-- | Lock request for a shared lock.
requestShared :: a -> LockRequest a

-- | Request to release a lock.
requestRelease :: a -> LockRequest a
updateAllocState :: (Ord a, Ord b) => (Maybe (AllocationState a b) -> AllocationState a b) -> LockAllocation a b -> a -> LockAllocation a b
updateLock :: (Ord a, Ord b) => b -> LockAllocation a b -> LockRequest a -> LockAllocation a b
updateIndirectSet :: (Ord a, Ord b) => (IndirectOwners a b -> IndirectOwners a b) -> LockAllocation a b -> a -> LockAllocation a b
updateIndirects :: (Lock a, Ord b) => b -> LockAllocation a b -> LockRequest a -> LockAllocation a b

-- | Update the locks of an owner according to the given request. Return
--   the pair of the new state and the result of the operation, which is
--   the the set of owners on which the operation was blocked on. so an
--   empty set is success, and the state is updated if, and only if, the
--   returned set is emtpy. In that way, it can be used in
--   atomicModifyIORef.
updateLocks :: (Lock a, Ord b) => b -> [LockRequest a] -> LockAllocation a b -> (LockAllocation a b, Result (Set b))
manipulateLocksPredicate :: (Lock a, Ord b) => (a -> LockRequest a) -> (a -> Bool) -> b -> LockAllocation a b -> LockAllocation a b
freeLocksPredicate :: (Lock a, Ord b) => (a -> Bool) -> LockAllocation a b -> b -> LockAllocation a b

-- | Compute the state after an onwer releases all its locks.
freeLocks :: (Lock a, Ord b) => LockAllocation a b -> b -> LockAllocation a b
readLockOwnerstate :: JSON a => JSValue -> Result (a, OwnerState)
readOwnerLock :: (JSON a, JSON b) => JSValue -> Result (b, [(a, OwnerState)])
toRequest :: (a, OwnerState) -> LockRequest a
allocationFromOwners :: (Lock a, Ord b, Show b) => [(b, [(a, OwnerState)])] -> Result (LockAllocation a b)
instance Ord OwnerState
instance Eq OwnerState
instance Show OwnerState
instance (Eq a, Eq b) => Eq (AllocationState a b)
instance (Show a, Show b) => Show (AllocationState a b)
instance (Eq a, Eq b) => Eq (LockAllocation a b)
instance (Show a, Show b) => Show (LockAllocation a b)
instance Eq a => Eq (LockRequest a)
instance Show a => Show (LockRequest a)
instance Ord a => Ord (LockRequest a)
instance (Lock a, JSON a, Ord b, JSON b, Show b) => JSON (LockAllocation a b)
instance JSON OwnerState
instance JSON a => JSON (LockRequest a)


-- | Implementation of a priority waiting structure for locks.
module Ganeti.Locking.Waiting

-- | Representation of the waiting structure
--   
--   For any request we cannot fullfill immediately, we have a set of lock
--   owners it is blocked on. We can pick one of the owners, the smallest
--   say; then we know that this request cannot possibly be fulfilled until
--   this owner does something. So we can index the pending requests by
--   such a chosen owner and only revisit them once the owner acts. For the
--   requests to revisit we need to do so in order of increasing priority;
--   this order can be maintained by the Set data structure, where we make
--   use of the fact that tuples are ordered lexicographically.
--   
--   Additionally, we keep track of which owners have pending requests, to
--   disallow them any other lock tasks till their request is fulfilled. To
--   allow canceling of pending requests, we also keep track on which owner
--   their request is pending on and what the request was.
data LockWaiting a b c
LockWaiting :: LockAllocation a b -> Map b (Set (c, b, [LockRequest a])) -> Map b (b, (c, b, [LockRequest a])) -> LockWaiting a b c
lwAllocation :: LockWaiting a b c -> LockAllocation a b
lwPending :: LockWaiting a b c -> Map b (Set (c, b, [LockRequest a]))
lwPendingOwners :: LockWaiting a b c -> Map b (b, (c, b, [LockRequest a]))

-- | A state without locks and pending requests.
emptyWaiting :: (Ord a, Ord b, Ord c) => LockWaiting a b c

-- | Get the set of owners with pending lock requests.
getPendingOwners :: LockWaiting a b c -> Set b

-- | Predicate on whether an owner has a pending lock request.
hasPendingRequest :: Ord b => b -> LockWaiting a b c -> Bool

-- | Get the allocation state from the waiting state
getAllocation :: LockWaiting a b c -> LockAllocation a b

-- | Get the list of all pending requests.
getPendingRequests :: (Ord a, Ord b, Ord c) => LockWaiting a b c -> Set (c, b, [LockRequest a])

-- | Type of the extensional representation of a LockWaiting.
type ExtWaiting a b c = (LockAllocation a b, Set (c, b, [LockRequest a]))

-- | Get a representation, comparable by (==), that captures the
--   extensional behaviour. In other words, <tt>(==) <tt>on</tt>
--   extRepr</tt> is a bisumlation.
extRepr :: (Ord a, Ord b, Ord c) => LockWaiting a b c -> ExtWaiting a b c
tryFulfillRequest :: (Lock a, Ord b, Ord c) => (LockWaiting a b c, Set b) -> (c, b, [LockRequest a]) -> (LockWaiting a b c, Set b)
revisitRequests :: (Lock a, Ord b, Ord c) => Set b -> Set b -> LockWaiting a b c -> (Set b, LockWaiting a b c)
updateLocks' :: (Lock a, Ord b, Ord c) => b -> [LockRequest a] -> LockWaiting a b c -> (LockWaiting a b c, (Result (Set b), Set b))
updateLocksWaiting' :: (Lock a, Ord b, Ord c) => c -> b -> [LockRequest a] -> LockWaiting a b c -> (LockWaiting a b c, (Result (Set b), Set b))
requestFulfilled :: (Ord a, Ord b) => b -> [LockRequest a] -> LockWaiting a b c -> Bool

-- | Update the locks on an onwer according to the given request, if
--   possible. Additionally (if the request succeeds) fulfill any pending
--   requests that became possible through this request. Return the new
--   state of the waiting structure, the result of the operation, and a
--   list of owners to be notified. The result is, as for lock allocation,
--   the set of owners the request is blocked on. Again, the type is chosen
--   to be suitable for use in atomicModifyIORef. For convenience,
--   fulfilled requests are always accepted.
updateLocks :: (Lock a, Ord b, Ord c) => b -> [LockRequest a] -> LockWaiting a b c -> (LockWaiting a b c, (Result (Set b), Set b))

-- | Update locks as soon as possible. If the request cannot be fulfilled
--   immediately add the request to the waiting queue. The first argument
--   is the priority at which the owner is waiting, the remaining are as
--   for updateLocks, and so is the output. For convenience, fulfilled
--   requests are always accepted.
updateLocksWaiting :: (Lock a, Ord b, Ord c) => c -> b -> [LockRequest a] -> LockWaiting a b c -> (LockWaiting a b c, (Result (Set b), Set b))

-- | Compute the state of a waiting after an owner gives up on his pending
--   request.
removePendingRequest :: (Lock a, Ord b, Ord c) => b -> LockWaiting a b c -> LockWaiting a b c

-- | A repeatable version of <a>updateLocksWaiting</a>. If the owner has a
--   pending request and the pending request is equal to the current one,
--   do nothing; otherwise call updateLocksWaiting.
safeUpdateLocksWaiting :: (Lock a, Ord b, Ord c) => c -> b -> [LockRequest a] -> LockWaiting a b c -> (LockWaiting a b c, (Result (Set b), Set b))

-- | Convenience function to release all pending requests and locks of a
--   given owner. Return the new configuration and the owners to notify.
releaseResources :: (Lock a, Ord b, Ord c) => b -> LockWaiting a b c -> (LockWaiting a b c, Set b)

-- | Obtain a LockWaiting from its extensional representation.
fromExtRepr :: (Lock a, Ord b, Ord c) => ExtWaiting a b c -> LockWaiting a b c
manipulateLocksPredicate :: (Lock a, Ord b, Ord c) => (a -> LockRequest a) -> (a -> Bool) -> b -> LockWaiting a b c -> (LockWaiting a b c, Set b)

-- | Free all Locks of a given owner satisfying a given predicate. As this
--   operation is supposed to unconditionally suceed, all pending requests
--   are dropped as well.
freeLocksPredicate :: (Lock a, Ord b, Ord c) => (a -> Bool) -> b -> LockWaiting a b c -> (LockWaiting a b c, Set b)

-- | Downgrade all locks of a given owner that satisfy a given predicate.
--   As this operation is supposed to unconditionally suceed, all pending
--   requests are dropped as well.
downGradeLocksPredicate :: (Lock a, Ord b, Ord c) => (a -> Bool) -> b -> LockWaiting a b c -> (LockWaiting a b c, Set b)

-- | Intersect locks to a given set.
intersectLocks :: (Lock a, Ord b, Ord c) => [a] -> b -> LockWaiting a b c -> (LockWaiting a b c, Set b)

-- | Opprotunistically allocate locks for a given owner; return the set of
--   newly actually acquired locks (i.e., locks already held before are not
--   mentioned).
opportunisticLockUnion :: (Lock a, Ord b, Ord c) => b -> [(a, OwnerState)] -> LockWaiting a b c -> (LockWaiting a b c, ([a], Set b))

-- | A guarded version of opportunisticLockUnion; if the number of
--   fulfilled requests is not at least the given amount, then do not
--   change anything.
guardedOpportunisticLockUnion :: (Lock a, Ord b, Ord c) => Int -> b -> [(a, OwnerState)] -> LockWaiting a b c -> (LockWaiting a b c, ([a], Set b))
instance (Show a, Show b, Show c) => Show (LockWaiting a b c)
instance (Lock a, JSON a, Ord b, JSON b, Show b, Ord c, JSON c) => JSON (LockWaiting a b c)


-- | Ganeti lock structure
module Ganeti.Locking.Locks

-- | The type of Locks available in Ganeti. The order of this type is the
--   lock oder.
data GanetiLocks
ClusterLockSet :: GanetiLocks
BGL :: GanetiLocks
InstanceLockSet :: GanetiLocks
Instance :: String -> GanetiLocks
NodeGroupLockSet :: GanetiLocks
NodeGroup :: String -> GanetiLocks
NodeLockSet :: GanetiLocks
Node :: String -> GanetiLocks
NodeResLockSet :: GanetiLocks
NodeRes :: String -> GanetiLocks
NetworkLockSet :: GanetiLocks
Network :: String -> GanetiLocks

-- | A lock used for a transitional period when WConfd keeps the state of
--   the configuration, but all the operations are still performed on the
--   Python side.
ConfigLock :: GanetiLocks

-- | Provide the String representation of a lock
lockName :: GanetiLocks -> String
lockFromName :: String -> Result GanetiLocks

-- | The levels, the locks belong to.
data LockLevel
LevelCluster :: LockLevel
LevelInstance :: LockLevel
LevelNodeGroup :: LockLevel
LevelNode :: LockLevel
LevelNodeRes :: LockLevel
LevelNetwork :: LockLevel

-- | A transitional level for internal configuration locks
LevelConfig :: LockLevel
lockLevelName :: LockLevel -> String
lockLevelFromName :: String -> Result LockLevel

-- | For a lock, provide its level.
lockLevel :: GanetiLocks -> LockLevel

-- | Type of entities capable of owning locks. Usually, locks are owned by
--   jobs. However, occassionally other tasks need locks (currently, e.g.,
--   to lock the configuration). These are identified by a unique name,
--   reported to WConfD as a strig.
data ClientType
ClientOther :: String -> ClientType
ClientJob :: JobId -> ClientType

-- | A client is identified as a job id, thread id, a path to its process
--   identifier file, and its process id.
--   
--   The JobId isn't enough to identify a client as the master daemon also
--   handles client calls that aren't jobs, but which use the
--   configuration. These taks are identified by a unique name, reported to
--   WConfD as a string.
data ClientId
ClientId :: ClientType -> FilePath -> ProcessID -> ClientId
ciIdentifier :: ClientId -> ClientType
ciLockFile :: ClientId -> FilePath
ciPid :: ClientId -> ProcessID
clientIdFromJSON :: JSValue -> Result ClientId

-- | The type of lock Allocations in Ganeti. In Ganeti, the owner of locks
--   are jobs.
type GanetiLockWaiting = LockWaiting GanetiLocks ClientId Integer
instance Ord GanetiLocks
instance Eq GanetiLocks
instance Show GanetiLocks
instance Eq LockLevel
instance Show LockLevel
instance Enum LockLevel
instance Ord ClientType
instance Eq ClientType
instance Show ClientType
instance Ord ClientId
instance Eq ClientId
instance Show ClientId
instance JSON ClientId
instance JSON ClientType
instance Lock GanetiLocks
instance JSON LockLevel
instance JSON GanetiLocks


-- | Function related to serialisation of WConfD requests
module Ganeti.WConfd.Language

-- | Operation to be carried out on a lock (request exclusive/shared
--   ownership, or release).
data LockRequestType
ReqExclusive :: LockRequestType
ReqShared :: LockRequestType
ReqRelease :: LockRequestType

-- | The type describing how lock update requests are passed over the wire.
type GanetiLockRequest = [(GanetiLocks, LockRequestType)]
toLockRequest :: (GanetiLocks, LockRequestType) -> LockRequest GanetiLocks

-- | From a GanetiLockRequest obtain a list of
--   Ganeti.Lock.Allocation.LockRequest, suitable to updateLocks.
fromGanetiLockRequest :: GanetiLockRequest -> [LockRequest GanetiLocks]
instance Eq LockRequestType
instance Show LockRequestType
instance JSON LockRequestType


-- | Space efficient bit arrays
--   
--   The module is meant to be imported qualified (as it is common with
--   collection libraries).
module Ganeti.Objects.BitArray

-- | A fixed-size, space-efficient array of bits.
data BitArray
BitArray :: !Int -> !IntSet -> BitArray
size :: BitArray -> !Int
_bitArrayBits :: BitArray -> !IntSet
empty :: BitArray
zeroes :: Int -> BitArray

-- | Right fold over the set, including indexes of each value.
foldr :: (Bool -> Int -> a -> a) -> a -> BitArray -> a

-- | Converts a bit array into a string, given characters for <tt>0</tt>
--   and <tt>1</tt>/
asString :: Char -> Char -> BitArray -> String

-- | Computes the number of zeroes in the array.
count0 :: BitArray -> Int

-- | Computes the number of ones in the array.
count1 :: BitArray -> Int

-- | Test a given bit in an array. If it's outside its scope, it's always
--   <tt>False</tt>.
(!) :: BitArray -> Int -> Bool

-- | Sets or removes an element from a bit array.
--   
--   Sets a given bit in an array. Fails if the index is out of bounds.
setAt :: (MonadError e m, Error e) => Int -> Bool -> BitArray -> m BitArray

-- | An intersection of two bit arrays. The length of the result is the
--   minimum length of the two.
(-&-) :: BitArray -> BitArray -> BitArray

-- | A union of two bit arrays. The length of the result is the maximum
--   length of the two.
(-|-) :: BitArray -> BitArray -> BitArray

-- | Checks if the first array is a subset of the other.
subset :: BitArray -> BitArray -> Bool

-- | Converts a bit array into a list of booleans.
toList :: BitArray -> [Bool]

-- | Converts a list of booleans to a <a>BitArray</a>.
fromList :: [Bool] -> BitArray
instance Eq BitArray
instance Ord BitArray
instance JSON BitArray
instance Show BitArray


-- | Implementation of the Ganeti config objects.
module Ganeti.Objects

-- | Fills one map with keys from the other map, if not already existing.
--   Mirrors objects.py:FillDict.
fillDict :: Ord k => Map k v -> Map k v -> [k] -> Map k v
data Ip4Address
Ip4Address :: Word8 -> Word8 -> Word8 -> Word8 -> Ip4Address
mkIp4Address :: (Word8, Word8, Word8, Word8) -> Ip4Address
readIp4Address :: (Applicative m, Monad m) => String -> m Ip4Address
ip4AddressToList :: Ip4Address -> [Word8]

-- | Converts an address into its ordinal number. This is needed for
--   indexing IP adresses in reservation pools.
ip4AddressToNumber :: Ip4Address -> Integer

-- | Converts a number into an address. This is needed for indexing IP
--   adresses in reservation pools.
ip4AddressFromNumber :: Integer -> Ip4Address
nextIp4Address :: Ip4Address -> Ip4Address

-- | Custom type for an IPv4 network.
data Ip4Network
Ip4Network :: Ip4Address -> Word8 -> Ip4Network
ip4netAddr :: Ip4Network -> Ip4Address
ip4netMask :: Ip4Network -> Word8
mkIp4Network :: Ip4Address -> Word8 -> Ip4Network

-- | Currently address pools just wrap a reservation <a>BitArray</a>.
--   
--   In future, <a>Network</a> might be extended to include several address
--   pools and address pools might include their own ranges of addresses.
newtype AddressPool
AddressPool :: BitArray -> AddressPool
apReservations :: AddressPool -> BitArray
data Network
Network :: NonEmptyString -> Maybe String -> Ip4Network -> Maybe String -> Maybe Ip4Address -> Maybe String -> Maybe AddressPool -> Maybe AddressPool -> String -> ClockTime -> ClockTime -> Int -> TagSet -> Network
networkName :: Network -> NonEmptyString
networkMacPrefix :: Network -> Maybe String
networkNetwork :: Network -> Ip4Network
networkNetwork6 :: Network -> Maybe String
networkGateway :: Network -> Maybe Ip4Address
networkGateway6 :: Network -> Maybe String
networkReservations :: Network -> Maybe AddressPool
networkExtReservations :: Network -> Maybe AddressPool
networkUuid :: Network -> String
networkCtime :: Network -> ClockTime
networkMtime :: Network -> ClockTime
networkSerial :: Network -> Int
networkTags :: Network -> TagSet
loadNetwork :: JSValue -> Result Network
saveNetwork :: Network -> JSValue
type MicroSeconds = Integer

-- | The configuration regarding a single data collector.
data DataCollectorConfig
DataCollectorConfig :: Bool -> MicroSeconds -> DataCollectorConfig
dataCollectorActive :: DataCollectorConfig -> Bool
dataCollectorInterval :: DataCollectorConfig -> MicroSeconds
loadDataCollectorConfig :: JSValue -> Result DataCollectorConfig
saveDataCollectorConfig :: DataCollectorConfig -> JSValue
data FilledISpecParams
FilledISpecParams :: Int -> Int -> Int -> Int -> Int -> Int -> FilledISpecParams
ispecMemorySize :: FilledISpecParams -> Int
ispecDiskSize :: FilledISpecParams -> Int
ispecDiskCount :: FilledISpecParams -> Int
ispecCpuCount :: FilledISpecParams -> Int
ispecNicCount :: FilledISpecParams -> Int
ispecSpindleUse :: FilledISpecParams -> Int
data PartialISpecParams
PartialISpecParams :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> PartialISpecParams
ispecMemorySizeP :: PartialISpecParams -> Maybe Int
ispecDiskSizeP :: PartialISpecParams -> Maybe Int
ispecDiskCountP :: PartialISpecParams -> Maybe Int
ispecCpuCountP :: PartialISpecParams -> Maybe Int
ispecNicCountP :: PartialISpecParams -> Maybe Int
ispecSpindleUseP :: PartialISpecParams -> Maybe Int
allISpecParamFields :: [String]
loadPartialISpecParams :: JSValue -> Result PartialISpecParams
savePartialISpecParams :: PartialISpecParams -> JSValue
loadFilledISpecParams :: JSValue -> Result FilledISpecParams
saveFilledISpecParams :: FilledISpecParams -> JSValue
data MinMaxISpecs
MinMaxISpecs :: FilledISpecParams -> FilledISpecParams -> MinMaxISpecs
mmisMinSpec :: MinMaxISpecs -> FilledISpecParams
mmisMaxSpec :: MinMaxISpecs -> FilledISpecParams
loadMinMaxISpecs :: JSValue -> Result MinMaxISpecs
saveMinMaxISpecs :: MinMaxISpecs -> JSValue

-- | Custom partial ipolicy. This is not built via buildParam since it has
--   a special 2-level inheritance mode.
data PartialIPolicy
PartialIPolicy :: Maybe [MinMaxISpecs] -> Maybe PartialISpecParams -> Maybe Double -> Maybe Double -> Maybe [DiskTemplate] -> PartialIPolicy
ipolicyMinMaxISpecsP :: PartialIPolicy -> Maybe [MinMaxISpecs]
ipolicyStdSpecP :: PartialIPolicy -> Maybe PartialISpecParams
ipolicySpindleRatioP :: PartialIPolicy -> Maybe Double
ipolicyVcpuRatioP :: PartialIPolicy -> Maybe Double
ipolicyDiskTemplatesP :: PartialIPolicy -> Maybe [DiskTemplate]
loadPartialIPolicy :: JSValue -> Result PartialIPolicy
savePartialIPolicy :: PartialIPolicy -> JSValue

-- | Custom filled ipolicy. This is not built via buildParam since it has a
--   special 2-level inheritance mode.
data FilledIPolicy
FilledIPolicy :: [MinMaxISpecs] -> FilledISpecParams -> Double -> Double -> [DiskTemplate] -> FilledIPolicy
ipolicyMinMaxISpecs :: FilledIPolicy -> [MinMaxISpecs]
ipolicyStdSpec :: FilledIPolicy -> FilledISpecParams
ipolicySpindleRatio :: FilledIPolicy -> Double
ipolicyVcpuRatio :: FilledIPolicy -> Double
ipolicyDiskTemplates :: FilledIPolicy -> [DiskTemplate]
loadFilledIPolicy :: JSValue -> Result FilledIPolicy
saveFilledIPolicy :: FilledIPolicy -> JSValue
data FilledNDParams
FilledNDParams :: String -> Int -> Bool -> Bool -> String -> String -> Int -> Double -> FilledNDParams
ndpOobProgram :: FilledNDParams -> String
ndpSpindleCount :: FilledNDParams -> Int
ndpExclusiveStorage :: FilledNDParams -> Bool
ndpOvs :: FilledNDParams -> Bool
ndpOvsName :: FilledNDParams -> String
ndpOvsLink :: FilledNDParams -> String
ndpSshPort :: FilledNDParams -> Int
ndpCpuSpeed :: FilledNDParams -> Double
data PartialNDParams
PartialNDParams :: Maybe String -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe String -> Maybe String -> Maybe Int -> Maybe Double -> PartialNDParams
ndpOobProgramP :: PartialNDParams -> Maybe String
ndpSpindleCountP :: PartialNDParams -> Maybe Int
ndpExclusiveStorageP :: PartialNDParams -> Maybe Bool
ndpOvsP :: PartialNDParams -> Maybe Bool
ndpOvsNameP :: PartialNDParams -> Maybe String
ndpOvsLinkP :: PartialNDParams -> Maybe String
ndpSshPortP :: PartialNDParams -> Maybe Int
ndpCpuSpeedP :: PartialNDParams -> Maybe Double
allNDParamFields :: [String]
loadPartialNDParams :: JSValue -> Result PartialNDParams
savePartialNDParams :: PartialNDParams -> JSValue
loadFilledNDParams :: JSValue -> Result FilledNDParams
saveFilledNDParams :: FilledNDParams -> JSValue
type DiskState = Container JSValue
type HypervisorState = Container JSValue
data Node
Node :: String -> String -> String -> Bool -> Bool -> Bool -> String -> Bool -> Bool -> PartialNDParams -> Bool -> HypervisorState -> DiskState -> ClockTime -> ClockTime -> String -> Int -> TagSet -> Node
nodeName :: Node -> String
nodePrimaryIp :: Node -> String
nodeSecondaryIp :: Node -> String
nodeMasterCandidate :: Node -> Bool
nodeOffline :: Node -> Bool
nodeDrained :: Node -> Bool
nodeGroup :: Node -> String
nodeMasterCapable :: Node -> Bool
nodeVmCapable :: Node -> Bool
nodeNdparams :: Node -> PartialNDParams
nodePowered :: Node -> Bool
nodeHvStateStatic :: Node -> HypervisorState
nodeDiskStateStatic :: Node -> DiskState
nodeCtime :: Node -> ClockTime
nodeMtime :: Node -> ClockTime
nodeUuid :: Node -> String
nodeSerial :: Node -> Int
nodeTags :: Node -> TagSet
loadNode :: JSValue -> Result Node
saveNode :: Node -> JSValue

-- | The cluster/group disk parameters type.
type GroupDiskParams = Container DiskParams
type Networks = Container PartialNicParams
data NodeGroup
NodeGroup :: String -> [String] -> PartialNDParams -> AllocPolicy -> PartialIPolicy -> GroupDiskParams -> Networks -> HypervisorState -> DiskState -> ClockTime -> ClockTime -> String -> Int -> TagSet -> NodeGroup
groupName :: NodeGroup -> String
groupMembers :: NodeGroup -> [String]
groupNdparams :: NodeGroup -> PartialNDParams
groupAllocPolicy :: NodeGroup -> AllocPolicy
groupIpolicy :: NodeGroup -> PartialIPolicy
groupDiskparams :: NodeGroup -> GroupDiskParams
groupNetworks :: NodeGroup -> Networks
groupHvStateStatic :: NodeGroup -> HypervisorState
groupDiskStateStatic :: NodeGroup -> DiskState
groupCtime :: NodeGroup -> ClockTime
groupMtime :: NodeGroup -> ClockTime
groupUuid :: NodeGroup -> String
groupSerial :: NodeGroup -> Int
groupTags :: NodeGroup -> TagSet
loadNodeGroup :: JSValue -> Result NodeGroup
saveNodeGroup :: NodeGroup -> JSValue

-- | Actions that can be performed when a filter matches.
data FilterAction
Accept :: FilterAction
Pause :: FilterAction
Reject :: FilterAction
Continue :: FilterAction
RateLimit :: Int -> FilterAction
data FilterPredicate
FPJobId :: (Filter FilterField) -> FilterPredicate
FPOpCode :: (Filter FilterField) -> FilterPredicate
FPReason :: (Filter FilterField) -> FilterPredicate
data FilterRule
FilterRule :: JobId -> NonNegative Int -> [FilterPredicate] -> FilterAction -> ReasonTrail -> String -> FilterRule
frWatermark :: FilterRule -> JobId
frPriority :: FilterRule -> NonNegative Int
frPredicates :: FilterRule -> [FilterPredicate]
frAction :: FilterRule -> FilterAction
frReasonTrail :: FilterRule -> ReasonTrail
frUuid :: FilterRule -> String
loadFilterRule :: JSValue -> Result FilterRule
saveFilterRule :: FilterRule -> JSValue

-- | Order in which filter rules are evaluated, according to
--   `doc/design-optables.rst`. For <a>FilterRule</a> fields not specified
--   as important for the order, we choose an arbitrary ordering effect
--   (after the ones from the spec).
--   
--   The <a>Ord</a> instance for <a>FilterRule</a> agrees with this
--   function. Yet it is recommended to use this function instead of
--   <a>compare</a> to be explicit that the spec order is used.
filterRuleOrder :: FilterRule -> FilterRule -> Ordering

-- | IP family type
data IpFamily
IpFamilyV4 :: IpFamily
IpFamilyV6 :: IpFamily
ipFamilyFromRaw :: Monad m_a6Kcd => Int -> m_a6Kcd IpFamily
ipFamilyToRaw :: IpFamily -> Int

-- | Conversion from IP family to IP version. This is needed because Python
--   uses both, depending on context.
ipFamilyToVersion :: IpFamily -> Int

-- | Cluster HvParams (hvtype to hvparams mapping).
type ClusterHvParams = GenericContainer Hypervisor HvParams

-- | Cluster Os-HvParams (os to hvparams mapping).
type OsHvParams = Container ClusterHvParams

-- | Cluser BeParams.
type ClusterBeParams = Container FilledBeParams

-- | Cluster OsParams.
type ClusterOsParams = Container OsParams
type ClusterOsParamsPrivate = Container (Private OsParams)

-- | Cluster NicParams.
type ClusterNicParams = Container FilledNicParams

-- | A low-high UID ranges.
type UidRange = (Int, Int)
formatUidRange :: UidRange -> String

-- | Cluster UID Pool, list (low, high) UID ranges.
type UidPool = [UidRange]

-- | The iallocator parameters type.
type IAllocatorParams = Container JSValue
type CandidateCertificates = Container String
data Cluster
Cluster :: String -> Maybe String -> Int -> [Int] -> String -> Maybe String -> [String] -> Maybe String -> String -> String -> String -> Int -> Bool -> String -> String -> String -> String -> [Hypervisor] -> ClusterHvParams -> OsHvParams -> ClusterBeParams -> ClusterOsParams -> ClusterOsParamsPrivate -> ClusterNicParams -> FilledNDParams -> GroupDiskParams -> Int -> Bool -> Bool -> Bool -> UidPool -> String -> IAllocatorParams -> [String] -> [String] -> IpFamily -> Bool -> FilledIPolicy -> HypervisorState -> DiskState -> [DiskTemplate] -> CandidateCertificates -> Int -> Int -> String -> String -> String -> [String] -> Bool -> Container DataCollectorConfig -> ClockTime -> ClockTime -> String -> Int -> TagSet -> Cluster
clusterRsahostkeypub :: Cluster -> String
clusterDsahostkeypub :: Cluster -> Maybe String
clusterHighestUsedPort :: Cluster -> Int
clusterTcpudpPortPool :: Cluster -> [Int]
clusterMacPrefix :: Cluster -> String
clusterVolumeGroupName :: Cluster -> Maybe String
clusterReservedLvs :: Cluster -> [String]
clusterDrbdUsermodeHelper :: Cluster -> Maybe String
clusterMasterNode :: Cluster -> String
clusterMasterIp :: Cluster -> String
clusterMasterNetdev :: Cluster -> String
clusterMasterNetmask :: Cluster -> Int
clusterUseExternalMipScript :: Cluster -> Bool
clusterClusterName :: Cluster -> String
clusterFileStorageDir :: Cluster -> String
clusterSharedFileStorageDir :: Cluster -> String
clusterGlusterStorageDir :: Cluster -> String
clusterEnabledHypervisors :: Cluster -> [Hypervisor]
clusterHvparams :: Cluster -> ClusterHvParams
clusterOsHvp :: Cluster -> OsHvParams
clusterBeparams :: Cluster -> ClusterBeParams
clusterOsparams :: Cluster -> ClusterOsParams
clusterOsparamsPrivateCluster :: Cluster -> ClusterOsParamsPrivate
clusterNicparams :: Cluster -> ClusterNicParams
clusterNdparams :: Cluster -> FilledNDParams
clusterDiskparams :: Cluster -> GroupDiskParams
clusterCandidatePoolSize :: Cluster -> Int
clusterModifyEtcHosts :: Cluster -> Bool
clusterModifySshSetup :: Cluster -> Bool
clusterMaintainNodeHealth :: Cluster -> Bool
clusterUidPool :: Cluster -> UidPool
clusterDefaultIallocator :: Cluster -> String
clusterDefaultIallocatorParams :: Cluster -> IAllocatorParams
clusterHiddenOs :: Cluster -> [String]
clusterBlacklistedOs :: Cluster -> [String]
clusterPrimaryIpFamily :: Cluster -> IpFamily
clusterPreallocWipeDisks :: Cluster -> Bool
clusterIpolicy :: Cluster -> FilledIPolicy
clusterHvStateStatic :: Cluster -> HypervisorState
clusterDiskStateStatic :: Cluster -> DiskState
clusterEnabledDiskTemplates :: Cluster -> [DiskTemplate]
clusterCandidateCerts :: Cluster -> CandidateCertificates
clusterMaxRunningJobs :: Cluster -> Int
clusterMaxTrackedJobs :: Cluster -> Int
clusterInstallImage :: Cluster -> String
clusterInstanceCommunicationNetwork :: Cluster -> String
clusterZeroingImage :: Cluster -> String
clusterCompressionTools :: Cluster -> [String]
clusterEnabledUserShutdown :: Cluster -> Bool
clusterDataCollectors :: Cluster -> Container DataCollectorConfig
clusterCtime :: Cluster -> ClockTime
clusterMtime :: Cluster -> ClockTime
clusterUuid :: Cluster -> String
clusterSerial :: Cluster -> Int
clusterTags :: Cluster -> TagSet
loadCluster :: JSValue -> Result Cluster
saveCluster :: Cluster -> JSValue
data ConfigData
ConfigData :: Int -> Cluster -> Container Node -> Container NodeGroup -> Container Instance -> Container Network -> Container Disk -> Container FilterRule -> ClockTime -> ClockTime -> Int -> ConfigData
configVersion :: ConfigData -> Int
configCluster :: ConfigData -> Cluster
configNodes :: ConfigData -> Container Node
configNodegroups :: ConfigData -> Container NodeGroup
configInstances :: ConfigData -> Container Instance
configNetworks :: ConfigData -> Container Network
configDisks :: ConfigData -> Container Disk
configFilters :: ConfigData -> Container FilterRule
configCtime :: ConfigData -> ClockTime
configMtime :: ConfigData -> ClockTime
configSerial :: ConfigData -> Int
loadConfigData :: JSValue -> Result ConfigData
saveConfigData :: ConfigData -> JSValue
data MasterNetworkParameters
MasterNetworkParameters :: String -> String -> Int -> String -> IpFamily -> MasterNetworkParameters
masterNetworkParametersUuid :: MasterNetworkParameters -> String
masterNetworkParametersIp :: MasterNetworkParameters -> String
masterNetworkParametersNetmask :: MasterNetworkParameters -> Int
masterNetworkParametersNetdev :: MasterNetworkParameters -> String
masterNetworkParametersIpFamily :: MasterNetworkParameters -> IpFamily
loadMasterNetworkParameters :: JSValue -> Result MasterNetworkParameters
saveMasterNetworkParameters :: MasterNetworkParameters -> JSValue
instance Show MasterNetworkParameters
instance Eq MasterNetworkParameters
instance JSON MasterNetworkParameters
instance ArrayObject MasterNetworkParameters
instance DictObject MasterNetworkParameters
instance Show ConfigData
instance Eq ConfigData
instance TimeStampObject ConfigData
instance SerialNoObject ConfigData
instance JSON ConfigData
instance ArrayObject ConfigData
instance DictObject ConfigData
instance Show Cluster
instance Eq Cluster
instance TagsObject Cluster
instance SerialNoObject Cluster
instance UuidObject Cluster
instance TimeStampObject Cluster
instance JSON Cluster
instance ArrayObject Cluster
instance DictObject Cluster
instance JSON IpFamily
instance Show IpFamily
instance Eq IpFamily
instance Enum IpFamily
instance Bounded IpFamily
instance Ord IpFamily
instance Show FilterRule
instance Eq FilterRule
instance Ord FilterRule
instance UuidObject FilterRule
instance JSON FilterRule
instance ArrayObject FilterRule
instance DictObject FilterRule
instance Show NodeGroup
instance Eq NodeGroup
instance Eq FilterAction
instance Ord FilterAction
instance Show FilterAction
instance Eq FilterPredicate
instance Ord FilterPredicate
instance Show FilterPredicate
instance JSON FilterPredicate
instance JSON FilterAction
instance TagsObject NodeGroup
instance SerialNoObject NodeGroup
instance UuidObject NodeGroup
instance TimeStampObject NodeGroup
instance JSON NodeGroup
instance ArrayObject NodeGroup
instance DictObject NodeGroup
instance Show Node
instance Eq Node
instance TagsObject Node
instance SerialNoObject Node
instance UuidObject Node
instance TimeStampObject Node
instance JSON Node
instance ArrayObject Node
instance DictObject Node
instance Show FilledNDParams
instance Eq FilledNDParams
instance Show PartialNDParams
instance Eq PartialNDParams
instance Monoid PartialNDParams
instance PartialParams FilledNDParams PartialNDParams
instance JSON PartialNDParams
instance ArrayObject PartialNDParams
instance DictObject PartialNDParams
instance JSON FilledNDParams
instance ArrayObject FilledNDParams
instance DictObject FilledNDParams
instance Show FilledIPolicy
instance Eq FilledIPolicy
instance PartialParams FilledIPolicy PartialIPolicy
instance JSON FilledIPolicy
instance ArrayObject FilledIPolicy
instance DictObject FilledIPolicy
instance Show PartialIPolicy
instance Eq PartialIPolicy
instance JSON PartialIPolicy
instance ArrayObject PartialIPolicy
instance DictObject PartialIPolicy
instance Show MinMaxISpecs
instance Eq MinMaxISpecs
instance JSON MinMaxISpecs
instance ArrayObject MinMaxISpecs
instance DictObject MinMaxISpecs
instance Show FilledISpecParams
instance Eq FilledISpecParams
instance Show PartialISpecParams
instance Eq PartialISpecParams
instance Monoid PartialISpecParams
instance PartialParams FilledISpecParams PartialISpecParams
instance JSON PartialISpecParams
instance ArrayObject PartialISpecParams
instance DictObject PartialISpecParams
instance JSON FilledISpecParams
instance ArrayObject FilledISpecParams
instance DictObject FilledISpecParams
instance Show DataCollectorConfig
instance Eq DataCollectorConfig
instance Monoid DataCollectorConfig
instance JSON DataCollectorConfig
instance ArrayObject DataCollectorConfig
instance DictObject DataCollectorConfig
instance Show Network
instance Eq Network
instance TimeStampObject Network
instance UuidObject Network
instance TagsObject Network
instance SerialNoObject Network
instance JSON Network
instance ArrayObject Network
instance DictObject Network
instance Eq Ip4Address
instance Ord Ip4Address
instance Eq Ip4Network
instance Eq AddressPool
instance Ord AddressPool
instance Show AddressPool
instance JSON AddressPool
instance JSON Ip4Network
instance Show Ip4Network
instance JSON Ip4Address
instance Show Ip4Address


-- | Some utility functions, based on the Confd client, providing data in a
--   ready-to-use way.
module Ganeti.Confd.ClientFunctions

-- | Get the list of instances the given node is ([primary], [secondary])
--   for. The server address and the server port parameters are mainly
--   intended for testing purposes. If they are Nothing, the default values
--   will be used.
getInstances :: String -> Maybe String -> Maybe Int -> ResultT String IO ([Instance], [Instance])
getDisks :: Instance -> Maybe String -> Maybe Int -> ResultT String IO [Disk]

-- | Get the list of instances on the given node along with their disks The
--   server address and the server port parameters are mainly intended for
--   testing purposes. If they are Nothing, the default values will be
--   used.
getInstanceDisks :: String -> Maybe String -> Maybe Int -> ResultT String IO [(Instance, [Disk])]


-- | Implementation of the Ganeti configuration database.
module Ganeti.Config

-- | Type alias for the link and ip map.
type LinkIpMap = Map String (Map String String)
readConfig :: FilePath -> IO (Result String)
parseConfig :: String -> Result ConfigData
encodeConfig :: ConfigData -> String

-- | Wrapper over <a>readConfig</a> and <a>parseConfig</a>.
loadConfig :: FilePath -> IO (Result ConfigData)

-- | Wrapper over <a>hPutStr</a> and <a>encodeConfig</a>.
saveConfig :: Handle -> ConfigData -> IO ()
withMissingParam :: String -> (a -> ErrorResult b) -> Maybe a -> ErrorResult b
computeDiskNodes :: Disk -> Set String
instDiskNodes :: ConfigData -> Instance -> Set String

-- | Computes all nodes of an instance.
instNodes :: ConfigData -> Instance -> Set String
instSecondaryNodes :: ConfigData -> Instance -> Set String

-- | Get instances of a given node. The node is specified through its UUID.
getNodeInstances :: ConfigData -> String -> ([Instance], [Instance])

-- | Computes the role of a node.
getNodeRole :: ConfigData -> Node -> NodeRole

-- | Get the list of the master nodes (usually one).
getMasterNodes :: ConfigData -> [Node]

-- | Get the list of master candidates, <i>not including</i> the master
--   itself.
getMasterCandidates :: ConfigData -> [Node]

-- | Get the list of master candidates, <i>including</i> the master.
getMasterOrCandidates :: ConfigData -> [Node]

-- | Get the network parameters for the master IP address.
getMasterNetworkParameters :: ConfigData -> MasterNetworkParameters

-- | Get the list of online nodes.
getOnlineNodes :: ConfigData -> [Node]

-- | Returns the default cluster link.
getDefaultNicLink :: ConfigData -> String

-- | Returns the default cluster hypervisor.
getDefaultHypervisor :: ConfigData -> Hypervisor

-- | Returns instances of a given link.
getInstancesIpByLink :: LinkIpMap -> String -> [String]
getItem :: String -> String -> Map String a -> ErrorResult a

-- | Looks up a node by name or uuid.
getNode :: ConfigData -> String -> ErrorResult Node

-- | Looks up an instance by name or uuid.
getInstance :: ConfigData -> String -> ErrorResult Instance

-- | Looks up a disk by uuid.
getDisk :: ConfigData -> String -> ErrorResult Disk

-- | Looks up a filter by uuid.
getFilterRule :: ConfigData -> String -> ErrorResult FilterRule

-- | Looks up a node group by name or uuid.
getGroup :: ConfigData -> String -> ErrorResult NodeGroup

-- | Computes a node group's node params.
getGroupNdParams :: ConfigData -> NodeGroup -> FilledNDParams

-- | Computes a node group's ipolicy.
getGroupIpolicy :: ConfigData -> NodeGroup -> FilledIPolicy

-- | Computes a group's (merged) disk params.
getGroupDiskParams :: ConfigData -> NodeGroup -> GroupDiskParams

-- | Get nodes of a given node group.
getGroupNodes :: ConfigData -> String -> [Node]

-- | Get (primary, secondary) instances of a given node group.
getGroupInstances :: ConfigData -> String -> ([Instance], [Instance])

-- | Retrieves the instance hypervisor params, missing values filled with
--   cluster defaults.
getFilledInstHvParams :: [String] -> ConfigData -> Instance -> HvParams

-- | Retrieves the instance backend params, missing values filled with
--   cluster defaults.
getFilledInstBeParams :: ConfigData -> Instance -> ErrorResult FilledBeParams

-- | Retrieves the instance os params, missing values filled with cluster
--   defaults. This does NOT include private and secret parameters.
getFilledInstOsParams :: ConfigData -> Instance -> OsParams

-- | Looks up an instance's primary node.
getInstPrimaryNode :: ConfigData -> String -> ErrorResult Node
getDrbdDiskNodes :: ConfigData -> Disk -> [Node]

-- | Retrieves all the nodes of the instance.
--   
--   As instances not using DRBD can be sent as a parameter as well, the
--   primary node has to be appended to the results.
getInstAllNodes :: ConfigData -> String -> ErrorResult [Node]

-- | Get disks for a given instance. The instance is specified by name or
--   uuid.
getInstDisks :: ConfigData -> String -> ErrorResult [Disk]

-- | Get disks for a given instance object.
getInstDisksFromObj :: ConfigData -> Instance -> ErrorResult [Disk]
collectFromDrbdDisks :: Monoid a => (String -> String -> Int -> Int -> Int -> Private DRBDSecret -> a) -> Disk -> a
getDrbdSecretsForDisk :: Disk -> [DRBDSecret]

-- | Returns the DRBD minors of a given <a>Disk</a>
getDrbdMinorsForDisk :: Disk -> [(Int, String)]
getDrbdMinorsForNode :: String -> Disk -> [(Int, String)]

-- | Returns the DRBD minors of a given instance
getDrbdMinorsForInstance :: ConfigData -> Instance -> ErrorResult [(Int, String)]
rolePrimary :: String
roleSecondary :: String

-- | Gets the list of DRBD minors for an instance that are related to a
--   given node.
getInstMinorsForNode :: ConfigData -> String -> Instance -> [(String, Int, String, String, String, String)]

-- | Builds link -&gt; ip -&gt; instname map. For instances without a name,
--   we insert the uuid instead.
--   
--   TODO: improve this by splitting it into multiple independent
--   functions:
--   
--   <ul>
--   <li>abstract the "fetch instance with filled params"
--   functionality</li>
--   <li>abstsract the [instance] -&gt; [(nic, instance_name)] part</li>
--   <li>etc.</li>
--   </ul>
buildLinkIpInstnameMap :: ConfigData -> LinkIpMap

-- | Returns a node's group, with optional failure if we can't find it
--   (configuration corrupt).
getGroupOfNode :: ConfigData -> Node -> Maybe NodeGroup

-- | Returns a node's ndparams, filled.
getNodeNdParams :: ConfigData -> Node -> Maybe FilledNDParams

-- | Looks up a network. If looking up by uuid fails, we look up by name.
getNetwork :: ConfigData -> String -> ErrorResult Network
type MAC = String

-- | Returns all MAC addresses used in the cluster.
getAllMACs :: ConfigData -> [MAC]
getAllDrbdSecrets :: ConfigData -> [DRBDSecret]

-- | A map from node UUIDs to
--   
--   FIXME: After adding designated types for UUIDs, use them to replace
--   <a>String</a> here.
type NodeLVsMap = MultiMap String LogicalVolume
getInstanceLVsByNode :: ConfigData -> Instance -> ErrorResult NodeLVsMap
getAllLVs :: ConfigData -> ErrorResult (Set LogicalVolume)

-- | Type class denoting objects which have node parameters.
class NdParamObject a
getNdParamsOf :: NdParamObject a => ConfigData -> a -> Maybe FilledNDParams
instance NdParamObject Cluster
instance NdParamObject NodeGroup
instance NdParamObject Node


-- | Implementation of configuration reader with watching support.
module Ganeti.ConfigReader

-- | A type for functions that can return the configuration when executed.
type ConfigReader = IO (Result ConfigData)
data ReloadModel
ReloadNotify :: ReloadModel
ReloadPoll :: Int -> ReloadModel
data ServerState
ServerState :: ReloadModel -> Integer -> FStat -> ServerState
reloadModel :: ServerState -> ReloadModel
reloadTime :: ServerState -> Integer
reloadFStat :: ServerState -> FStat
maxIdlePollRounds :: Int
watchInterval :: Int
pollInterval :: Int
reloadRatelimit :: Integer
initialPoll :: ReloadModel
data ConfigReload
ConfigToDate :: ConfigReload
ConfigReloaded :: ConfigReload
ConfigIOError :: ConfigReload
moveToPolling :: String -> INotify -> FilePath -> (Result ConfigData -> IO ()) -> MVar ServerState -> IO ReloadModel
moveToNotify :: IO ReloadModel
updateConfig :: FilePath -> (Result ConfigData -> IO ()) -> IO ()
safeUpdateConfig :: FilePath -> FStat -> (Result ConfigData -> IO ()) -> IO (FStat, ConfigReload)
onWatcherTimer :: IO Bool -> FilePath -> (Result ConfigData -> IO ()) -> MVar ServerState -> IO ()
onWatcherInner :: FilePath -> (Result ConfigData -> IO ()) -> ServerState -> IO ServerState
onPollTimer :: IO Bool -> FilePath -> (Result ConfigData -> IO ()) -> MVar ServerState -> IO ()
onPollInner :: IO Bool -> FilePath -> (Result ConfigData -> IO ()) -> ServerState -> IO (ServerState, Bool)
addNotifier :: INotify -> FilePath -> (Result ConfigData -> IO ()) -> MVar ServerState -> IO Bool
onInotify :: INotify -> String -> (Result ConfigData -> IO ()) -> MVar ServerState -> Event -> IO ()
initConfigReader :: (Result ConfigData -> IO ()) -> IO ()
instance Eq ReloadModel
instance Show ReloadModel
instance Eq ConfigReload


-- | Implementation of the Ganeti Query2 cluster queries.
module Ganeti.Query.Cluster

-- | Get master node name.
clusterMasterNodeName :: ConfigData -> ErrorResult String
isWatcherPaused :: IO (Maybe Integer)


-- | Implementation of the Ganeti data collector types.
module Ganeti.DataCollectors.Types

-- | The possible classes a data collector can belong to.
data DCCategory
DCInstance :: DCCategory
DCStorage :: DCCategory
DCDaemon :: DCCategory
DCHypervisor :: DCCategory

-- | Get the category name and return it as a string.
getCategoryName :: DCCategory -> String
categoryNames :: Map String DCCategory

-- | The possible status codes of a data collector.
data DCStatusCode

-- | Everything is OK
DCSCOk :: DCStatusCode

-- | Bad, but being automatically fixed
DCSCTempBad :: DCStatusCode

-- | Unable to determine the status
DCSCUnknown :: DCStatusCode

-- | Bad. External intervention required
DCSCBad :: DCStatusCode

-- | The status of a "status reporting data collector".
data DCStatus
DCStatus :: DCStatusCode -> String -> DCStatus
dcStatusCode :: DCStatus -> DCStatusCode
dcStatusMessage :: DCStatus -> String
loadDCStatus :: JSValue -> Result DCStatus
saveDCStatus :: DCStatus -> JSValue

-- | The type representing the kind of the collector.
data DCKind

-- | Performance reporting collector
DCKPerf :: DCKind

-- | Status reporting collector
DCKStatus :: DCKind

-- | Type representing the version number of a data collector.
data DCVersion
DCVerBuiltin :: DCVersion
DCVersion :: String -> DCVersion

-- | Type for the value field of the <a>CollectorMap</a> below.
data CollectorData
CPULoadData :: (Seq (ClockTime, [Int])) -> CollectorData

-- | Type for the map storing the data of the statefull DataCollectors.
type CollectorMap = Map String CollectorData

-- | This is the format of the report produced by each data collector.
data DCReport
DCReport :: String -> DCVersion -> Int -> Integer -> Maybe DCCategory -> DCKind -> JSValue -> DCReport
dcReportName :: DCReport -> String
dcReportVersion :: DCReport -> DCVersion
dcReportFormatVersion :: DCReport -> Int
dcReportTimestamp :: DCReport -> Integer
dcReportCategory :: DCReport -> Maybe DCCategory
dcReportKind :: DCReport -> DCKind
dcReportData :: DCReport -> JSValue
loadDCReport :: JSValue -> Result DCReport
saveDCReport :: DCReport -> JSValue

-- | Add the data collector status information to the JSON representation
--   of the collector data.
addStatus :: DCStatus -> JSValue -> JSValue

-- | Helper function for merging statuses.
mergeStatuses :: (DCStatusCode, String) -> (DCStatusCode, [String]) -> (DCStatusCode, [String])

-- | Utility function for building a report automatically adding the
--   current timestamp (rounded up to seconds). If the version is not
--   specified, it will be set to the value indicating a builtin collector.
buildReport :: String -> DCVersion -> Int -> Maybe DCCategory -> DCKind -> JSValue -> IO DCReport

-- | A report of a data collector might be stateful or stateless.
data ReportBuilder
StatelessR :: (IO DCReport) -> ReportBuilder
StatefulR :: (Maybe CollectorData -> IO DCReport) -> ReportBuilder
type Name = String

-- | Type describing a data collector basic information
data DataCollector
DataCollector :: Name -> Maybe DCCategory -> DCKind -> ReportBuilder -> Maybe (Maybe CollectorData -> IO CollectorData) -> (Name -> ConfigData -> Bool) -> (Name -> ConfigData -> Integer) -> DataCollector

-- | Name of the data collector
dName :: DataCollector -> Name

-- | Category (storage, instance, ecc) of the collector
dCategory :: DataCollector -> Maybe DCCategory

-- | Kind (performance or status reporting) of the data collector
dKind :: DataCollector -> DCKind

-- | Report produced by the collector
dReport :: DataCollector -> ReportBuilder

-- | Update operation for stateful collectors.
dUpdate :: DataCollector -> Maybe (Maybe CollectorData -> IO CollectorData)

-- | Checks if the collector applies for the cluster.
dActive :: DataCollector -> Name -> ConfigData -> Bool

-- | Interval between collection in microseconds
dInterval :: DataCollector -> Name -> ConfigData -> Integer
instance Show DCReport
instance Eq DCReport
instance JSON DCReport
instance ArrayObject DCReport
instance DictObject DCReport
instance Show DCStatus
instance Eq DCStatus
instance Show DCKind
instance Eq DCKind
instance Show DCVersion
instance Eq DCVersion
instance NFData CollectorData
instance NFData ClockTime
instance JSON DCVersion
instance JSON DCKind
instance JSON DCStatus
instance ArrayObject DCStatus
instance DictObject DCStatus
instance Show DCCategory
instance Eq DCCategory
instance Read DCCategory
instance Enum DCCategory
instance Bounded DCCategory
instance Show DCStatusCode
instance Eq DCStatusCode
instance Ord DCStatusCode
instance JSON DCStatusCode
instance JSON DCCategory


-- | <tt><i>proc</i>stat</tt> data collector.
module Ganeti.DataCollectors.CPUload
defaultFile :: FilePath
bufferSize :: Int
windowSize :: Integer
defaultCharNum :: Int

-- | The name of this data collector.
dcName :: String

-- | The version of this data collector.
dcVersion :: DCVersion

-- | The version number for the data format of this data collector.
dcFormatVersion :: Int

-- | The category of this data collector.
dcCategory :: Maybe DCCategory

-- | The kind of this data collector.
dcKind :: DCKind

-- | The data exported by the data collector, taken from the default
--   location.
dcReport :: Maybe CollectorData -> IO DCReport
type Buffer = Seq (ClockTime, [Int])
computeLoad :: CPUstat -> Int
dcCollectFromFile :: FilePath -> IO (ClockTime, [Int])
dcCollect :: IO Buffer
formatData :: [Double] -> CPUavgload
updateEntry :: Buffer -> Buffer -> Buffer

-- | Updates the given Collector data.
dcUpdate :: Maybe CollectorData -> IO CollectorData
computeAverage :: Buffer -> Integer -> Integer -> Result [Double]
buildJsonReport :: Buffer -> IO JSValue
buildDCReport :: Buffer -> IO DCReport


-- | <tt><i>proc</i>diskstats</tt> data collector.
module Ganeti.DataCollectors.Diskstats
defaultFile :: FilePath
defaultCharNum :: Int

-- | The name of this data collector.
dcName :: String

-- | The version of this data collector.
dcVersion :: DCVersion

-- | The version number for the data format of this data collector.
dcFormatVersion :: Int

-- | The category of this data collector.
dcCategory :: Maybe DCCategory

-- | The kind of this data collector.
dcKind :: DCKind

-- | The data exported by the data collector, taken from the default
--   location.
dcReport :: IO DCReport
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
buildJsonReport :: FilePath -> IO JSValue
buildDCReport :: FilePath -> IO DCReport

-- | Main function.
main :: Options -> [String] -> IO ()


-- | DRBD data collector.
module Ganeti.DataCollectors.Drbd
defaultFile :: FilePath
defaultCharNum :: Int

-- | The name of this data collector.
dcName :: String

-- | The version of this data collector.
dcVersion :: DCVersion

-- | The version number for the data format of this data collector.
dcFormatVersion :: Int

-- | The category of this data collector.
dcCategory :: Maybe DCCategory

-- | The kind of this data collector.
dcKind :: DCKind

-- | The data exported by the data collector, taken from the default
--   location.
dcReport :: IO DCReport
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
getPairingInfo :: Maybe String -> IO (Result [DrbdInstMinor])
computeStatus :: DRBDStatus -> DCStatus
computeDevStatus :: DeviceInfo -> (DCStatusCode, String)
buildJsonReport :: FilePath -> Maybe FilePath -> IO JSValue
buildDCReport :: FilePath -> Maybe FilePath -> IO DCReport

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Type declarations specific for the instance status data collector.
module Ganeti.DataCollectors.InstStatusTypes

-- | Data type representing the status of an instance to be returned.
data InstStatus
InstStatus :: String -> String -> AdminState -> ActualState -> Maybe String -> ClockTime -> ReasonTrail -> DCStatus -> InstStatus
iStatName :: InstStatus -> String
iStatUuid :: InstStatus -> String
iStatAdminState :: InstStatus -> AdminState
iStatActualState :: InstStatus -> ActualState
iStatUptime :: InstStatus -> Maybe String
iStatMtime :: InstStatus -> ClockTime
iStatStateReason :: InstStatus -> ReasonTrail
iStatStatus :: InstStatus -> DCStatus
loadInstStatus :: JSValue -> Result InstStatus
saveInstStatus :: InstStatus -> JSValue
data ReportData
ReportData :: [InstStatus] -> DCStatus -> ReportData
rDataInstances :: ReportData -> [InstStatus]
rDataStatus :: ReportData -> DCStatus
loadReportData :: JSValue -> Result ReportData
saveReportData :: ReportData -> JSValue
instance Show ReportData
instance Eq ReportData
instance JSON ReportData
instance ArrayObject ReportData
instance DictObject ReportData
instance Show InstStatus
instance Eq InstStatus
instance JSON InstStatus
instance ArrayObject InstStatus
instance DictObject InstStatus


-- | Implementation of the RPC client.
module Ganeti.Rpc
curlOpts :: [CurlOption]

-- | Data type for RPC error reporting.
data RpcError
CurlLayerError :: String -> RpcError
JsonDecodeError :: String -> RpcError
RpcResultError :: String -> RpcError
OfflineNodeError :: RpcError

-- | Provide explanation to RPC errors.
explainRpcError :: RpcError -> String
type ERpcError = Either RpcError

-- | A generic class for RPC calls.
class ArrayObject a => RpcCall a where rpcCallData _ = encode . JSArray . toJSArray
rpcCallName :: RpcCall a => a -> String
rpcCallTimeout :: RpcCall a => a -> Int
rpcCallData :: RpcCall a => Node -> a -> String
rpcCallAcceptOffline :: RpcCall a => a -> Bool

-- | Generic class that ensures matching RPC call with its respective
--   result.
class (RpcCall a, JSON b) => Rpc a b | a -> b, b -> a
rpcResultFill :: Rpc a b => a -> JSValue -> ERpcError b
data HttpClientRequest
HttpClientRequest :: String -> String -> [CurlOption] -> HttpClientRequest
requestUrl :: HttpClientRequest -> String
requestData :: HttpClientRequest -> String
requestOpts :: HttpClientRequest -> [CurlOption]
isIpV6 :: String -> Bool
prepareUrl :: RpcCall a => Int -> Node -> a -> String
prepareHttpRequest :: RpcCall a => Int -> [CurlOption] -> Node -> a -> ERpcError HttpClientRequest
parseHttpReply :: Rpc a b => a -> ERpcError (CurlCode, String) -> ERpcError b
parseHttpResponse :: Rpc a b => a -> String -> ERpcError b

-- | Scan the list of results produced by executeRpcCall and extract all
--   the RPC errors.
rpcErrors :: [(a, ERpcError b)] -> [(a, RpcError)]

-- | Scan the list of results produced by executeRpcCall and log all the
--   RPC errors. Returns the list of errors for further processing.
logRpcErrors :: (MonadLog m, Show a) => [(a, ERpcError b)] -> m [(a, RpcError)]
getOptionsForCall :: Rpc a b => FilePath -> FilePath -> a -> [CurlOption]
getNodedPort :: IO Int

-- | Execute multiple RPC calls in parallel
executeRpcCalls :: Rpc a b => [(Node, a)] -> IO [(Node, ERpcError b)]

-- | Execute an RPC call for many nodes in parallel.
executeRpcCall :: Rpc a b => [Node] -> a -> IO [(Node, ERpcError b)]
sanitizeDictResults :: [(String, Result a)] -> ERpcError [(String, a)]
fromJResultToRes :: Result a -> (a -> b) -> ERpcError b
fromJSValueToRes :: JSON a => JSValue -> (a -> b) -> ERpcError b

-- | An opaque data type for representing data that should be compressed
--   over the wire.
--   
--   On Python side it is decompressed by <tt>backend._Decompress</tt>.
newtype Compressed
Compressed :: ByteString -> Compressed
getCompressed :: Compressed -> ByteString
packCompressed :: ByteString -> Compressed
toCompressed :: String -> Compressed

-- | Returns information about a single instance
data RpcCallInstanceInfo
RpcCallInstanceInfo :: String -> Hypervisor -> RpcCallInstanceInfo
rpcCallInstInfoInstance :: RpcCallInstanceInfo -> String
rpcCallInstInfoHname :: RpcCallInstanceInfo -> Hypervisor
loadRpcCallInstanceInfo :: JSValue -> Result RpcCallInstanceInfo
saveRpcCallInstanceInfo :: RpcCallInstanceInfo -> JSValue
data InstanceState
InstanceStateRunning :: InstanceState
InstanceStateShutdown :: InstanceState
instanceStateFromRaw :: Monad m_a7vcH => Int -> m_a7vcH InstanceState
instanceStateToRaw :: InstanceState -> Int
_InstanceStateShutdown :: Int
_InstanceStateRunning :: Int
data InstanceInfo
InstanceInfo :: Int -> InstanceState -> Int -> Int -> InstanceInfo
instInfoMemory :: InstanceInfo -> Int
instInfoState :: InstanceInfo -> InstanceState
instInfoVcpus :: InstanceInfo -> Int
instInfoTime :: InstanceInfo -> Int
loadInstanceInfo :: JSValue -> Result InstanceInfo
saveInstanceInfo :: InstanceInfo -> JSValue
data RpcResultInstanceInfo
RpcResultInstanceInfo :: Maybe InstanceInfo -> RpcResultInstanceInfo
rpcResInstInfoInstInfo :: RpcResultInstanceInfo -> Maybe InstanceInfo
loadRpcResultInstanceInfo :: JSValue -> Result RpcResultInstanceInfo
saveRpcResultInstanceInfo :: RpcResultInstanceInfo -> JSValue

-- | Returns information about all running instances on the given nodes
data RpcCallAllInstancesInfo
RpcCallAllInstancesInfo :: [(Hypervisor, HvParams)] -> RpcCallAllInstancesInfo
rpcCallAllInstInfoHypervisors :: RpcCallAllInstancesInfo -> [(Hypervisor, HvParams)]
loadRpcCallAllInstancesInfo :: JSValue -> Result RpcCallAllInstancesInfo
saveRpcCallAllInstancesInfo :: RpcCallAllInstancesInfo -> JSValue
data RpcResultAllInstancesInfo
RpcResultAllInstancesInfo :: [(String, InstanceInfo)] -> RpcResultAllInstancesInfo
rpcResAllInstInfoInstances :: RpcResultAllInstancesInfo -> [(String, InstanceInfo)]
loadRpcResultAllInstancesInfo :: JSValue -> Result RpcResultAllInstancesInfo
saveRpcResultAllInstancesInfo :: RpcResultAllInstancesInfo -> JSValue

-- | Returns information about how to access instances on the given node
data InstanceConsoleInfoParams
InstanceConsoleInfoParams :: Instance -> Node -> NodeGroup -> HvParams -> FilledBeParams -> InstanceConsoleInfoParams
instConsInfoParamsInstance :: InstanceConsoleInfoParams -> Instance
instConsInfoParamsNode :: InstanceConsoleInfoParams -> Node
instConsInfoParamsGroup :: InstanceConsoleInfoParams -> NodeGroup
instConsInfoParamsHvParams :: InstanceConsoleInfoParams -> HvParams
instConsInfoParamsBeParams :: InstanceConsoleInfoParams -> FilledBeParams
loadInstanceConsoleInfoParams :: JSValue -> Result InstanceConsoleInfoParams
saveInstanceConsoleInfoParams :: InstanceConsoleInfoParams -> JSValue
data RpcCallInstanceConsoleInfo
RpcCallInstanceConsoleInfo :: [(String, InstanceConsoleInfoParams)] -> RpcCallInstanceConsoleInfo
rpcCallInstConsInfoInstanceInfo :: RpcCallInstanceConsoleInfo -> [(String, InstanceConsoleInfoParams)]
loadRpcCallInstanceConsoleInfo :: JSValue -> Result RpcCallInstanceConsoleInfo
saveRpcCallInstanceConsoleInfo :: RpcCallInstanceConsoleInfo -> JSValue
data InstanceConsoleInfo
InstanceConsoleInfo :: String -> String -> Maybe String -> Maybe String -> Maybe Int -> Maybe String -> Maybe [String] -> Maybe String -> InstanceConsoleInfo
instConsInfoInstance :: InstanceConsoleInfo -> String
instConsInfoKind :: InstanceConsoleInfo -> String
instConsInfoMessage :: InstanceConsoleInfo -> Maybe String
instConsInfoHost :: InstanceConsoleInfo -> Maybe String
instConsInfoPort :: InstanceConsoleInfo -> Maybe Int
instConsInfoUser :: InstanceConsoleInfo -> Maybe String
instConsInfoCommand :: InstanceConsoleInfo -> Maybe [String]
instConsInfoDisplay :: InstanceConsoleInfo -> Maybe String
loadInstanceConsoleInfo :: JSValue -> Result InstanceConsoleInfo
saveInstanceConsoleInfo :: InstanceConsoleInfo -> JSValue
data RpcResultInstanceConsoleInfo
RpcResultInstanceConsoleInfo :: [(String, InstanceConsoleInfo)] -> RpcResultInstanceConsoleInfo
rpcResInstConsInfoInstancesInfo :: RpcResultInstanceConsoleInfo -> [(String, InstanceConsoleInfo)]
loadRpcResultInstanceConsoleInfo :: JSValue -> Result RpcResultInstanceConsoleInfo
saveRpcResultInstanceConsoleInfo :: RpcResultInstanceConsoleInfo -> JSValue

-- | Returns the list of running instances on the given nodes
data RpcCallInstanceList
RpcCallInstanceList :: [Hypervisor] -> RpcCallInstanceList
rpcCallInstListHypervisors :: RpcCallInstanceList -> [Hypervisor]
loadRpcCallInstanceList :: JSValue -> Result RpcCallInstanceList
saveRpcCallInstanceList :: RpcCallInstanceList -> JSValue
data RpcResultInstanceList
RpcResultInstanceList :: [String] -> RpcResultInstanceList
rpcResInstListInstances :: RpcResultInstanceList -> [String]
loadRpcResultInstanceList :: JSValue -> Result RpcResultInstanceList
saveRpcResultInstanceList :: RpcResultInstanceList -> JSValue

-- | Returns node information
data RpcCallNodeInfo
RpcCallNodeInfo :: Map String [StorageUnit] -> [(Hypervisor, HvParams)] -> RpcCallNodeInfo
rpcCallNodeInfoStorageUnits :: RpcCallNodeInfo -> Map String [StorageUnit]
rpcCallNodeInfoHypervisors :: RpcCallNodeInfo -> [(Hypervisor, HvParams)]
loadRpcCallNodeInfo :: JSValue -> Result RpcCallNodeInfo
saveRpcCallNodeInfo :: RpcCallNodeInfo -> JSValue
data StorageInfo
StorageInfo :: String -> String -> Maybe Int -> Maybe Int -> StorageInfo
storageInfoName :: StorageInfo -> String
storageInfoType :: StorageInfo -> String
storageInfoStorageFree :: StorageInfo -> Maybe Int
storageInfoStorageSize :: StorageInfo -> Maybe Int
loadStorageInfo :: JSValue -> Result StorageInfo
saveStorageInfo :: StorageInfo -> JSValue

-- | Common fields (as described in hv_base.py) are mandatory, other fields
--   are optional.
data HvInfo
HvInfo :: Maybe [Int] -> Int -> Int -> Int -> Maybe Int -> Int -> Int -> Int -> Int -> HvInfo
hvInfoHvVersion :: HvInfo -> Maybe [Int]
hvInfoMemoryTotal :: HvInfo -> Int
hvInfoMemoryFree :: HvInfo -> Int
hvInfoMemoryDom0 :: HvInfo -> Int
hvInfoMemoryHv :: HvInfo -> Maybe Int
hvInfoCpuTotal :: HvInfo -> Int
hvInfoCpuNodes :: HvInfo -> Int
hvInfoCpuSockets :: HvInfo -> Int
hvInfoCpuDom0 :: HvInfo -> Int
loadHvInfo :: JSValue -> Result HvInfo
saveHvInfo :: HvInfo -> JSValue
data RpcResultNodeInfo
RpcResultNodeInfo :: String -> [StorageInfo] -> [HvInfo] -> RpcResultNodeInfo
rpcResNodeInfoBootId :: RpcResultNodeInfo -> String
rpcResNodeInfoStorageInfo :: RpcResultNodeInfo -> [StorageInfo]
rpcResNodeInfoHvInfo :: RpcResultNodeInfo -> [HvInfo]
loadRpcResultNodeInfo :: JSValue -> Result RpcResultNodeInfo
saveRpcResultNodeInfo :: RpcResultNodeInfo -> JSValue

-- | Query node version.
data RpcCallVersion
RpcCallVersion :: RpcCallVersion
loadRpcCallVersion :: JSValue -> Result RpcCallVersion
saveRpcCallVersion :: RpcCallVersion -> JSValue

-- | Query node reply.
data RpcResultVersion
RpcResultVersion :: Int -> RpcResultVersion
rpcResultVersionVersion :: RpcResultVersion -> Int
loadRpcResultVersion :: JSValue -> Result RpcResultVersion
saveRpcResultVersion :: RpcResultVersion -> JSValue
data RpcCallStorageList
RpcCallStorageList :: StorageType -> [String] -> String -> [StorageField] -> RpcCallStorageList
rpcCallStorageListSuName :: RpcCallStorageList -> StorageType
rpcCallStorageListSuArgs :: RpcCallStorageList -> [String]
rpcCallStorageListName :: RpcCallStorageList -> String
rpcCallStorageListFields :: RpcCallStorageList -> [StorageField]
loadRpcCallStorageList :: JSValue -> Result RpcCallStorageList
saveRpcCallStorageList :: RpcCallStorageList -> JSValue
data RpcResultStorageList
RpcResultStorageList :: [[(StorageField, JSValue)]] -> RpcResultStorageList
rpcResStorageListStorage :: RpcResultStorageList -> [[(StorageField, JSValue)]]
loadRpcResultStorageList :: JSValue -> Result RpcResultStorageList
saveRpcResultStorageList :: RpcResultStorageList -> JSValue

-- | Call definition for test delay.
data RpcCallTestDelay
RpcCallTestDelay :: Double -> RpcCallTestDelay
rpcCallTestDelayDuration :: RpcCallTestDelay -> Double
loadRpcCallTestDelay :: JSValue -> Result RpcCallTestDelay
saveRpcCallTestDelay :: RpcCallTestDelay -> JSValue

-- | Result definition for test delay.
data RpcResultTestDelay
RpcResultTestDelay :: RpcResultTestDelay

-- | Call definition for export list.
data RpcCallExportList
RpcCallExportList :: RpcCallExportList
loadRpcCallExportList :: JSValue -> Result RpcCallExportList
saveRpcCallExportList :: RpcCallExportList -> JSValue

-- | Result definition for export list.
data RpcResultExportList
RpcResultExportList :: [String] -> RpcResultExportList
rpcResExportListExports :: RpcResultExportList -> [String]
loadRpcResultExportList :: JSValue -> Result RpcResultExportList
saveRpcResultExportList :: RpcResultExportList -> JSValue

-- | Update a job queue file
data RpcCallJobqueueUpdate
RpcCallJobqueueUpdate :: String -> String -> RpcCallJobqueueUpdate
rpcCallJobqueueUpdateFileName :: RpcCallJobqueueUpdate -> String
rpcCallJobqueueUpdateContent :: RpcCallJobqueueUpdate -> String
loadRpcCallJobqueueUpdate :: JSValue -> Result RpcCallJobqueueUpdate
saveRpcCallJobqueueUpdate :: RpcCallJobqueueUpdate -> JSValue
data RpcResultJobQueueUpdate
RpcResultJobQueueUpdate :: RpcResultJobQueueUpdate
loadRpcResultJobQueueUpdate :: JSValue -> Result RpcResultJobQueueUpdate
saveRpcResultJobQueueUpdate :: RpcResultJobQueueUpdate -> JSValue

-- | Rename a file in the job queue
data RpcCallJobqueueRename
RpcCallJobqueueRename :: [(String, String)] -> RpcCallJobqueueRename
rpcCallJobqueueRenameRename :: RpcCallJobqueueRename -> [(String, String)]
loadRpcCallJobqueueRename :: JSValue -> Result RpcCallJobqueueRename
saveRpcCallJobqueueRename :: RpcCallJobqueueRename -> JSValue
data RpcResultJobqueueRename
RpcResultJobqueueRename :: RpcResultJobqueueRename
loadRpcResultJobqueueRename :: JSValue -> Result RpcResultJobqueueRename
saveRpcResultJobqueueRename :: RpcResultJobqueueRename -> JSValue

-- | Set the watcher status
data RpcCallSetWatcherPause
RpcCallSetWatcherPause :: Maybe ClockTime -> RpcCallSetWatcherPause
rpcCallSetWatcherPauseTime :: RpcCallSetWatcherPause -> Maybe ClockTime
loadRpcCallSetWatcherPause :: JSValue -> Result RpcCallSetWatcherPause
saveRpcCallSetWatcherPause :: RpcCallSetWatcherPause -> JSValue
data RpcResultSetWatcherPause
RpcResultSetWatcherPause :: RpcResultSetWatcherPause
loadRpcResultSetWatcherPause :: JSValue -> Result RpcResultSetWatcherPause
saveRpcResultSetWatcherPause :: RpcResultSetWatcherPause -> JSValue

-- | Set the queu drain flag
data RpcCallSetDrainFlag
RpcCallSetDrainFlag :: Bool -> RpcCallSetDrainFlag
rpcCallSetDrainFlagValue :: RpcCallSetDrainFlag -> Bool
loadRpcCallSetDrainFlag :: JSValue -> Result RpcCallSetDrainFlag
saveRpcCallSetDrainFlag :: RpcCallSetDrainFlag -> JSValue
data RpcResultSetDrainFlag
RpcResultSetDrainFlag :: RpcResultSetDrainFlag
loadRpcResultSetDrainFlag :: JSValue -> Result RpcResultSetDrainFlag
saveRpcResultSetDrainFlag :: RpcResultSetDrainFlag -> JSValue

-- | Upload a configuration file to nodes
data RpcCallUploadFile
RpcCallUploadFile :: FilePath -> Compressed -> Maybe FileMode -> String -> String -> ClockTime -> ClockTime -> RpcCallUploadFile
rpcCallUploadFileFileName :: RpcCallUploadFile -> FilePath
rpcCallUploadFileContent :: RpcCallUploadFile -> Compressed
rpcCallUploadFileMode :: RpcCallUploadFile -> Maybe FileMode
rpcCallUploadFileUid :: RpcCallUploadFile -> String
rpcCallUploadFileGid :: RpcCallUploadFile -> String
rpcCallUploadFileAtime :: RpcCallUploadFile -> ClockTime
rpcCallUploadFileMtime :: RpcCallUploadFile -> ClockTime
loadRpcCallUploadFile :: JSValue -> Result RpcCallUploadFile
saveRpcCallUploadFile :: RpcCallUploadFile -> JSValue
data RpcResultUploadFile
RpcResultUploadFile :: RpcResultUploadFile
loadRpcResultUploadFile :: JSValue -> Result RpcResultUploadFile
saveRpcResultUploadFile :: RpcResultUploadFile -> JSValue

-- | Reads a file and constructs the corresponding <a>RpcCallUploadFile</a>
--   value.
prepareRpcCallUploadFile :: RuntimeEnts -> FilePath -> ResultG RpcCallUploadFile

-- | Upload ssconf files to nodes
data RpcCallWriteSsconfFiles
RpcCallWriteSsconfFiles :: SSConf -> RpcCallWriteSsconfFiles
rpcCallWriteSsconfFilesValues :: RpcCallWriteSsconfFiles -> SSConf
loadRpcCallWriteSsconfFiles :: JSValue -> Result RpcCallWriteSsconfFiles
saveRpcCallWriteSsconfFiles :: RpcCallWriteSsconfFiles -> JSValue
data RpcResultWriteSsconfFiles
RpcResultWriteSsconfFiles :: RpcResultWriteSsconfFiles
loadRpcResultWriteSsconfFiles :: JSValue -> Result RpcResultWriteSsconfFiles
saveRpcResultWriteSsconfFiles :: RpcResultWriteSsconfFiles -> JSValue

-- | Activate the master IP address
data RpcCallNodeActivateMasterIp
RpcCallNodeActivateMasterIp :: MasterNetworkParameters -> Bool -> RpcCallNodeActivateMasterIp
rpcCallNodeActivateMasterIpParams :: RpcCallNodeActivateMasterIp -> MasterNetworkParameters
rpcCallNodeActivateMasterIpEms :: RpcCallNodeActivateMasterIp -> Bool
loadRpcCallNodeActivateMasterIp :: JSValue -> Result RpcCallNodeActivateMasterIp
saveRpcCallNodeActivateMasterIp :: RpcCallNodeActivateMasterIp -> JSValue
data RpcResultNodeActivateMasterIp
RpcResultNodeActivateMasterIp :: RpcResultNodeActivateMasterIp
loadRpcResultNodeActivateMasterIp :: JSValue -> Result RpcResultNodeActivateMasterIp
saveRpcResultNodeActivateMasterIp :: RpcResultNodeActivateMasterIp -> JSValue

-- | Ask who the node believes is the master.
data RpcCallMasterNodeName
RpcCallMasterNodeName :: RpcCallMasterNodeName
loadRpcCallMasterNodeName :: JSValue -> Result RpcCallMasterNodeName
saveRpcCallMasterNodeName :: RpcCallMasterNodeName -> JSValue
data RpcResultMasterNodeName
RpcResultMasterNodeName :: String -> RpcResultMasterNodeName
rpcResultMasterNodeNameMaster :: RpcResultMasterNodeName -> String
loadRpcResultMasterNodeName :: JSValue -> Result RpcResultMasterNodeName
saveRpcResultMasterNodeName :: RpcResultMasterNodeName -> JSValue
instance Show RpcResultMasterNodeName
instance Eq RpcResultMasterNodeName
instance Rpc RpcCallMasterNodeName RpcResultMasterNodeName
instance JSON RpcResultMasterNodeName
instance ArrayObject RpcResultMasterNodeName
instance DictObject RpcResultMasterNodeName
instance Show RpcCallMasterNodeName
instance Eq RpcCallMasterNodeName
instance RpcCall RpcCallMasterNodeName
instance JSON RpcCallMasterNodeName
instance ArrayObject RpcCallMasterNodeName
instance DictObject RpcCallMasterNodeName
instance Show RpcResultNodeActivateMasterIp
instance Eq RpcResultNodeActivateMasterIp
instance Rpc RpcCallNodeActivateMasterIp RpcResultNodeActivateMasterIp
instance JSON RpcResultNodeActivateMasterIp
instance ArrayObject RpcResultNodeActivateMasterIp
instance DictObject RpcResultNodeActivateMasterIp
instance Show RpcCallNodeActivateMasterIp
instance Eq RpcCallNodeActivateMasterIp
instance RpcCall RpcCallNodeActivateMasterIp
instance JSON RpcCallNodeActivateMasterIp
instance ArrayObject RpcCallNodeActivateMasterIp
instance DictObject RpcCallNodeActivateMasterIp
instance Show RpcResultWriteSsconfFiles
instance Eq RpcResultWriteSsconfFiles
instance Rpc RpcCallWriteSsconfFiles RpcResultWriteSsconfFiles
instance JSON RpcResultWriteSsconfFiles
instance ArrayObject RpcResultWriteSsconfFiles
instance DictObject RpcResultWriteSsconfFiles
instance Show RpcCallWriteSsconfFiles
instance Eq RpcCallWriteSsconfFiles
instance RpcCall RpcCallWriteSsconfFiles
instance JSON RpcCallWriteSsconfFiles
instance ArrayObject RpcCallWriteSsconfFiles
instance DictObject RpcCallWriteSsconfFiles
instance Show RpcResultUploadFile
instance Eq RpcResultUploadFile
instance Rpc RpcCallUploadFile RpcResultUploadFile
instance JSON RpcResultUploadFile
instance ArrayObject RpcResultUploadFile
instance DictObject RpcResultUploadFile
instance Show RpcCallUploadFile
instance Eq RpcCallUploadFile
instance RpcCall RpcCallUploadFile
instance JSON RpcCallUploadFile
instance ArrayObject RpcCallUploadFile
instance DictObject RpcCallUploadFile
instance Show RpcResultSetDrainFlag
instance Eq RpcResultSetDrainFlag
instance Rpc RpcCallSetDrainFlag RpcResultSetDrainFlag
instance JSON RpcResultSetDrainFlag
instance ArrayObject RpcResultSetDrainFlag
instance DictObject RpcResultSetDrainFlag
instance Show RpcCallSetDrainFlag
instance Eq RpcCallSetDrainFlag
instance RpcCall RpcCallSetDrainFlag
instance JSON RpcCallSetDrainFlag
instance ArrayObject RpcCallSetDrainFlag
instance DictObject RpcCallSetDrainFlag
instance Show RpcResultSetWatcherPause
instance Eq RpcResultSetWatcherPause
instance Rpc RpcCallSetWatcherPause RpcResultSetWatcherPause
instance JSON RpcResultSetWatcherPause
instance ArrayObject RpcResultSetWatcherPause
instance DictObject RpcResultSetWatcherPause
instance Show RpcCallSetWatcherPause
instance Eq RpcCallSetWatcherPause
instance RpcCall RpcCallSetWatcherPause
instance JSON RpcCallSetWatcherPause
instance ArrayObject RpcCallSetWatcherPause
instance DictObject RpcCallSetWatcherPause
instance Show RpcResultJobqueueRename
instance Eq RpcResultJobqueueRename
instance Rpc RpcCallJobqueueRename RpcResultJobqueueRename
instance RpcCall RpcCallJobqueueRename
instance JSON RpcResultJobqueueRename
instance ArrayObject RpcResultJobqueueRename
instance DictObject RpcResultJobqueueRename
instance Show RpcCallJobqueueRename
instance Eq RpcCallJobqueueRename
instance JSON RpcCallJobqueueRename
instance ArrayObject RpcCallJobqueueRename
instance DictObject RpcCallJobqueueRename
instance Show RpcResultJobQueueUpdate
instance Eq RpcResultJobQueueUpdate
instance Rpc RpcCallJobqueueUpdate RpcResultJobQueueUpdate
instance RpcCall RpcCallJobqueueUpdate
instance JSON RpcResultJobQueueUpdate
instance ArrayObject RpcResultJobQueueUpdate
instance DictObject RpcResultJobQueueUpdate
instance Show RpcCallJobqueueUpdate
instance Eq RpcCallJobqueueUpdate
instance JSON RpcCallJobqueueUpdate
instance ArrayObject RpcCallJobqueueUpdate
instance DictObject RpcCallJobqueueUpdate
instance Show RpcResultExportList
instance Eq RpcResultExportList
instance Rpc RpcCallExportList RpcResultExportList
instance RpcCall RpcCallExportList
instance JSON RpcResultExportList
instance ArrayObject RpcResultExportList
instance DictObject RpcResultExportList
instance Show RpcCallExportList
instance Eq RpcCallExportList
instance JSON RpcCallExportList
instance ArrayObject RpcCallExportList
instance DictObject RpcCallExportList
instance Show RpcCallTestDelay
instance Eq RpcCallTestDelay
instance Show RpcResultTestDelay
instance Rpc RpcCallTestDelay RpcResultTestDelay
instance RpcCall RpcCallTestDelay
instance JSON RpcResultTestDelay
instance JSON RpcCallTestDelay
instance ArrayObject RpcCallTestDelay
instance DictObject RpcCallTestDelay
instance Show RpcResultStorageList
instance Eq RpcResultStorageList
instance Rpc RpcCallStorageList RpcResultStorageList
instance RpcCall RpcCallStorageList
instance JSON RpcResultStorageList
instance ArrayObject RpcResultStorageList
instance DictObject RpcResultStorageList
instance Show RpcCallStorageList
instance Eq RpcCallStorageList
instance JSON RpcCallStorageList
instance ArrayObject RpcCallStorageList
instance DictObject RpcCallStorageList
instance Show RpcResultVersion
instance Eq RpcResultVersion
instance Rpc RpcCallVersion RpcResultVersion
instance RpcCall RpcCallVersion
instance JSON RpcResultVersion
instance ArrayObject RpcResultVersion
instance DictObject RpcResultVersion
instance Show RpcCallVersion
instance Eq RpcCallVersion
instance JSON RpcCallVersion
instance ArrayObject RpcCallVersion
instance DictObject RpcCallVersion
instance Show RpcResultNodeInfo
instance Eq RpcResultNodeInfo
instance Rpc RpcCallNodeInfo RpcResultNodeInfo
instance RpcCall RpcCallNodeInfo
instance JSON RpcResultNodeInfo
instance ArrayObject RpcResultNodeInfo
instance DictObject RpcResultNodeInfo
instance Show HvInfo
instance Eq HvInfo
instance JSON HvInfo
instance ArrayObject HvInfo
instance DictObject HvInfo
instance Show StorageInfo
instance Eq StorageInfo
instance JSON StorageInfo
instance ArrayObject StorageInfo
instance DictObject StorageInfo
instance Show RpcCallNodeInfo
instance Eq RpcCallNodeInfo
instance JSON RpcCallNodeInfo
instance ArrayObject RpcCallNodeInfo
instance DictObject RpcCallNodeInfo
instance Show RpcResultInstanceList
instance Eq RpcResultInstanceList
instance Rpc RpcCallInstanceList RpcResultInstanceList
instance RpcCall RpcCallInstanceList
instance JSON RpcResultInstanceList
instance ArrayObject RpcResultInstanceList
instance DictObject RpcResultInstanceList
instance Show RpcCallInstanceList
instance Eq RpcCallInstanceList
instance JSON RpcCallInstanceList
instance ArrayObject RpcCallInstanceList
instance DictObject RpcCallInstanceList
instance Show RpcResultInstanceConsoleInfo
instance Eq RpcResultInstanceConsoleInfo
instance Rpc RpcCallInstanceConsoleInfo RpcResultInstanceConsoleInfo
instance RpcCall RpcCallInstanceConsoleInfo
instance JSON RpcResultInstanceConsoleInfo
instance ArrayObject RpcResultInstanceConsoleInfo
instance DictObject RpcResultInstanceConsoleInfo
instance Show InstanceConsoleInfo
instance Eq InstanceConsoleInfo
instance JSON InstanceConsoleInfo
instance ArrayObject InstanceConsoleInfo
instance DictObject InstanceConsoleInfo
instance Show RpcCallInstanceConsoleInfo
instance Eq RpcCallInstanceConsoleInfo
instance JSON RpcCallInstanceConsoleInfo
instance ArrayObject RpcCallInstanceConsoleInfo
instance DictObject RpcCallInstanceConsoleInfo
instance Show InstanceConsoleInfoParams
instance Eq InstanceConsoleInfoParams
instance JSON InstanceConsoleInfoParams
instance ArrayObject InstanceConsoleInfoParams
instance DictObject InstanceConsoleInfoParams
instance Show RpcResultAllInstancesInfo
instance Eq RpcResultAllInstancesInfo
instance Rpc RpcCallAllInstancesInfo RpcResultAllInstancesInfo
instance RpcCall RpcCallAllInstancesInfo
instance JSON RpcResultAllInstancesInfo
instance ArrayObject RpcResultAllInstancesInfo
instance DictObject RpcResultAllInstancesInfo
instance Show RpcCallAllInstancesInfo
instance Eq RpcCallAllInstancesInfo
instance JSON RpcCallAllInstancesInfo
instance ArrayObject RpcCallAllInstancesInfo
instance DictObject RpcCallAllInstancesInfo
instance Show RpcResultInstanceInfo
instance Eq RpcResultInstanceInfo
instance Rpc RpcCallInstanceInfo RpcResultInstanceInfo
instance RpcCall RpcCallInstanceInfo
instance JSON RpcResultInstanceInfo
instance ArrayObject RpcResultInstanceInfo
instance DictObject RpcResultInstanceInfo
instance Show InstanceInfo
instance Eq InstanceInfo
instance JSON InstanceInfo
instance ArrayObject InstanceInfo
instance DictObject InstanceInfo
instance PyValue InstanceState
instance JSON InstanceState
instance Show InstanceState
instance Eq InstanceState
instance Enum InstanceState
instance Bounded InstanceState
instance Ord InstanceState
instance Show RpcCallInstanceInfo
instance Eq RpcCallInstanceInfo
instance JSON RpcCallInstanceInfo
instance ArrayObject RpcCallInstanceInfo
instance DictObject RpcCallInstanceInfo
instance Show RpcError
instance Eq RpcError
instance Eq Compressed
instance Ord Compressed
instance Show Compressed
instance JSON Compressed


-- | Utility functions for complex operations carried out by several
--   daemons.
module Ganeti.Daemon.Utils
verifyMasterVotes :: IO (Result Bool)

-- | Verify, by voting, that this node is the master. Bad if we're not.
--   Allow the given number of retries to wait for not available nodes.
verifyMaster :: Int -> IO (Result ())

-- | Verify master position according to the options provided, usually by
--   carrying out a voting. Either return unit on success, or a suggested
--   exit code.
handleMasterVerificationOptions :: DaemonOptions -> IO (Either ExitCode ())


-- | Instance status data collector.
module Ganeti.DataCollectors.InstStatus

-- | The name of this data collector.
dcName :: String

-- | The version of this data collector.
dcVersion :: DCVersion

-- | The version number for the data format of this data collector.
dcFormatVersion :: Int

-- | The category of this data collector.
dcCategory :: Maybe DCCategory

-- | The kind of this data collector.
dcKind :: DCKind

-- | The report of this data collector.
dcReport :: IO DCReport
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
getReasonTrail :: String -> IO ReasonTrail
computeStatusField :: AdminState -> ActualState -> DCStatus
buildStatus :: Map String Domain -> Map Int UptimeInfo -> RealInstanceData -> IO InstStatus
computeGlobalStatus :: [InstStatus] -> DCStatus
buildInstStatusReport :: Maybe String -> Maybe Int -> IO DCReport

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Logical Volumes data collector.
module Ganeti.DataCollectors.Lv
defaultCharNum :: Int

-- | The name of this data collector.
dcName :: String

-- | The version of this data collector.
dcVersion :: DCVersion

-- | The version number for the data format of this data collector.
dcFormatVersion :: Int

-- | The category of this data collector.
dcCategory :: Maybe DCCategory

-- | The kind of this data collector.
dcKind :: DCKind

-- | The data exported by the data collector, taken from the default
--   location.
dcReport :: IO DCReport
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
getLvInfo :: Maybe FilePath -> IO [LVInfo]
getInstDiskList :: Options -> IO [(RealInstanceData, [Disk])]
addInstNameToOneLv :: [(RealInstanceData, [Disk])] -> LVInfo -> LVInfo
addInstNameToLv :: [(RealInstanceData, [Disk])] -> [LVInfo] -> [LVInfo]
buildJsonReport :: Options -> IO JSValue
buildDCReport :: Options -> IO DCReport

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Definition of the data collectors used by MonD.
module Ganeti.DataCollectors

-- | The list of available builtin data collectors.
collectors :: [DataCollector]


-- | Implementation of the Ganeti confd server functionality.
module Ganeti.Confd.Server
type CRef = IORef (Result (ConfigData, LinkIpMap))
type StatusAnswer = (ConfdReplyStatus, JSValue, Int)
queryUnknownEntry :: StatusAnswer
queryArgumentError :: StatusAnswer
gntErrorToResult :: ErrorResult a -> Result a
nodeRole :: ConfigData -> String -> Result ConfdNodeRole
getNodePipByInstanceIp :: ConfigData -> LinkIpMap -> String -> String -> StatusAnswer
uuidToNodeName :: ConfigData -> String -> Result String
encodeMinors :: ConfigData -> (String, Int, String, String, String, String) -> Result JSValue
buildResponse :: (ConfigData, LinkIpMap) -> ConfdRequest -> Result StatusAnswer
serializeResponse :: Result StatusAnswer -> ConfdReply
responder :: CRef -> Socket -> HashKey -> String -> SockAddr -> IO ()
respondInner :: Result (ConfigData, LinkIpMap) -> HashKey -> ConfdRequest -> String
listener :: Socket -> HashKey -> (Socket -> HashKey -> String -> SockAddr -> IO ()) -> IO ()
type PrepResult = (Socket, IORef (Result (ConfigData, LinkIpMap)))

-- | Check function for confd.
checkMain :: CheckFn (Family, SockAddr)

-- | Prepare function for confd.
prepMain :: PrepFn (Family, SockAddr) PrepResult

-- | Main function.
main :: MainFn (Family, SockAddr) PrepResult


-- | Small module holding program definitions for data collectors.
module Ganeti.DataCollectors.Program

-- | Supported binaries.
personalities :: PersonalityList Options


-- | Implementation of the Ganeti LUXI interface.
module Ganeti.Luxi

-- | Currently supported Luxi operations and JSON serialization.
data LuxiOp
Query :: ItemType -> [String] -> Filter FilterField -> LuxiOp
QueryFields :: ItemType -> [String] -> LuxiOp
QueryNodes :: [String] -> [String] -> Bool -> LuxiOp
QueryGroups :: [String] -> [String] -> Bool -> LuxiOp
QueryNetworks :: [String] -> [String] -> Bool -> LuxiOp
QueryInstances :: [String] -> [String] -> Bool -> LuxiOp
QueryFilters :: [String] -> [String] -> LuxiOp
ReplaceFilter :: Maybe String -> NonNegative Int -> [FilterPredicate] -> FilterAction -> ReasonTrail -> LuxiOp
DeleteFilter :: String -> LuxiOp
QueryJobs :: [JobId] -> [String] -> LuxiOp
QueryExports :: [String] -> Bool -> LuxiOp
QueryConfigValues :: [String] -> LuxiOp
QueryClusterInfo :: LuxiOp
QueryTags :: TagKind -> String -> LuxiOp
SubmitJob :: [MetaOpCode] -> LuxiOp
SubmitJobToDrainedQueue :: [MetaOpCode] -> LuxiOp
SubmitManyJobs :: [[MetaOpCode]] -> LuxiOp
WaitForJobChange :: JobId -> [String] -> JSValue -> JSValue -> Int -> LuxiOp
PickupJob :: JobId -> LuxiOp
ArchiveJob :: JobId -> LuxiOp
AutoArchiveJobs :: Int -> Int -> LuxiOp
CancelJob :: JobId -> Bool -> LuxiOp
ChangeJobPriority :: JobId -> Int -> LuxiOp
SetDrainFlag :: Bool -> LuxiOp
SetWatcherPause :: Maybe ClockTime -> LuxiOp
data LuxiReq
ReqQuery :: LuxiReq
ReqQueryFields :: LuxiReq
ReqQueryNodes :: LuxiReq
ReqQueryGroups :: LuxiReq
ReqQueryNetworks :: LuxiReq
ReqQueryInstances :: LuxiReq
ReqQueryFilters :: LuxiReq
ReqReplaceFilter :: LuxiReq
ReqDeleteFilter :: LuxiReq
ReqQueryJobs :: LuxiReq
ReqQueryExports :: LuxiReq
ReqQueryConfigValues :: LuxiReq
ReqQueryClusterInfo :: LuxiReq
ReqQueryTags :: LuxiReq
ReqSubmitJob :: LuxiReq
ReqSubmitJobToDrainedQueue :: LuxiReq
ReqSubmitManyJobs :: LuxiReq
ReqWaitForJobChange :: LuxiReq
ReqPickupJob :: LuxiReq
ReqArchiveJob :: LuxiReq
ReqAutoArchiveJobs :: LuxiReq
ReqCancelJob :: LuxiReq
ReqChangeJobPriority :: LuxiReq
ReqSetDrainFlag :: LuxiReq
ReqSetWatcherPause :: LuxiReq
luxiReqFromRaw :: Monad m_a7URw => String -> m_a7URw LuxiReq
luxiReqToRaw :: LuxiReq -> String
opToArgs :: LuxiOp -> JSValue

-- | List of all defined Luxi calls.
allLuxiCalls :: [String]

-- | The serialisation of LuxiOps into strings in messages.
strOfOp :: LuxiOp -> String
luxiConnectConfig :: ServerConfig

-- | Connects to the master daemon and returns a luxi Client.
getLuxiClient :: String -> IO Client

-- | Creates and returns a server endpoint.
getLuxiServer :: Bool -> FilePath -> IO Server

-- | Converts Luxi call arguments into a <a>LuxiOp</a> data structure. This
--   is used for building a Luxi <a>Handler</a>.
--   
--   This is currently hand-coded until we make it more uniform so that it
--   can be generated using TH.
decodeLuxiCall :: JSValue -> JSValue -> Result LuxiOp

-- | Generic luxi method call
callMethod :: LuxiOp -> Client -> IO (ErrorResult JSValue)
parseSubmitJobResult :: JSValue -> ErrorResult JobId

-- | Specialized submitManyJobs call.
submitManyJobs :: Client -> [[MetaOpCode]] -> IO (ErrorResult [JobId])

-- | Custom queryJobs call.
queryJobsStatus :: Client -> [JobId] -> IO (ErrorResult [JobStatus])
instance JSON LuxiReq
instance Show LuxiOp
instance Eq LuxiOp
instance Show LuxiReq
instance Eq LuxiReq
instance Enum LuxiReq
instance Bounded LuxiReq
instance Ord LuxiReq
instance DictObject LuxiOp


-- | Implementation of the LUXI loader.
module Ganeti.HTools.Backend.Luxi
getData :: Monad m => JSValue -> m JSValue
parseQueryField :: Monad m => JSValue -> m (JSValue, JSValue)
parseQueryRow :: Monad m => JSValue -> m [(JSValue, JSValue)]
parseQueryResult :: Monad m => JSValue -> m [[(JSValue, JSValue)]]
extractArray :: Monad m => JSValue -> m [[(JSValue, JSValue)]]
fromJValWithStatus :: (JSON a, Monad m) => (JSValue, JSValue) -> m a
annotateConvert :: String -> String -> String -> Result a -> Result a
genericConvert :: JSON a => String -> String -> String -> (JSValue, JSValue) -> Result a
convertArrayMaybe :: JSON a => String -> String -> String -> (JSValue, JSValue) -> Result [Maybe a]
queryNodesMsg :: LuxiOp
queryInstancesMsg :: LuxiOp
queryClusterInfoMsg :: LuxiOp
queryGroupsMsg :: LuxiOp
queryNodes :: Client -> IO (Result JSValue)
queryInstances :: Client -> IO (Result JSValue)
queryClusterInfo :: Client -> IO (Result JSValue)
queryGroups :: Client -> IO (Result JSValue)
getInstances :: NameAssoc -> JSValue -> Result [(String, Instance)]
parseInstance :: NameAssoc -> [(JSValue, JSValue)] -> Result (String, Instance)
getNodes :: NameAssoc -> JSValue -> Result [(String, Node)]
parseNode :: NameAssoc -> [(JSValue, JSValue)] -> Result (String, Node)
getClusterData :: JSValue -> Result ([String], IPolicy, String)
getGroups :: JSValue -> Result [(String, Group)]
parseGroup :: [(JSValue, JSValue)] -> Result (String, Group)
readData :: String -> IO (Result JSValue, Result JSValue, Result JSValue, Result JSValue)

-- | Converts the output of <a>readData</a> into the internal cluster
--   representation.
parseData :: (Result JSValue, Result JSValue, Result JSValue, Result JSValue) -> Result ClusterData

-- | Top level function for data loading.
loadData :: String -> IO (Result ClusterData)


-- | External data loader.
--   
--   This module holds the external data loading, and thus is the only one
--   depending (via the specialized Text/Rapi/Luxi modules) on the actual
--   libraries implementing the low-level protocols.
module Ganeti.HTools.ExtLoader
wrapIO :: IO (Result a) -> IO (Result a)
parseUtilisation :: String -> Result (String, DynUtil)

-- | External tool data loader from a variety of sources.
loadExternalData :: Options -> IO ClusterData

-- | Function to save the cluster data to a file.
maybeSaveData :: Maybe FilePath -> String -> String -> ClusterData -> IO ()
data DataCollector
DataCollector :: String -> Maybe DCCategory -> DataCollector
dName :: DataCollector -> String
dCategory :: DataCollector -> Maybe DCCategory
data Report
CPUavgloadReport :: CPUavgload -> Report
collectors :: Options -> [DataCollector]
type MonDData = (String, [DCReport])
type MapMonDData = Map String [DCReport]

-- | Parse MonD data file contents.
pMonDData :: String -> Result [MonDData]
pMonDN :: JSRecord -> Result MonDData

-- | Query all MonDs for all Data Collector.
queryAllMonDDCs :: ClusterData -> Options -> IO ClusterData
queryAllMonDs :: Maybe MapMonDData -> (List, List) -> DataCollector -> IO (List, List)
fromCurl :: DataCollector -> Node -> IO (Maybe DCReport)
mkReport :: DataCollector -> Maybe DCReport -> Maybe Report
fromFile :: DataCollector -> Node -> MapMonDData -> Maybe DCReport
queryAMonD :: Maybe MapMonDData -> DataCollector -> Node -> IO (Maybe Node)
updateUtilData :: List -> Node -> List
prepareUrl :: DataCollector -> Node -> URLString
getDCCName :: Maybe DCCategory -> String


-- | IAllocator plugin for Ganeti.
module Ganeti.HTools.Program.Hail

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
wrapReadRequest :: Options -> [String] -> IO Request

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Cluster information printer.
module Ganeti.HTools.Program.Hinfo

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
data GroupInfo
GroupInfo :: String -> Int -> Int -> Int -> Int -> Bool -> Double -> GroupInfo
giName :: GroupInfo -> String
giNodeCount :: GroupInfo -> Int
giInstCount :: GroupInfo -> Int
giBadNodes :: GroupInfo -> Int
giBadInsts :: GroupInfo -> Int
giN1Status :: GroupInfo -> Bool
giScore :: GroupInfo -> Double
calcGroupInfo :: Group -> List -> List -> GroupInfo
groupRowFormatHelper :: GroupInfo -> [String]
showGroupInfo :: Int -> List -> List -> List -> IO ()
splitInstancesInfo :: Int -> List -> List -> IO ()
commonInfo :: Int -> List -> List -> List -> IO ()

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Cluster space sizing
module Ganeti.HTools.Program.Hspace

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
data Phase
PInitial :: Phase
PFinal :: Phase
PTiered :: Phase
data SpecType
SpecNormal :: SpecType
SpecTiered :: SpecType
htsPrefix :: String
specPrefix :: SpecType -> String
specDescription :: SpecType -> String
specName :: SpecType -> String
effFn :: (CStats -> Integer) -> (CStats -> Double) -> CStats -> Double
memEff :: CStats -> Double
dskEff :: CStats -> Double
cpuEff :: CStats -> Double
spnEff :: CStats -> Double
statsData :: [(String, CStats -> String)]
specData :: [(String, RSpec -> String)]
specDataSpn :: [(String, RSpec -> String)]
clusterData :: [(String, CStats -> String)]
clusterDataSpn :: [(String, CStats -> String)]
printStats :: Phase -> CStats -> [(String, String)]
printFRScores :: List -> List -> [(FailMode, Int)] -> IO ()
printResults :: Bool -> List -> List -> Int -> Int -> [(FailMode, Int)] -> IO ()
printFinalHTS :: Bool -> IO ()
tieredSpecMap :: [Instance] -> [(RSpec, Int)]
formatSpecMap :: [(RSpec, Int)] -> [String]
formatRSpec :: String -> AllocInfo -> [(String, String)]
printAllocationStats :: List -> List -> IO ()
printKeysHTS :: [(String, String)] -> IO ()
printInstance :: List -> Instance -> [String]
printAllocationMap :: Int -> String -> List -> [Instance] -> IO ()
formatResources :: a -> [(String, a -> String)] -> String
printCluster :: Bool -> CStats -> Int -> Bool -> IO ()
printISpec :: Bool -> RSpec -> SpecType -> DiskTemplate -> Bool -> IO ()
printTiered :: Bool -> [(RSpec, Int)] -> List -> List -> [(FailMode, Int)] -> IO ()
printClusterScores :: List -> List -> IO ()
printClusterEff :: CStats -> Bool -> IO ()
failureReason :: [(FailMode, Int)] -> String
sortReasons :: [(FailMode, Int)] -> [(FailMode, Int)]
runAllocation :: ClusterData -> Maybe AllocResult -> Result AllocResult -> RSpec -> DiskTemplate -> SpecType -> Options -> IO (FailStats, List, Int, [(RSpec, Int)])
instFromSpec :: RSpec -> DiskTemplate -> Int -> Instance
combineTiered :: AlgorithmOptions -> Maybe Int -> AllocNodes -> AllocResult -> Instance -> Result AllocResult

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Cluster rolling maintenance helper.
module Ganeti.HTools.Program.Hroller

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
move :: Idx -> Ndx -> (List, List) -> OpResult (List, List)
locateInstance :: Idx -> [Ndx] -> (List, List) -> Result (List, List)
locateInstances :: [Idx] -> [Ndx] -> (List, List) -> Result (List, List)
greedyClearNodes :: ((List, List) -> Ndx -> [Idx]) -> ([Idx] -> [Ndx] -> (List, List) -> Result (List, List)) -> [Ndx] -> [Ndx] -> (List, List) -> Result ([Ndx], (List, List))
clearNodes :: [Ndx] -> [Ndx] -> (List, List) -> Result ([Ndx], (List, List))
partitionNodes :: ([Ndx] -> [Ndx] -> (List, List) -> Result ([Ndx], (List, List))) -> [Ndx] -> [Ndx] -> (List, List) -> Result [([Ndx], (List, List))]
partitionNonRedundant :: [Ndx] -> [Ndx] -> (List, List) -> Result [([Ndx], (List, List))]
migrate :: Idx -> (List, List) -> OpResult (List, List)
primaries :: (List, List) -> Ndx -> [Idx]
migrateOffNodes :: ([Ndx], (List, List)) -> OpResult ([Ndx], (List, List))
replaceSecondary :: Idx -> Ndx -> (List, List) -> OpResult (List, List)
findSecondary :: Idx -> [Ndx] -> (List, List) -> Result (List, List)
findSecondaries :: [Idx] -> [Ndx] -> (List, List) -> Result (List, List)
secondaries :: (List, List) -> Ndx -> [Idx]
clearSecondaries :: [Ndx] -> [Ndx] -> (List, List) -> Result ([Ndx], (List, List))
partitionSecondaries :: [Ndx] -> [Ndx] -> (List, List) -> Result [([Ndx], (List, List))]
getStats :: [(String, ColorVertMap)] -> String
hasGroup :: Maybe Group -> Node -> Bool
hasTag :: Maybe [String] -> Node -> Bool
nonRedundant :: (List, List) -> Ndx -> [Idx]
noNonRedundant :: (List, List) -> Node -> Bool
masterLast :: [([Node], a)] -> [([Node], a)]
getMoves :: (List, List) -> (List, List) -> [(Instance, (Node, Maybe Node))]

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Scan clusters via RAPI or LUXI and write state data files.
module Ganeti.HTools.Program.Hscan

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
printCluster :: List -> List -> String
fixSlash :: String -> String
processData :: ClockTime -> ClusterData -> Result ClusterData
writeData :: Int -> String -> Options -> Result ClusterData -> IO Bool
writeDataInner :: Int -> String -> Options -> ClusterData -> ClusterData -> IO Bool

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Generic code to work with jobs, e.g. submit jobs and check their
--   status.
module Ganeti.Jobs

-- | A simple type alias for clearer signature.
type Annotator = OpCode -> MetaOpCode
execCancelWrapper :: Annotator -> String -> IORef Int -> [([[OpCode]], String)] -> IO (Result ())
execJobSet :: Annotator -> String -> IORef Int -> [([[OpCode]], String)] -> IO (Result ())
handleSigInt :: IORef Int -> IO ()
handleSigTerm :: IORef Int -> IO ()

-- | Prepares to run a set of jobsets with handling of signals and early
--   termination.
execWithCancel :: Annotator -> String -> [([[OpCode]], String)] -> IO (Result ())

-- | Submits a set of jobs and returns their job IDs without waiting for
--   completion.
submitJobs :: [[MetaOpCode]] -> Client -> IO (Result [JobId])

-- | Executes a set of jobs and waits for their completion, returning their
--   status.
execJobsWait :: [[MetaOpCode]] -> ([JobId] -> IO ()) -> Client -> IO (Result [(JobId, JobStatus)])

-- | Polls a set of jobs at an increasing interval until all are finished
--   one way or another.
waitForJobs :: [JobId] -> Client -> IO (Result [(JobId, JobStatus)])

-- | Execute jobs and return <tt>Ok</tt> only if all of them succeeded.
execJobsWaitOk :: [[MetaOpCode]] -> Client -> IO (Result ())


-- | Auto-repair tool for Ganeti.
module Ganeti.HTools.Program.Harep

-- | Options list and functions.
options :: IO [OptType]
arguments :: [ArgCompletion]
data InstanceData
InstanceData :: Instance -> AutoRepairStatus -> [String] -> InstanceData
arInstance :: InstanceData -> Instance
arState :: InstanceData -> AutoRepairStatus
tagsToRemove :: InstanceData -> [String]
parseInitTag :: String -> Maybe AutoRepairData
getArData :: AutoRepairStatus -> Maybe AutoRepairData
arStateName :: AutoRepairStatus -> String
delCurTag :: InstanceData -> [String]
setInitialState :: Instance -> Result InstanceData
arStatusCmp :: InstanceData -> [AutoRepairData] -> Result InstanceData
processPending :: Client -> InstanceData -> IO InstanceData
updateTag :: AutoRepairData -> AutoRepairData
commitChange :: Client -> InstanceData -> IO InstanceData
detectBroken :: List -> Instance -> Maybe (AutoRepairType, [OpCode])
doRepair :: Client -> Double -> InstanceData -> (AutoRepairType, [OpCode]) -> IO InstanceData

-- | Main function.
main :: Options -> [String] -> IO ()
instance Eq InstanceData
instance Show InstanceData


-- | Lenses for Ganeti config objects
module Ganeti.Objects.Lens

-- | Class of objects that have timestamps.
class TimeStampObject a => TimeStampObjectL a
mTimeL :: TimeStampObjectL a => Lens' a ClockTime

-- | Class of objects that have an UUID.
class UuidObject a => UuidObjectL a
uuidL :: UuidObjectL a => Lens' a String

-- | Class of object that have a serial number.
class SerialNoObject a => SerialNoObjectL a
serialL :: SerialNoObjectL a => Lens' a Int

-- | Class of objects that have tags.
class TagsObject a => TagsObjectL a
tagsL :: TagsObjectL a => Lens' a (Set String)
apReservationsL :: Iso' AddressPool BitArray
networkUuidL :: Lens' Network String
networkTagsL :: Lens' Network TagSet
networkSerialL :: Lens' Network Int
networkReservationsL :: Lens' Network (Maybe AddressPool)
networkNetworkL :: Lens' Network Ip4Network
networkNetwork6L :: Lens' Network (Maybe String)
networkNameL :: Lens' Network NonEmptyString
networkMtimeL :: Lens' Network ClockTime
networkMacPrefixL :: Lens' Network (Maybe String)
networkGatewayL :: Lens' Network (Maybe Ip4Address)
networkGateway6L :: Lens' Network (Maybe String)
networkExtReservationsL :: Lens' Network (Maybe AddressPool)
networkCtimeL :: Lens' Network ClockTime
nicUuidL :: Lens' PartialNic String
nicNicparamsL :: Lens' PartialNic PartialNicParams
nicNetworkL :: Lens' PartialNic (Maybe String)
nicNameL :: Lens' PartialNic (Maybe String)
nicMacL :: Lens' PartialNic String
nicIpL :: Lens' PartialNic (Maybe String)
mmisMinSpecL :: Lens' MinMaxISpecs FilledISpecParams
mmisMaxSpecL :: Lens' MinMaxISpecs FilledISpecParams
ipolicyVcpuRatioPL :: Lens' PartialIPolicy (Maybe Double)
ipolicyStdSpecPL :: Lens' PartialIPolicy (Maybe PartialISpecParams)
ipolicySpindleRatioPL :: Lens' PartialIPolicy (Maybe Double)
ipolicyMinMaxISpecsPL :: Lens' PartialIPolicy (Maybe [MinMaxISpecs])
ipolicyDiskTemplatesPL :: Lens' PartialIPolicy (Maybe [DiskTemplate])
ipolicyVcpuRatioL :: Lens' FilledIPolicy Double
ipolicyStdSpecL :: Lens' FilledIPolicy FilledISpecParams
ipolicySpindleRatioL :: Lens' FilledIPolicy Double
ipolicyMinMaxISpecsL :: Lens' FilledIPolicy [MinMaxISpecs]
ipolicyDiskTemplatesL :: Lens' FilledIPolicy [DiskTemplate]
nodeVmCapableL :: Lens' Node Bool
nodeUuidL :: Lens' Node String
nodeTagsL :: Lens' Node TagSet
nodeSerialL :: Lens' Node Int
nodeSecondaryIpL :: Lens' Node String
nodePrimaryIpL :: Lens' Node String
nodePoweredL :: Lens' Node Bool
nodeOfflineL :: Lens' Node Bool
nodeNdparamsL :: Lens' Node PartialNDParams
nodeNameL :: Lens' Node String
nodeMtimeL :: Lens' Node ClockTime
nodeMasterCapableL :: Lens' Node Bool
nodeMasterCandidateL :: Lens' Node Bool
nodeHvStateStaticL :: Lens' Node HypervisorState
nodeGroupL :: Lens' Node String
nodeDrainedL :: Lens' Node Bool
nodeDiskStateStaticL :: Lens' Node DiskState
nodeCtimeL :: Lens' Node ClockTime
groupUuidL :: Lens' NodeGroup String
groupTagsL :: Lens' NodeGroup TagSet
groupSerialL :: Lens' NodeGroup Int
groupNetworksL :: Lens' NodeGroup Networks
groupNdparamsL :: Lens' NodeGroup PartialNDParams
groupNameL :: Lens' NodeGroup String
groupMtimeL :: Lens' NodeGroup ClockTime
groupMembersL :: Lens' NodeGroup [String]
groupIpolicyL :: Lens' NodeGroup PartialIPolicy
groupHvStateStaticL :: Lens' NodeGroup HypervisorState
groupDiskparamsL :: Lens' NodeGroup GroupDiskParams
groupDiskStateStaticL :: Lens' NodeGroup DiskState
groupCtimeL :: Lens' NodeGroup ClockTime
groupAllocPolicyL :: Lens' NodeGroup AllocPolicy
clusterZeroingImageL :: Lens' Cluster String
clusterVolumeGroupNameL :: Lens' Cluster (Maybe String)
clusterUuidL :: Lens' Cluster String
clusterUseExternalMipScriptL :: Lens' Cluster Bool
clusterUidPoolL :: Lens' Cluster UidPool
clusterTcpudpPortPoolL :: Lens' Cluster [Int]
clusterTagsL :: Lens' Cluster TagSet
clusterSharedFileStorageDirL :: Lens' Cluster String
clusterSerialL :: Lens' Cluster Int
clusterRsahostkeypubL :: Lens' Cluster String
clusterReservedLvsL :: Lens' Cluster [String]
clusterPrimaryIpFamilyL :: Lens' Cluster IpFamily
clusterPreallocWipeDisksL :: Lens' Cluster Bool
clusterOsparamsPrivateClusterL :: Lens' Cluster ClusterOsParamsPrivate
clusterOsparamsL :: Lens' Cluster ClusterOsParams
clusterOsHvpL :: Lens' Cluster OsHvParams
clusterNicparamsL :: Lens' Cluster ClusterNicParams
clusterNdparamsL :: Lens' Cluster FilledNDParams
clusterMtimeL :: Lens' Cluster ClockTime
clusterModifySshSetupL :: Lens' Cluster Bool
clusterModifyEtcHostsL :: Lens' Cluster Bool
clusterMaxTrackedJobsL :: Lens' Cluster Int
clusterMaxRunningJobsL :: Lens' Cluster Int
clusterMasterNodeL :: Lens' Cluster String
clusterMasterNetmaskL :: Lens' Cluster Int
clusterMasterNetdevL :: Lens' Cluster String
clusterMasterIpL :: Lens' Cluster String
clusterMaintainNodeHealthL :: Lens' Cluster Bool
clusterMacPrefixL :: Lens' Cluster String
clusterIpolicyL :: Lens' Cluster FilledIPolicy
clusterInstanceCommunicationNetworkL :: Lens' Cluster String
clusterInstallImageL :: Lens' Cluster String
clusterHvparamsL :: Lens' Cluster ClusterHvParams
clusterHvStateStaticL :: Lens' Cluster HypervisorState
clusterHighestUsedPortL :: Lens' Cluster Int
clusterHiddenOsL :: Lens' Cluster [String]
clusterGlusterStorageDirL :: Lens' Cluster String
clusterFileStorageDirL :: Lens' Cluster String
clusterEnabledUserShutdownL :: Lens' Cluster Bool
clusterEnabledHypervisorsL :: Lens' Cluster [Hypervisor]
clusterEnabledDiskTemplatesL :: Lens' Cluster [DiskTemplate]
clusterDsahostkeypubL :: Lens' Cluster (Maybe String)
clusterDrbdUsermodeHelperL :: Lens' Cluster (Maybe String)
clusterDiskparamsL :: Lens' Cluster GroupDiskParams
clusterDiskStateStaticL :: Lens' Cluster DiskState
clusterDefaultIallocatorParamsL :: Lens' Cluster IAllocatorParams
clusterDefaultIallocatorL :: Lens' Cluster String
clusterDataCollectorsL :: Lens' Cluster (Container DataCollectorConfig)
clusterCtimeL :: Lens' Cluster ClockTime
clusterCompressionToolsL :: Lens' Cluster [String]
clusterClusterNameL :: Lens' Cluster String
clusterCandidatePoolSizeL :: Lens' Cluster Int
clusterCandidateCertsL :: Lens' Cluster CandidateCertificates
clusterBlacklistedOsL :: Lens' Cluster [String]
clusterBeparamsL :: Lens' Cluster ClusterBeParams
configVersionL :: Lens' ConfigData Int
configSerialL :: Lens' ConfigData Int
configNodesL :: Lens' ConfigData (Container Node)
configNodegroupsL :: Lens' ConfigData (Container NodeGroup)
configNetworksL :: Lens' ConfigData (Container Network)
configMtimeL :: Lens' ConfigData ClockTime
configInstancesL :: Lens' ConfigData (Container Instance)
configFiltersL :: Lens' ConfigData (Container FilterRule)
configDisksL :: Lens' ConfigData (Container Disk)
configCtimeL :: Lens' ConfigData ClockTime
configClusterL :: Lens' ConfigData Cluster
instance TimeStampObjectL ConfigData
instance SerialNoObjectL ConfigData
instance TagsObjectL Cluster
instance SerialNoObjectL Cluster
instance UuidObjectL Cluster
instance TimeStampObjectL Cluster
instance TagsObjectL NodeGroup
instance SerialNoObjectL NodeGroup
instance UuidObjectL NodeGroup
instance TimeStampObjectL NodeGroup
instance TagsObjectL Node
instance SerialNoObjectL Node
instance UuidObjectL Node
instance TimeStampObjectL Node
instance TagsObjectL Instance
instance SerialNoObjectL Instance
instance UuidObjectL Instance
instance TimeStampObjectL Instance
instance TimeStampObjectL Network
instance UuidObjectL Network
instance TagsObjectL Network
instance SerialNoObjectL Network


-- | Implementation of the Ganeti Query2 basic types.
--   
--   These are types internal to the library, and for example clients that
--   use the library should not need to import it.
module Ganeti.Query.Types

-- | The type of field getters. The "a" type represents the type we're
--   querying, whereas the "b" type represents the 'runtime' data for that
--   type (if any). Note that we don't support multiple runtime sources,
--   and we always consider the entire configuration as a given (so no
--   equivalent for Python's <i>*_CONFIG</i> and <i>*_GROUP</i>;
--   configuration accesses are cheap for us).
data FieldGetter a b
FieldSimple :: (a -> ResultEntry) -> FieldGetter a b
FieldRuntime :: (b -> a -> ResultEntry) -> FieldGetter a b
FieldConfig :: (ConfigData -> a -> ResultEntry) -> FieldGetter a b
FieldConfigRuntime :: (ConfigData -> b -> a -> ResultEntry) -> FieldGetter a b
FieldUnknown :: FieldGetter a b

-- | Type defining how the value of a field is used in filtering. This
--   implements the equivalent to Python's QFF_ flags, except that we don't
--   use OR-able values.
data QffMode

-- | Value is used as-is in filters
QffNormal :: QffMode

-- | Value is a timestamp tuple, convert to float
QffTimestamp :: QffMode

-- | Value is a hostname, compare it smartly
QffHostname :: QffMode

-- | Alias for a field data (definition and getter).
type FieldData a b = (FieldDefinition, FieldGetter a b, QffMode)

-- | Alias for a field data list.
type FieldList a b = [FieldData a b]

-- | Alias for field maps.
type FieldMap a b = Map String (FieldData a b)

-- | Helper function to check if a getter is a runtime one.
isRuntimeField :: FieldGetter a b -> Bool

-- | Helper function to obtain a FieldMap from the corresponding FieldList.
fieldListToFieldMap :: FieldList a b -> FieldMap a b
instance Show QffMode
instance Eq QffMode


-- | Implementation of the Ganeti Query2 filterning.
--   
--   The filtering of results should be done in two phases.
--   
--   In the first phase, before contacting any remote nodes for runtime
--   data, the filtering should be executed with <a>Nothing</a> for the
--   runtime context. This will make all non-runtime filters filter
--   correctly, whereas all runtime filters will respond successfully. As
--   described in the Python version too, this makes for example <i>Or</i>
--   filters very inefficient if they contain runtime fields.
--   
--   Once this first filtering phase has been done, we hopefully eliminated
--   some remote nodes out of the list of candidates, we run the remote
--   data gathering, and we evaluate the filter again, this time with a
--   <a>Just</a> runtime context. This will make all filters work
--   correctly.
--   
--   Note that the second run will re-evaluate the config/simple fields,
--   without caching; this is not perfect, but we consider config accesses
--   very cheap (and the configuration snapshot we have won't change
--   between the two runs, hence we will not get inconsistent results).
module Ganeti.Query.Filter

-- | Compiles a filter based on field names to one based on getters.
compileFilter :: FieldMap a b -> Filter FilterField -> ErrorResult (Filter (FieldGetter a b, QffMode))
qffField :: QffMode -> JSValue -> ErrorResult JSValue
wrapGetter :: ConfigData -> Maybe b -> a -> (FieldGetter a b, QffMode) -> (JSValue -> ErrorResult Bool) -> MaybeT ErrorResult Bool
trueFilter :: JSValue -> ErrorResult Bool

-- | A type synonim for a rank-2 comparator function. This is used so that
--   we can pass the usual <a>&lt;=</a>, <a>&gt;</a>, <a>==</a> functions
--   to <a>binOpFilter</a> and for them to be used in multiple contexts.
type Comparator = (Eq a, Ord a) => a -> a -> Bool
eqFilter :: QffMode -> FilterValue -> JSValue -> ErrorResult Bool
binOpFilter :: Comparator -> FilterValue -> JSValue -> ErrorResult Bool
regexpFilter :: FilterRegex -> JSValue -> ErrorResult Bool
containsFilter :: FilterValue -> JSValue -> ErrorResult Bool

-- | Ways we can compare things in the filter language.
data Comparison
Eq :: Comparison
Lt :: Comparison
Le :: Comparison
Gt :: Comparison
Ge :: Comparison

-- | Turns a comparison into the corresponding Haskell function.
toCompFun :: Comparison -> Comparator

-- | Operations in the leaves of the Ganeti filter language.
data FilterOp field val
Truth :: FilterOp field ()
Comp :: Comparison -> FilterOp field FilterValue
Regex :: FilterOp field FilterRegex
Contains :: FilterOp field FilterValue

-- | Checks if a filter matches.
--   
--   The leaves of the filter are evaluated against an object using the
--   passed <tt>opFun</tt>; that is why the object need not be passed in.
--   
--   The <tt>field</tt> type describes the <a>accessors</a> that are used
--   to query values from the object; those values are to be matched
--   against the <tt>val</tt> type in the filter leaves.
--   
--   Useful monads <tt>m</tt> for this are <a>ErrorResult</a> and
--   <a>Maybe</a>.
evaluateFilterM :: (Monad m, Applicative m) => (forall val. FilterOp field val -> field -> val -> m Bool) -> Filter field -> m Bool

-- | Verifies if a given item passes a filter. The runtime context might be
--   missing, in which case most of the filters will consider this as
--   passing the filter.
evaluateQueryFilter :: ConfigData -> Maybe b -> a -> Filter (FieldGetter a b, QffMode) -> ErrorResult Bool

-- | Evaluates a <a>Filter</a> on a JSON object.
evaluateFilterJSON :: Filter JSValue -> ErrorResult Bool
tryGetter :: ConfigData -> Maybe b -> a -> FieldGetter a b -> Maybe ResultEntry

-- | Computes the requested names, if only names were requested (and with
--   equality). Otherwise returns <a>Nothing</a>.
requestedNames :: FilterField -> Filter FilterField -> Maybe [FilterValue]

-- | Builds a simple filter from a list of names.
makeSimpleFilter :: String -> [Either String Integer] -> Filter FilterField
instance Show (FilterOp field val)
instance Eq (FilterOp field val)
instance Eq Comparison
instance Ord Comparison
instance Show Comparison


-- | Implementation of Utility functions for storage
module Ganeti.Storage.Utils
getDefaultStorageKey :: ConfigData -> DiskTemplate -> Maybe StorageKey
getDefaultSpindleSU :: ConfigData -> (StorageType, Maybe StorageKey)
getClusterStorageUnitRaws :: ConfigData -> [StorageUnitRaw]
foldSUs :: [(StorageType, Maybe StorageKey)] -> [StorageUnitRaw]
getExclusiveStorage :: ConfigData -> Node -> Maybe Bool
hasExclusiveStorageFlag :: ConfigData -> Node -> Bool

-- | Filter for nodes with a valid config
nodesWithValidConfig :: ConfigData -> [Node] -> [Node]
getStorageUnitsOfNode :: ConfigData -> Node -> [StorageUnit]

-- | Get the storage unit map for all nodes
getStorageUnitsOfNodes :: ConfigData -> [Node] -> Map String [StorageUnit]


-- | Pure functions for manipulating the configuration state.
module Ganeti.WConfd.ConfigState

-- | In future this data type will include the current configuration
--   (<a>ConfigData</a>) and the last <tt>FStat</tt> of its file.
data ConfigState
ConfigState :: ConfigData -> ConfigState
csConfigData :: ConfigState -> ConfigData
csConfigDataL :: Iso' ConfigState ConfigData

-- | Creates a new configuration state. This method will expand as more
--   fields are added to <a>ConfigState</a>.
mkConfigState :: ConfigData -> ConfigState
bumpSerial :: (SerialNoObjectL a, TimeStampObjectL a) => ClockTime -> a -> a

-- | Given two versions of the configuration, determine if its distribution
--   needs to be fully commited before returning the corresponding call to
--   WConfD.
needsFullDist :: ConfigState -> ConfigState -> Bool
instance Eq ConfigState
instance Show ConfigState


-- | Implementation of functions specific to configuration management.
module Ganeti.WConfd.ConfigVerify
keysSet :: Ord k => GenericContainer k v -> Set k
checkUUIDKeys :: (UuidObject a, Show a) => String -> Container a -> ValidationMonad ()
checkUUIDRefs :: (UuidObject a, Show a, Foldable f) => String -> String -> (a -> [String]) -> f a -> Container b -> ValidationMonad ()

-- | Checks consistency of a given configuration.
--   
--   TODO: Currently this implements only some very basic checks. Evenually
--   all checks from Python ConfigWriter need to be moved here (see issue
--   #759).
verifyConfig :: ConfigData -> ValidationMonad ()

-- | Checks consistency of a given configuration. If there is an error,
--   throw <a>ConfigVerifyError</a>.
verifyConfigErr :: MonadError GanetiException m => ConfigData -> m ()


-- | Implementation of the Ganeti network objects.
--   
--   This is does not (yet) cover all methods that are provided in the
--   corresponding python implementation (network.py).
module Ganeti.Network
ipv4NumHosts :: Integral n => n -> Integer
ipv4NetworkMinNumHosts :: Integer
ipv4NetworkMaxNumHosts :: Integer
data PoolPart
PoolInstances :: PoolPart
PoolExt :: PoolPart
addressPoolIso :: Iso' AddressPool BitArray
poolLens :: PoolPart -> Lens' Network (Maybe AddressPool)
poolArrayLens :: PoolPart -> Lens' Network (Maybe BitArray)
netIpv4NumHosts :: Network -> Integer
newPoolArray :: (MonadError e m, Error e) => Network -> m BitArray
newPool :: (MonadError e m, Error e) => Network -> m AddressPool
orNewPool :: (MonadError e m, Error e) => Network -> Maybe AddressPool -> m AddressPool
withPool :: (MonadError e m, Error e) => PoolPart -> (Network -> BitArray -> m (a, BitArray)) -> StateT Network m a
withPool_ :: (MonadError e m, Error e) => PoolPart -> (Network -> BitArray -> m BitArray) -> Network -> m Network
readPool :: PoolPart -> Network -> Maybe BitArray
readPoolE :: (MonadError e m, Error e) => PoolPart -> Network -> m BitArray
readAllE :: (MonadError e m, Error e) => Network -> m BitArray
reservations :: Network -> Maybe BitArray
extReservations :: Network -> Maybe BitArray

-- | Get a bit vector of all reservations (internal and external) combined.
allReservations :: Network -> Maybe BitArray

-- | Get the count of reserved addresses.
getReservedCount :: Network -> Int

-- | Get the count of free addresses.
getFreeCount :: Network -> Int

-- | Check whether the network is full.
isFull :: Network -> Bool

-- | Return a textual representation of the network's occupation status.
getMap :: Network -> String
addrIndex :: (MonadError e m, Error e) => Ip4Address -> Network -> m Int
addrAt :: (MonadError e m, Error e) => Int -> Network -> m Ip4Address

-- | Checks if a given address is reserved. Fails if the address isn't in
--   the network range.
isReserved :: (MonadError e m, Error e) => PoolPart -> Ip4Address -> Network -> m Bool

-- | Marks an address as used.
reserve :: (MonadError e m, Error e) => PoolPart -> Ip4Address -> Network -> m Network

-- | Marks an address as unused.
release :: (MonadError e m, Error e) => PoolPart -> Ip4Address -> Network -> m Network

-- | Get the first free address in the network that satisfies a given
--   predicate.
findFree :: (MonadError e m, Error e) => (Ip4Address -> Bool) -> Network -> m (Maybe Ip4Address)


-- | Implementation of the Ganeti Query2 common objects.
module Ganeti.Query.Common

-- | The runtime used by queries which retrieve no live data.
data NoDataRuntime
NoDataRuntime :: NoDataRuntime
vTypeToQFT :: VType -> FieldType

-- | Helper for a result with no data.
rsNoData :: ResultEntry

-- | Helper for result for an entity which supports no such field.
rsUnavail :: ResultEntry

-- | Helper to declare a normal result.
rsNormal :: JSON a => a -> ResultEntry

-- | Helper to declare a result from a <a>Maybe</a> (the item might be
--   missing, in which case we return no data). Note that there's some
--   ambiguity here: in some cases, we mean <a>RSNoData</a>, but in other
--   <a>RSUnavail</a>; this is easy to solve in simple cases, but not in
--   nested dicts. If you want to return <a>RSUnavail</a> in case of
--   <a>Nothing</a> use the function <a>rsMaybeUnavail</a>.
rsMaybeNoData :: JSON a => Maybe a -> ResultEntry

-- | Helper to declare a result from a <a>ErrorResult</a> (an error
--   happened while retrieving the data from a config, or there was no
--   data). This function should be used if an error signals there was no
--   data.
rsErrorNoData :: JSON a => ErrorResult a -> ResultEntry

-- | Helper to declare a result from a <a>Maybe</a>. This version returns a
--   <a>RSUnavail</a> in case of <a>Nothing</a>. It should be used for
--   optional fields that are not set. For cases where <a>Nothing</a> means
--   that there was an error, consider using <tt>rsMaybe</tt> instead.
rsMaybeUnavail :: JSON a => Maybe a -> ResultEntry

-- | Helper to declare a result from 'ErrorResult Maybe'. This version
--   should be used if an error signals there was no data and at the same
--   time when we have optional fields that may not be setted (i.e. we want
--   to return a <a>RSUnavail</a> in case of <a>Nothing</a>).
rsErrorMaybeUnavail :: JSON a => ErrorResult (Maybe a) -> ResultEntry

-- | Helper for unknown field result.
rsUnknown :: ResultEntry

-- | Helper for a missing runtime parameter.
missingRuntime :: FieldGetter a b

-- | Convert RpcError to ResultStatus
rpcErrorToStatus :: RpcError -> ResultStatus

-- | The list of timestamp fields.
timeStampFields :: TimeStampObject a => FieldList a b

-- | The list of the field for the property of being forthcoming.
forthcomingFields :: ForthcomingObject a => String -> FieldList a b

-- | The list of UUID fields.
uuidFields :: UuidObject a => String -> FieldList a b

-- | The list of serial number fields.
serialFields :: SerialNoObject a => String -> FieldList a b

-- | The list of tag fields.
tagsFields :: TagsObject a => FieldList a b

-- | Returns a field from a (possibly missing) <a>DictObject</a>. This is
--   used by parameter dictionaries, usually. Note that we have two levels
--   of maybe: the top level dict might be missing, or one key in the
--   dictionary might be.
dictFieldGetter :: DictObject a => String -> Maybe a -> ResultEntry
ndParamTypes :: Map String FieldType
ndParamTitles :: Map String FieldTitle
ndParamGetter :: NdParamObject a => String -> ConfigData -> a -> ResultEntry

-- | Builds the ndparam fields for an object.
buildNdParamField :: NdParamObject a => String -> FieldData a b
beParamTypes :: Map String FieldType

-- | Builds the beparam fields for an object.
buildBeParamField :: (String -> ConfigData -> a -> ResultEntry) -> String -> FieldData a b
hvParamTypes :: Map String FieldType

-- | Builds the beparam fields for an object.
buildHvParamField :: (String -> ConfigData -> a -> ResultEntry) -> String -> FieldData a b
buildParamField :: String -> String -> Map String String -> Map String FieldType -> (String -> ConfigData -> a -> ResultEntry) -> String -> FieldData a b

-- | Looks up the default hypervisor and its hvparams
getDefaultHypervisorSpec :: ConfigData -> (Hypervisor, HvParams)

-- | Looks up the cluster's hvparams of the given hypervisor
getHvParamsFromCluster :: ConfigData -> Hypervisor -> HvParams

-- | Given an alias list and a field list, copies field definitions under a
--   new field name. Aliases should be tested - see the test module
--   <a>Aliases</a>!
aliasFields :: [(FieldName, FieldName)] -> FieldList a b -> FieldList a b


-- | Implementation of the Ganeti Query2 export queries.
module Ganeti.Query.Export

-- | The parsed result of the ExportList. This is a bit tricky, in that we
--   already do parsing of the results in the RPC calls, so the runtime
--   type is a plain <a>ResultEntry</a>, as we have just one type.
type Runtime = ResultEntry
rpcErrToRs :: RpcError -> ResultEntry
rpcExtractor :: Node -> Either RpcError RpcResultExportList -> [(Node, ResultEntry)]
exportFields :: FieldList Node Runtime

-- | The node fields map.
fieldsMap :: FieldMap Node Runtime

-- | Collect live data from RPC query if enabled.
--   
--   Note that this function is "funny": the returned rows will not be 1:1
--   with the input, as nodes without exports will be pruned, whereas nodes
--   with multiple exports will be listed multiple times.
collectLiveData :: Bool -> ConfigData -> [Node] -> IO [(Node, Runtime)]


-- | Implementation of Ganeti filter queries.
module Ganeti.Query.FilterRules
filterFields :: FieldList FilterRule NoDataRuntime

-- | The lock fields map.
fieldsMap :: FieldMap FilterRule NoDataRuntime


-- | Implementation of the Ganeti Query2 node group queries.
module Ganeti.Query.Group
groupFields :: FieldList NodeGroup NoDataRuntime

-- | The group fields map.
fieldsMap :: FieldMap NodeGroup NoDataRuntime


-- | Implementation of Ganeti Lock field queries
--   
--   The actual computation of the field values is done by forwarding the
--   request; so only have a minimal field definition here.
module Ganeti.Query.Locks

-- | The runtime information for locks. As all information about locks is
--   handled by WConfD, the actual information is obtained as live data.
--   The type represents the information for a single lock, even though all
--   locks are queried simultaneously, ahead of time.
type RuntimeData = ([(ClientId, OwnerState)], [(ClientId, OwnerState)])
getOwners :: RuntimeData -> a -> ResultEntry
getMode :: RuntimeData -> a -> ResultEntry
getPending :: RuntimeData -> a -> ResultEntry
lockFields :: FieldList String RuntimeData

-- | The lock fields map.
fieldsMap :: FieldMap String RuntimeData


-- | Implementation of the Ganeti Query2 node group queries.
module Ganeti.Query.Network
networkFields :: FieldList Network NoDataRuntime

-- | The group fields map.
fieldsMap :: FieldMap Network NoDataRuntime
getGroupConnections :: ConfigData -> String -> [(String, String, String, String)]

-- | Given a network's UUID and a node group, this function assembles a
--   tuple of the group's name, the mode and the link by which the network
--   is connected to the group. Returns <a>Nothing</a> if the network is
--   not connected to the group.
getGroupConnection :: String -> NodeGroup -> Maybe (String, String, String, String)
getNicMode :: PartialNicParams -> String
getNicLink :: PartialNicParams -> String
getNicVlan :: PartialNicParams -> String
getInstances :: ConfigData -> String -> [String]

-- | Helper function that checks if an instance is linked to the given
--   network.
instIsConnected :: String -> Instance -> Bool

-- | Helper function to look up a network's UUID by its name
getNetworkUuid :: ConfigData -> String -> Maybe String
getReservations :: Ip4Network -> Maybe AddressPool -> [Ip4Address]
getExtReservationsString :: Network -> ResultEntry


-- | Implementation of the Ganeti Query2 node queries.
module Ganeti.Query.Node

-- | Runtime is the resulting type for NodeInfo call.
type Runtime = Either RpcError RpcResultNodeInfo
nodeLiveFieldsDefs :: [(FieldName, FieldTitle, FieldType, String, FieldDoc)]
getAttrFromStorageInfo :: JSON a => (StorageInfo -> Maybe a) -> Maybe StorageInfo -> JSValue
isStorageInfoOfType :: StorageType -> StorageInfo -> Bool
getStorageInfoForDefault :: [StorageInfo] -> Maybe StorageInfo
getStorageInfoForType :: [StorageInfo] -> StorageType -> Maybe StorageInfo
nodeLiveFieldExtract :: FieldName -> RpcResultNodeInfo -> JSValue
nodeLiveRpcCall :: FieldName -> Runtime -> Node -> ResultEntry
nodeLiveFieldBuilder :: (FieldName, FieldTitle, FieldType, String, FieldDoc) -> FieldData Node Runtime
nodeRoleDoc :: String
getNodePower :: ConfigData -> Node -> ResultEntry
nodeFields :: FieldList Node Runtime
getNumInstances :: (([Instance], [Instance]) -> [Instance]) -> ConfigData -> Node -> Int

-- | The node fields map.
fieldsMap :: FieldMap Node Runtime
rpcResultNodeBroken :: Node -> (Node, Runtime)
storageFields :: [String]
hypervisorFields :: [String]
queryDomainRequired :: [String] -> [String] -> Bool

-- | Collect live data from RPC query if enabled.
collectLiveData :: Bool -> ConfigData -> [String] -> [Node] -> IO [(Node, Runtime)]


-- | Implementation of the Ganeti Query2 instance queries.
module Ganeti.Query.Instance
type LiveInfo = (Maybe (InstanceInfo, Bool), Maybe InstanceConsoleInfo)

-- | Runtime containing the <a>LiveInfo</a>. See the genericQuery function
--   in the Query.hs file for an explanation of the terms used.
type Runtime = Either RpcError LiveInfo

-- | The instance fields map.
fieldsMap :: FieldMap Instance Runtime

-- | The instance aliases.
instanceAliases :: [(FieldName, FieldName)]
aliasedFields :: FieldList Instance Runtime

-- | The instance fields.
instanceFields :: FieldList Instance Runtime
nicDescSuffix :: String
nicAggDescPrefix :: String
getNetworkName :: ConfigData -> String -> NonEmptyString
getNicBridge :: FilledNicParams -> Maybe String
getNicVlan :: FilledNicParams -> Maybe String
fillNicParamsFromConfig :: ConfigData -> PartialNicParams -> FilledNicParams
getDefaultNicParams :: ConfigData -> FilledNicParams
getDiskSizeRequirements :: ConfigData -> Instance -> ResultEntry
getDiskSizes :: ConfigData -> Instance -> ResultEntry
getDiskSpindles :: ConfigData -> Instance -> ResultEntry
getDiskNames :: ConfigData -> Instance -> ResultEntry
getDiskUuids :: ConfigData -> Instance -> ResultEntry
getIndexedOptionalConfField :: JSON b => (ConfigData -> Instance -> ErrorResult [a]) -> (a -> Maybe b) -> Int -> FieldGetter Instance Runtime
getIndexedConfField :: JSON b => (ConfigData -> Instance -> ErrorResult [a]) -> (a -> b) -> Int -> FieldGetter Instance Runtime
getIndexedNicNetworkNameField :: Int -> FieldGetter Instance Runtime
getIndexedNicField :: JSON a => (FilledNicParams -> a) -> Int -> FieldGetter Instance Runtime
getOptionalIndexedNicField :: JSON a => (FilledNicParams -> Maybe a) -> Int -> FieldGetter Instance Runtime
getIndexedFieldWithDefault :: JSON c => (Instance -> [a]) -> (ConfigData -> Instance -> b) -> (b -> a -> b) -> (b -> Maybe c) -> Int -> FieldGetter Instance Runtime
getIndexedOptionalField :: JSON b => (Instance -> [a]) -> (a -> Maybe b) -> Int -> FieldGetter Instance Runtime
getIndexedField :: JSON b => (Instance -> [a]) -> (a -> b) -> Int -> FieldGetter Instance Runtime
maybeAt :: Int -> [a] -> Maybe a
fieldDefinitionCompleter :: PrintfArg t1 => PrintfArg t2 => FieldName -> FieldTitle -> FieldType -> FieldDoc -> t1 -> t2 -> FieldDefinition
fillIncompleteFields :: (t1 -> t2 -> FieldDefinition, t1 -> FieldGetter a b, QffMode) -> t1 -> t2 -> FieldData a b
instantiateIndexedFields :: (Show t1, Integral t1) => Int -> [(t1 -> String -> FieldDefinition, t1 -> FieldGetter a b, QffMode)] -> FieldList a b
getPrimaryNode :: ConfigData -> Instance -> ErrorResult Node
getPrimaryNodeName :: ConfigData -> Instance -> ResultEntry
getPrimaryNodeGroup :: ConfigData -> Instance -> ErrorResult NodeGroup
getPrimaryNodeGroupName :: ConfigData -> Instance -> ResultEntry
getPrimaryNodeGroupUuid :: ConfigData -> Instance -> ResultEntry
getSecondaryNodes :: ConfigData -> Instance -> ErrorResult [Node]
getSecondaryNodeAttribute :: JSON a => (Node -> a) -> ConfigData -> Instance -> ResultEntry
getSecondaryNodeGroups :: ConfigData -> Instance -> ErrorResult [NodeGroup]
getSecondaryNodeGroupAttribute :: JSON a => (NodeGroup -> a) -> ConfigData -> Instance -> ResultEntry
beParamGetter :: String -> ConfigData -> Instance -> ResultEntry
hvParamGetter :: String -> ConfigData -> Instance -> ResultEntry
instanceLiveFieldsDefs :: [(FieldName, FieldTitle, FieldType, String, FieldDoc)]
instanceLiveFieldExtract :: FieldName -> InstanceInfo -> Instance -> JSValue
instanceLiveRpcCall :: FieldName -> Runtime -> Instance -> ResultEntry
instanceLiveFieldBuilder :: (FieldName, FieldTitle, FieldType, String, FieldDoc) -> FieldData Instance Runtime
statusDocText :: String
isPrimaryOffline :: ConfigData -> Instance -> Bool
userShutdownEnabled :: ConfigData -> Bool
liveInstanceStatus :: ConfigData -> (InstanceInfo, Bool) -> Instance -> InstanceStatus
deadInstanceStatus :: ConfigData -> Instance -> InstanceStatus
determineInstanceStatus :: ConfigData -> Runtime -> Instance -> InstanceStatus
statusExtract :: ConfigData -> Runtime -> Instance -> ResultEntry
operStatusExtract :: Runtime -> Instance -> ResultEntry
consoleExtract :: Runtime -> Instance -> ResultEntry
checkForNodeError :: [(String, ERpcError a)] -> String -> Maybe RpcError
findInfoInNodeResult :: Instance -> ERpcError RpcResultAllInstancesInfo -> Maybe InstanceInfo

-- | Retrieves the instance information if it is present anywhere in the
--   all instances RPC result. Notes if it originates from the primary
--   node. An error is delivered if there is no result, and the primary
--   node is down.
getInstanceInfo :: [(String, ERpcError RpcResultAllInstancesInfo)] -> Instance -> ERpcError (Maybe (InstanceInfo, Bool))
getConsoleInfo :: [(String, ERpcError RpcResultInstanceConsoleInfo)] -> Instance -> Maybe InstanceConsoleInfo
extractLiveInfo :: [(Node, ERpcError RpcResultAllInstancesInfo)] -> [(Node, ERpcError RpcResultInstanceConsoleInfo)] -> Instance -> Runtime
getAllConsoleParams :: ConfigData -> [Instance] -> ErrorResult [InstanceConsoleInfoParams]
compareParamsByNode :: InstanceConsoleInfoParams -> InstanceConsoleInfoParams -> Bool
consoleParamsToCalls :: [InstanceConsoleInfoParams] -> [(Node, RpcCallInstanceConsoleInfo)]
getHypervisorSpecs :: ConfigData -> [Instance] -> [(Hypervisor, HvParams)]

-- | Collect live data from RPC query if enabled.
collectLiveData :: Bool -> ConfigData -> [String] -> [Instance] -> IO [(Instance, Runtime)]
getDiskTemplate :: ConfigData -> Instance -> ResultEntry


-- | Unittests for query aliases.
module Test.Ganeti.Query.Aliases
toFieldNameList :: FieldList a b -> [FieldName]
toAliasNameList :: [(FieldName, FieldName)] -> [FieldName]
toAliasTargetList :: [(FieldName, FieldName)] -> [FieldName]
checkShadowing :: String -> FieldList a b -> [(FieldName, FieldName)] -> Assertion
checkTargets :: String -> FieldList a b -> [(FieldName, FieldName)] -> Assertion
case_instanceAliasesNoShadowing :: Assertion
case_instanceAliasesTargetsExist :: Assertion
testQuery_Aliases :: Test


-- | Unittests for Instance Queries.
module Test.Ganeti.Query.Instance
createInstance :: String -> String -> AdminState -> AdminStateSource -> Instance
fakeInstanceInfo :: InstanceInfo
responseError :: String -> (String, ERpcError a)
responseSuccess :: String -> [String] -> (String, ERpcError RpcResultAllInstancesInfo)
waldoInstance :: Instance
case_nodeOffline :: Assertion
case_nodeOnlineNoInfo :: Assertion
case_infoOnPrimary :: Assertion
case_infoOnSecondary :: Assertion
testQuery_Instance :: Test


-- | Creates a client out of list of RPC server components.
module Ganeti.THH.HsRPC

-- | The monad for all client RPC functions. Given a client value, it runs
--   the RPC call in IO and either retrieves the result or the error.
newtype RpcClientMonad a
RpcClientMonad :: ReaderT Client ResultG a -> RpcClientMonad a
runRpcClientMonad :: RpcClientMonad a -> ReaderT Client ResultG a

-- | Given a client run a given client RPC action.
runRpcClient :: (MonadBase IO m, MonadError GanetiException m) => RpcClientMonad a -> Client -> m a
callMethod :: (JSON r, JSON args) => String -> args -> RpcClientMonad r

-- | Given a server RPC function (such as from WConfd.Core), creates the
--   corresponding client function. The monad of the result type of the
--   given function is replaced by <a>RpcClientMonad</a> and the new
--   function is implemented to issue a RPC call to the server.
mkRpcCall :: Name -> Q [Dec]
mkRpcCalls :: [Name] -> Q [Dec]
instance Functor RpcClientMonad
instance Applicative RpcClientMonad
instance Monad RpcClientMonad
instance MonadIO RpcClientMonad
instance MonadBase IO RpcClientMonad
instance MonadError GanetiException RpcClientMonad
instance MonadBaseControl IO RpcClientMonad


-- | Implements Template Haskell generation of RPC server components from
--   Haskell functions.
module Ganeti.THH.RPC
data RpcFn m
RpcFn :: (i -> m o) -> RpcFn m
type RpcServer m = Handler Request m JSValue

-- | A RPC request consiting of a method and its argument(s).
data Request
Request :: String -> JSValue -> Request
rMethod :: Request -> String
rArgs :: Request -> JSValue
decodeRequest :: JSValue -> JSValue -> Result Request
dispatch :: Monad m => Map String (RpcFn (ResultT GanetiException m)) -> RpcServer m
toRpcFn :: Name -> Q Exp
rpcFnsList :: [(String, Q Exp)] -> Q Exp

-- | Takes a list of function names and creates a RPC handler that
--   delegates calls to them.
--   
--   The functions must conform to <tt>(J.JSON i, J.JSON o) =&gt; i -&gt;
--   ResultT GanetiException m o</tt>. The <tt>m</tt> monads types of all
--   the functions must unify.
--   
--   The result expression is of type <tt>RpcServer m</tt>.
mkRpcM :: [Name] -> Q Exp
instance Eq Request
instance Ord Request
instance Show Request


-- | Necessary foreign function calls
--   
--   ...with foreign functions declared in unistd.h
module Ganeti.Utils.UniStd
fsync :: CInt -> IO CInt
fsyncFile :: Error e => FilePath -> ResultT e IO ()


-- | Utility functions for atomic file access.
module Ganeti.Utils.Atomic

-- | Atomically write a file, by first writing the contents into a
--   temporary file and then renaming it to the old position.
atomicWriteFile :: FilePath -> String -> IO ()
fsyncFileChecked :: FilePath -> IO ()

-- | Atomically update a file, by first creating a temporary file, running
--   the given action on it, and then renaming it to the old position.
--   Usually the action will write to the file and update its permissions.
--   The action is allowed to close the file descriptor, but isn't required
--   to do so.
atomicUpdateFile :: MonadBaseControl IO m => FilePath -> (FilePath -> Handle -> m a) -> m a

-- | Opens a file in a R/W mode, locks it (blocking if needed) and runs a
--   given action while the file is locked. Releases the lock and closes
--   the file afterwards.
withLockedFile :: (MonadError e m, Error e, MonadBaseControl IO m) => FilePath -> (Fd -> m a) -> m a

-- | Just as <a>atomicUpdateFile</a>, but in addition locks the file during
--   the operation using <a>withLockedFile</a> and checks if the file has
--   been modified. The action is only run if it hasn't, otherwise an error
--   is thrown. The file must exist. Returns the new file status after the
--   operation is finished.
atomicUpdateLockedFile :: FilePath -> FStat -> (FilePath -> Handle -> IO a) -> ResultG (FStat, a)

-- | Just as <a>atomicUpdateLockedFile</a>, but discards the action result.
atomicUpdateLockedFile_ :: FilePath -> FStat -> (FilePath -> Handle -> IO a) -> ResultG FStat


-- | Implementation of the job queue.
module Ganeti.JQueue

-- | Missing timestamp type.
noTimestamp :: Timestamp

-- | Obtain a Timestamp from a given clock time
fromClockTime :: ClockTime -> Timestamp

-- | Get the current time in the job-queue timestamp format.
currentTimestamp :: IO Timestamp

-- | From a given timestamp, obtain the timestamp of the time that is the
--   given number of seconds later.
advanceTimestamp :: Int -> Timestamp -> Timestamp
toMetaOpCode :: InputOpCode -> [MetaOpCode]
invalidOp :: String

-- | Tries to extract the opcode summary from an <a>InputOpCode</a>. This
--   duplicates some functionality from the <a>opSummary</a> function in
--   <a>Ganeti.OpCodes</a>.
extractOpSummary :: InputOpCode -> String

-- | Convenience function to obtain a QueuedOpCode from a MetaOpCode
queuedOpCodeFromMetaOpCode :: MetaOpCode -> QueuedOpCode

-- | From a job-id and a list of op-codes create a job. This is the pure
--   part of job creation, as allocating a new job id lives in IO.
queuedJobFromOpCodes :: Monad m => JobId -> [MetaOpCode] -> m QueuedJob

-- | Attach a received timestamp to a Queued Job.
setReceivedTimestamp :: Timestamp -> QueuedJob -> QueuedJob

-- | Build a timestamp in the format expected by the reason trail
--   (nanoseconds) starting from a JQueue Timestamp.
reasonTrailTimestamp :: Timestamp -> Integer
extendInputOpCodeReasonTrail :: JobId -> Timestamp -> Int -> InputOpCode -> InputOpCode
extendOpCodeReasonTrail :: JobId -> Timestamp -> Int -> QueuedOpCode -> QueuedOpCode

-- | Append an element to the reason trail of all the OpCodes of a queued
--   job.
extendJobReasonTrail :: QueuedJob -> QueuedJob

-- | From a queued job obtain the list of jobs it depends on.
getJobDependencies :: QueuedJob -> [JobId]

-- | Change the priority of a QueuedOpCode, if it is not already finalized.
changeOpCodePriority :: Int -> QueuedOpCode -> QueuedOpCode
cancelOpCode :: Timestamp -> QueuedOpCode -> QueuedOpCode

-- | Change the priority of a job, i.e., change the priority of the
--   non-finalized opcodes.
changeJobPriority :: Int -> QueuedJob -> QueuedJob

-- | Transform a QueuedJob that has not been started into its canceled
--   form.
cancelQueuedJob :: Timestamp -> QueuedJob -> QueuedJob
failOpCode :: ReasonElem -> Timestamp -> QueuedOpCode -> QueuedOpCode

-- | Transform a QueuedJob that has not been started into its failed form.
failQueuedJob :: ReasonElem -> Timestamp -> QueuedJob -> QueuedJob
jobFilePrefix :: String

-- | Computes the filename for a given job ID.
jobFileName :: JobId -> FilePath
parseJobFileId :: Monad m => FilePath -> m JobId

-- | Computes the full path to a live job.
liveJobFile :: FilePath -> JobId -> FilePath

-- | Computes the full path to an archives job. BROKEN.
archivedJobFile :: FilePath -> JobId -> FilePath
opStatusToJob :: OpStatus -> JobStatus

-- | Computes a queued job's status.
calcJobStatus :: QueuedJob -> JobStatus

-- | Determine if a job has started
jobStarted :: QueuedJob -> Bool

-- | Determine if a job is finalised.
jobFinalized :: QueuedJob -> Bool

-- | Determine if a job is finalized and its timestamp is before a given
--   time.
jobArchivable :: Timestamp -> QueuedJob -> Bool

-- | Determine whether an opcode status is finalized.
opStatusFinalized :: OpStatus -> Bool

-- | Compute a job's priority.
calcJobPriority :: QueuedJob -> Int
ignoreIOError :: a -> Bool -> String -> IOError -> IO a
allArchiveDirs :: FilePath -> IO [FilePath]

-- | Build list of directories containing job files. Note: compared to the
--   Python version, this doesn't ignore a potential lost+found file.
determineJobDirectories :: FilePath -> Bool -> IO [FilePath]

-- | Computes the list of all jobs in the given directories.
getJobIDs :: [FilePath] -> IO (GenericResult IOError [JobId])

-- | Sorts the a list of job IDs.
sortJobIDs :: [JobId] -> [JobId]
getDirJobIDs :: FilePath -> ResultT IOError IO [JobId]
readJobDataFromDisk :: FilePath -> Bool -> JobId -> IO (Maybe (String, Bool))

-- | Failed to load job error.
noSuchJob :: Result (QueuedJob, Bool)

-- | Loads a job from disk.
loadJobFromDisk :: FilePath -> Bool -> JobId -> IO (Result (QueuedJob, Bool))

-- | Write a job to disk.
writeJobToDisk :: FilePath -> QueuedJob -> IO (Result ())
replicateJob :: FilePath -> [Node] -> QueuedJob -> IO [(Node, ERpcError ())]

-- | Replicate many jobs to all master candidates.
replicateManyJobs :: FilePath -> [Node] -> [QueuedJob] -> IO ()

-- | Writes a job to a file and replicates it to master candidates.
writeAndReplicateJob :: Error e => ConfigData -> FilePath -> QueuedJob -> ResultT e IO [(Node, ERpcError ())]

-- | Read the job serial number from disk.
readSerialFromDisk :: IO (Result JobId)

-- | Allocate new job ids. To avoid races while accessing the serial file,
--   the threads synchronize over a lock, as usual provided by a Lock.
allocateJobIds :: [Node] -> Lock -> Int -> IO (Result [JobId])

-- | Allocate one new job id.
allocateJobId :: [Node] -> Lock -> IO (Result JobId)

-- | Decide if job queue is open
isQueueOpen :: IO Bool

-- | Start enqueued jobs by executing the Python code.
startJobs :: Livelock -> Lock -> [QueuedJob] -> IO [ErrorResult QueuedJob]
isQueuedJobDead :: MonadIO m => Livelock -> QueuedJob -> m Bool
waitForJob :: JobId -> Int -> ResultG (Bool, String)

-- | Try to cancel a job that has already been handed over to execution, by
--   terminating the process.
cancelJob :: Bool -> Livelock -> JobId -> IO (ErrorResult (Bool, String))

-- | Inform a job that it is requested to change its priority. This is done
--   by writing the new priority to a file and sending SIGUSR1.
tellJobPriority :: Livelock -> JobId -> Int -> IO (ErrorResult (Bool, String))

-- | Notify a job that something relevant happened, e.g., a lock became
--   available. We do this by sending sigHUP to the process.
notifyJob :: ProcessID -> IO (ErrorResult ())

-- | Permissions for the archive directories.
queueDirPermissions :: FilePermissions
archiveSomeJobsUntil :: ([JobId] -> IO ()) -> FilePath -> ClockTime -> Timestamp -> Int -> [JobId] -> [JobId] -> IO (Int, Int)

-- | Archive jobs older than the given time, but do not exceed the timeout
--   for carrying out this task.
archiveJobs :: ConfigData -> Int -> Int -> [JobId] -> IO (Int, Int)


-- | Cluster rebalancer.
module Ganeti.HTools.Program.Hbal

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
annotateOpCode :: Timestamp -> Annotator

-- | Start computing the solution at the given depth and recurse until we
--   find a valid solution or we exceed the maximum depth.
iterateDepth :: Bool -> AlgorithmOptions -> Table -> Int -> Int -> Int -> [MoveJob] -> Score -> IO (Table, [MoveJob])
printStats :: List -> List -> IO ()
maybeExecJobs :: Options -> [a] -> List -> List -> [JobSet] -> IO (Result ())
selectGroup :: Options -> List -> List -> List -> IO (String, (List, List))
checkCluster :: Int -> List -> List -> IO ()
checkGroup :: Bool -> Int -> String -> List -> List -> IO ()
checkNeedRebalance :: Options -> Score -> IO ()

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Cluster checker.
module Ganeti.HTools.Program.Hcheck

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
data Phase
Initial :: Phase
Rebalanced :: Phase
data Level
GroupLvl :: String -> Level
ClusterLvl :: Level
type GroupInfo = (Gdx, (List, List))
type GroupStats = ((Group, Double), [Int])
htcPrefix :: String
commonData :: [(String, String)]
groupData :: [(String, String)]
clusterData :: [(String, String)]
phasePrefix :: Phase -> String
levelPrefix :: Level -> String
keysData :: Level -> [String]
phaseDescr :: Phase -> String
descrData :: Level -> [String]
phaseLevelDescr :: Phase -> Level -> String
printKeysHTC :: [(String, String)] -> IO ()
printBool :: Bool -> Bool -> String
printGroupsMappings :: List -> IO ()
prepareKey :: Level -> Phase -> String -> String
printStats :: Int -> Bool -> Level -> Phase -> [String] -> IO ()
extractGroupData :: Bool -> Group -> String
prepareGroupValues :: [Int] -> Double -> [String]
prepareClusterValues :: Bool -> [Int] -> [Bool] -> [String]
printGroupStats :: Int -> Bool -> Phase -> GroupStats -> IO ()
printClusterStats :: Int -> Bool -> Phase -> [Int] -> Bool -> IO ()
clusterNeedsRebalance :: [Int] -> Bool
perGroupChecks :: List -> GroupInfo -> GroupStats
executeSimulation :: Options -> Table -> Double -> Gdx -> List -> List -> IO GroupInfo
maybeSimulateGroupRebalance :: Options -> GroupInfo -> IO GroupInfo
maybeSimulateRebalance :: Bool -> Options -> [GroupInfo] -> IO [GroupInfo]
printFinalHTC :: Bool -> IO ()

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Node freeing scheduler
module Ganeti.HTools.Program.Hsqueeze

-- | Options list and functions.
options :: IO [OptType]

-- | The list of arguments supported by the program.
arguments :: [ArgCompletion]
annotateOpCode :: Timestamp -> String -> Annotator
onlyExternal :: (List, List) -> Node -> Bool
noSecondaries :: Node -> Bool
allInstancesOnOnlineNodes :: (List, List) -> Bool
allNodesCapacityFor :: Instance -> (List, List) -> Bool
balance :: (List, List) -> ((List, List), [MoveJob])
onlineOfflineNode :: Bool -> (List, List) -> Ndx -> (List, List)
onlineOfflineNodes :: Bool -> [Ndx] -> (List, List) -> ((List, List), [MoveJob])
offlineNodes :: [Ndx] -> (List, List) -> ((List, List), [MoveJob])
onlineNodes :: [Ndx] -> (List, List) -> ((List, List), [MoveJob])
canOnlineOffline :: Bool -> Instance -> (List, List) -> [Node] -> Bool
canOffline :: Instance -> (List, List) -> [Node] -> Bool
sufficesOnline :: Instance -> (List, List) -> [Node] -> Bool
greedyOfflineNodes :: Instance -> (List, List) -> [Node] -> [Node]
tryOnline :: Instance -> (List, List) -> [Node] -> Maybe [Node]
instanceFromSpecAndFactor :: String -> Double -> ISpec -> Instance
getMoveOpCodes :: List -> List -> [JobSet] -> Result [([[OpCode]], String)]
getTagOpCodes :: [Node] -> Result [([[OpCode]], String)]
getPowerOffOpCodes :: [Node] -> Result [([[OpCode]], String)]
getPowerOnOpCodes :: [Node] -> Result [([[OpCode]], String)]
maybeExecJobs :: Options -> String -> Result [([[OpCode]], String)] -> IO (Result ())

-- | Main function.
main :: Options -> [String] -> IO ()


-- | Small module holding program definitions.
module Ganeti.HTools.Program.Main

-- | Supported binaries.
personalities :: PersonalityList Options
usage :: String -> IO ()
main :: IO ()


-- | Types for the JQScheduler.
module Ganeti.JQScheduler.Types
data JobWithStat
JobWithStat :: Maybe INotify -> FStat -> QueuedJob -> JobWithStat
jINotify :: JobWithStat -> Maybe INotify
jStat :: JobWithStat -> FStat
jJob :: JobWithStat -> QueuedJob
jJobL :: Lens' JobWithStat QueuedJob

-- | A job without <a>INotify</a> and <a>FStat</a>.
nullJobWithStat :: QueuedJob -> JobWithStat
data Queue
Queue :: [JobWithStat] -> [JobWithStat] -> [JobWithStat] -> Queue
qEnqueued :: Queue -> [JobWithStat]
qRunning :: Queue -> [JobWithStat]

-- | running jobs that are being manipulated by some thread
qManipulated :: Queue -> [JobWithStat]
qRunningL :: Lens' Queue [JobWithStat]
qManipulatedL :: Lens' Queue [JobWithStat]
qEnqueuedL :: Lens' Queue [JobWithStat]
instance Eq Queue
instance Show Queue
instance Eq JobWithStat
instance Show JobWithStat


-- | Filtering of jobs for the Ganeti job queue.
module Ganeti.JQScheduler.Filtering
accessOpCodeField :: OpCode -> String -> ErrorResult JSValue
opCodesOf :: QueuedJob -> [OpCode]
reasonsOf :: QueuedJob -> [ReasonElem]
evaluateFilterComparator :: Ord field => Filter field -> (Comparator -> field -> FilterValue -> Maybe Bool) -> Bool

-- | Whether a <a>FilterPredicate</a> is true for a job.
matchPredicate :: QueuedJob -> JobId -> FilterPredicate -> Bool

-- | Whether all predicates of the filter rule are true for the job.
matches :: QueuedJob -> FilterRule -> Bool
orderFilters :: Set FilterRule -> [FilterRule]

-- | Finds the first filter whose predicates all match the job and whose
--   action is not <a>Continue</a>. This is the <i>applying</i> filter.
applyingFilter :: Set FilterRule -> QueuedJob -> Maybe FilterRule
type RateLimitSlotMap = SlotMap String
data FilterChainState
FilterChainState :: RateLimitSlotMap -> FilterChainState
rateLimitSlotMap :: FilterChainState -> RateLimitSlotMap
tryFitSlots :: FilterChainState -> CountMap String -> Maybe FilterChainState
queueRateLimitSlotMap :: Queue -> Set FilterRule -> RateLimitSlotMap

-- | Implements job filtering as specified in `doc/design-optables.rst`.
--   
--   Importantly, the filter that *applies* is the first one of which all
--   predicates match; this is implemented in <a>applyingFilter</a>.
--   
--   The initial <a>FilterChainState</a> is currently not cached across
--   <tt>selectJobsToRun</tt> invocations because the number of running
--   jobs is typically small (&lt; 100).
jobFiltering :: Queue -> Set FilterRule -> [JobWithStat] -> [JobWithStat]
instance Eq FilterChainState
instance Ord FilterChainState
instance Show FilterChainState


-- | Ad-hoc rate limiting for the JQScheduler based on reason trails.
module Ganeti.JQScheduler.ReasonRateLimiting
type AdHocReasonKey = String

-- | Parses an ad-hoc rate limit from a reason trail, as defined under
--   <a>Ad-Hoc Rate Limiting</a> in `doc/design-optables.rst`.
--   
--   The parse succeeds only on reasons of form `rate-limit:n:REASONSTRING`
--   where <tt>n</tt> is a positive integer and <tt>REASONSTRING</tt> is an
--   arbitrary string (may include spaces).
parseReasonRateLimit :: Monad m => String -> m (String, Int)
labelCountMapFromJob :: QueuedJob -> CountMap (String, Int)

-- | Computes the bucket slots required by a job.
countMapFromJob :: QueuedJob -> CountMap AdHocReasonKey

-- | Map of how many slots are in use for a given bucket, for a list of
--   jobs. The slot limits are taken from the ad-hoc reason rate limiting
--   strings.
slotMapFromJobs :: [QueuedJob] -> SlotMap AdHocReasonKey
unoccupiedSlotMapFromJobs :: [QueuedJob] -> SlotMap AdHocReasonKey

-- | Implements ad-hoc rate limiting using the reason trail as specified in
--   `doc/design-optables.rst`.
--   
--   Reasons of form `rate-limit:n:REASONSTRING` define buckets that limit
--   how many jobs with that reason can be running at the same time to a
--   positive integer n of available slots.
--   
--   The used buckets map is currently not cached across
--   <tt>selectJobsToRun</tt> invocations because the number of running
--   jobs is typically small (&lt; 100).
reasonRateLimit :: Queue -> [JobWithStat] -> [JobWithStat]


-- | Implementation of a reader for the job queue.
module Ganeti.JQScheduler

-- | Representation of the job queue
--   
--   We keep two lists of jobs (together with information about the last
--   fstat result observed): the jobs that are enqueued, but not yet handed
--   over for execution, and the jobs already handed over for execution.
--   They are kept together in a single IORef, so that we can atomically
--   update both, in particular when scheduling jobs to be handed over for
--   execution.
data JQStatus
JQStatus :: IORef Queue -> IORef (Result ConfigData) -> Livelock -> Lock -> JQStatus
jqJobs :: JQStatus -> IORef Queue
jqConfig :: JQStatus -> IORef (Result ConfigData)
jqLivelock :: JQStatus -> Livelock
jqForkLock :: JQStatus -> Lock
emptyJQStatus :: IORef (Result ConfigData) -> IO JQStatus
onRunningJobs :: ([JobWithStat] -> [JobWithStat]) -> Queue -> Queue
onQueuedJobs :: ([JobWithStat] -> [JobWithStat]) -> Queue -> Queue
unreadJob :: QueuedJob -> JobWithStat
watchInterval :: Int
getConfigValue :: (Cluster -> a) -> a -> JQStatus -> IO a
getMaxRunningJobs :: JQStatus -> IO Int
getMaxTrackedJobs :: JQStatus -> IO Int
getRQL :: JQStatus -> IO Int
modifyJobs :: JQStatus -> (Queue -> Queue) -> IO ()
readJobStatus :: JobWithStat -> IO (Maybe JobWithStat)
updateJobStatus :: JobWithStat -> [JobWithStat] -> [JobWithStat]
updateJob :: JQStatus -> JobWithStat -> IO ()
moveJob :: Lens' Queue [JobWithStat] -> Lens' Queue [JobWithStat] -> JobId -> Queue -> (Queue, Maybe JobWithStat)
moveJobAtomic :: Lens' Queue [JobWithStat] -> Lens' Queue [JobWithStat] -> JobId -> JQStatus -> IO (Maybe JobWithStat)
manipulateRunningJob :: JQStatus -> JobId -> IO a -> IO (Maybe a)
sortoutFinishedJobs :: Queue -> (Queue, [JobWithStat])
cleanupFinishedJobs :: JQStatus -> IO ()
jobWatcher :: JQStatus -> JobWithStat -> Event -> IO ()
attachWatcher :: JQStatus -> JobWithStat -> IO ()
jobEligible :: Queue -> JobWithStat -> Bool

-- | Decide on which jobs to schedule next for execution. This is the pure
--   function doing the scheduling.
selectJobsToRun :: Int -> Set FilterRule -> Queue -> (Queue, [JobWithStat])
logFailedJobs :: MonadLog m => [(JobWithStat, GanetiException)] -> m (Set JobId)
failJobs :: ConfigData -> JQStatus -> [(JobWithStat, GanetiException)] -> IO ()
cancelRejectedJobs :: JQStatus -> ConfigData -> Set FilterRule -> IO ()

-- | Schedule jobs to be run. This is the IO wrapper around the pure
--   <a>selectJobsToRun</a>.
scheduleSomeJobs :: JQStatus -> IO ()
showQueue :: Queue -> String
checkForDeath :: JQStatus -> JobWithStat -> IO Bool

-- | Trigger job detection for the job with the given job id. Return True,
--   if the job is dead.
cleanupIfDead :: JQStatus -> JobId -> IO Bool
onTimeWatcher :: JQStatus -> IO ()
readJobFromDisk :: JobId -> IO (Result JobWithStat)
readJobsFromDisk :: IO [JobWithStat]

-- | Set up the job scheduler. This will also start the monitoring of
--   changes to the running jobs.
initJQScheduler :: JQStatus -> IO ()

-- | Enqueue new jobs. This will guarantee that the jobs will be executed
--   eventually.
enqueueNewJobs :: JQStatus -> [QueuedJob] -> IO ()
rmJob :: JobId -> Queue -> (Queue, Result (Maybe QueuedJob))

-- | Try to remove a queued job from the job queue. Return True, if the job
--   could be removed from the queue before being handed over to execution,
--   False if the job already started, and a Bad result if the job is
--   unknown.
dequeueJob :: JQStatus -> JobId -> IO (Result Bool)

-- | Change the priority of a queued job (once the job is handed over to
--   execution, the job itself needs to be informed). To avoid the job
--   being started unmodified, it is temporarily unqueued during the
--   change. Return the modified job, if the job's priority was sucessfully
--   modified, Nothing, if the job already started, and a Bad value, if the
--   job is unkown.
setJobPriority :: JQStatus -> JobId -> Int -> IO (Result (Maybe QueuedJob))

-- | Given old and new configs, determines if the changes between them
--   should trigger the scheduler to run.
configChangeNeedsRescheduling :: ConfigData -> ConfigData -> Bool


-- | Implementation of the Ganeti Query2 job queries.
module Ganeti.Query.Job

-- | The runtime data for a job.
type RuntimeData = Result (QueuedJob, Bool)
jobPrioDoc :: String
tsDoc :: String -> String
maybeJob :: JSON a => (QueuedJob -> a) -> RuntimeData -> JobId -> ResultEntry
maybeJobOpt :: JSON a => (QueuedJob -> Maybe a) -> RuntimeData -> JobId -> ResultEntry
jobGetter :: JSON a => (QueuedJob -> a) -> FieldGetter JobId RuntimeData
opsGetter :: JSON a => (QueuedOpCode -> a) -> FieldGetter JobId RuntimeData
opsOptGetter :: JSON a => (QueuedOpCode -> Maybe a) -> FieldGetter JobId RuntimeData
archivedField :: String

-- | Check whether we should look at archived jobs as well.
wantArchived :: [FilterField] -> Bool
jobFields :: FieldList JobId RuntimeData

-- | The node fields map.
fieldsMap :: FieldMap JobId RuntimeData


-- | Utility functions for working with IORefs.
module Ganeti.Utils.IORef

-- | Atomically modifies an <a>IORef</a> using a lens
atomicModifyWithLens :: MonadBase IO m => IORef a -> Lens a a b c -> (b -> (r, c)) -> m r

-- | Atomically modifies an <a>IORef</a> using a function that can possibly
--   fail. If it fails, the value of the <a>IORef</a> is preserved.
atomicModifyIORefErr :: MonadBase IO m => IORef a -> (a -> GenericResult e (a, b)) -> ResultT e m b

-- | Atomically modifies an <a>IORef</a> using a function that can possibly
--   fail and log errors. If it fails, the value of the <a>IORef</a> is
--   preserved. Any log messages are passed to the outer monad.
atomicModifyIORefErrLog :: (MonadBase IO m, MonadLog m) => IORef a -> (a -> ResultT e WriterLog (a, b)) -> ResultT e m b


-- | Pure functions for manipulating reservations of temporary objects
--   
--   NOTE: Reservations aren't released specifically, they're just all
--   released at the end of a job. This could be improved in the future.
module Ganeti.WConfd.TempRes
type NodeUUID = String
type InstanceUUID = String
type DiskUUID = String
type NetworkUUID = String
type DRBDMinor = Int

-- | A map of the usage of DRBD minors
type DRBDMap = Map NodeUUID (Map DRBDMinor DiskUUID)
type DRBDMap' = Map NodeUUID (Map DRBDMinor [DiskUUID])

-- | Types of IPv4 reservation actions.
data IPv4ResAction
IPv4Reserve :: IPv4ResAction
IPv4Release :: IPv4ResAction

-- | The values stored in the IPv4 reservation table.
data IPv4Reservation
IPv4Res :: IPv4ResAction -> NetworkUUID -> Ip4Address -> IPv4Reservation
ipv4ResAction :: IPv4Reservation -> IPv4ResAction
ipv4ResNetwork :: IPv4Reservation -> NetworkUUID
ipv4ResAddr :: IPv4Reservation -> Ip4Address

-- | A polymorphic data structure for managing temporary resources assigned
--   to jobs.
newtype TempRes j a
TempRes :: MultiMap j a -> TempRes j a
getTempRes :: TempRes j a -> MultiMap j a

-- | Create a temporary reservations from a given multi-map.
mkTempRes :: MultiMap j a -> TempRes j a

-- | The state of the temporary reservations
data TempResState
TempResState :: DRBDMap -> TempRes ClientId MAC -> TempRes ClientId DRBDSecret -> TempRes ClientId LogicalVolume -> TempRes ClientId IPv4Reservation -> TempResState
trsDRBD :: TempResState -> DRBDMap
trsMACs :: TempResState -> TempRes ClientId MAC
trsDRBDSecrets :: TempResState -> TempRes ClientId DRBDSecret
trsLVs :: TempResState -> TempRes ClientId LogicalVolume
trsIPv4s :: TempResState -> TempRes ClientId IPv4Reservation
loadTempResState :: JSValue -> Result TempResState
saveTempResState :: TempResState -> JSValue
emptyTempResState :: TempResState
trsMACsL :: Lens' TempResState (TempRes ClientId MAC)
trsLVsL :: Lens' TempResState (TempRes ClientId LogicalVolume)
trsIPv4sL :: Lens' TempResState (TempRes ClientId IPv4Reservation)
trsDRBDSecretsL :: Lens' TempResState (TempRes ClientId DRBDSecret)
trsDRBDL :: Lens' TempResState DRBDMap
resError :: MonadError GanetiException m => String -> m a
toResError :: MonadError GanetiException m => m a -> m a
filterNested :: (Ord a, Ord b) => (c -> Bool) -> Map a (Map b c) -> Map a (Map b c)
maybeLens :: (Monoid a, Monoid b, Eq b) => Lens s t (Maybe a) (Maybe b) -> Lens s t a b

-- | Compute the map of used DRBD minor/nodes, including possible
--   duplicates. An error is returned if the configuration isn't consistent
--   (for example if a referenced disk is missing etc.).
computeDRBDMap' :: MonadError GanetiException m => ConfigData -> TempResState -> m DRBDMap'

-- | Compute the map of used DRBD minor/nodes. Report any duplicate entries
--   as an error.
--   
--   Unlike <a>computeDRBDMap'</a>, includes entries for all nodes, even if
--   empty.
computeDRBDMap :: MonadError GanetiException m => ConfigData -> TempResState -> m DRBDMap
allocateDRBDMinor :: (MonadError GanetiException m, MonadState TempResState m) => ConfigData -> DiskUUID -> [NodeUUID] -> m [DRBDMinor]
releaseDRBDMinors :: MonadState TempResState m => DiskUUID -> m ()

-- | Tests if a given value is reserved for a given job.
isReserved :: (Ord a, Ord j) => a -> TempRes j a -> Bool

-- | Tries to reserve a given value for a given job.
reserve :: (MonadError GanetiException m, Show a, Ord a, Ord j) => j -> a -> TempRes j a -> m (TempRes j a)
dropReservationsFor :: (Ord a, Ord j) => j -> TempRes j a -> TempRes j a
reservedFor :: (Ord a, Ord j) => j -> TempRes j a -> Set a
reserved :: (Ord a, Ord j) => TempRes j a -> Set a
withReserved :: (MonadError GanetiException m, Show a, Ord a, Ord j) => j -> (Set a -> m a) -> TempRes j a -> m (a, TempRes j a)
generate :: (MonadError GanetiException m, Show a, Ord a, Ord j) => j -> Set a -> m (Maybe a) -> TempRes j a -> m (a, TempRes j a)
generateRand :: (MonadError GanetiException m, Show a, Ord a, Ord j, RandomGen g) => g -> j -> Set a -> (g -> (Maybe a, g)) -> TempRes j a -> m (a, TempRes j a)
stateM :: MonadState s m => (s -> m (a, s)) -> m a
modifyM :: MonadState s m => (s -> m s) -> m ()

-- | Removes all resources reserved by a given job.
--   
--   If a new reservation resource type is added, it must be added here as
--   well.
dropAllReservations :: ClientId -> State TempResState ()
lookupNetwork :: MonadError GanetiException m => ConfigData -> NetworkUUID -> m Network
generateMAC :: (RandomGen g, MonadError GanetiException m, Functor m) => g -> ClientId -> Maybe NetworkUUID -> ConfigData -> StateT TempResState m MAC
reserveMAC :: (MonadError GanetiException m, MonadState TempResState m, Functor m) => ClientId -> MAC -> ConfigData -> m ()
generateDRBDSecret :: (RandomGen g, MonadError GanetiException m, Functor m) => g -> ClientId -> ConfigData -> StateT TempResState m DRBDSecret
reserveLV :: (MonadError GanetiException m, MonadState TempResState m, Functor m) => ClientId -> LogicalVolume -> ConfigData -> m ()
usedIPv4Addrs :: NetworkUUID -> Set IPv4Reservation -> Set Ip4Address

-- | Reserve a given IPv4 address for use by an instance.
reserveIp :: (MonadError GanetiException m, MonadState TempResState m, Functor m) => ClientId -> NetworkUUID -> Ip4Address -> Bool -> ConfigData -> m ()

-- | Give a specific IP address back to an IP pool. The IP address is
--   returned to the IP pool designated by network id and marked as
--   reserved.
releaseIp :: (MonadError GanetiException m, MonadState TempResState m, Functor m) => ClientId -> NetworkUUID -> Ip4Address -> m ()
generateIp :: (MonadError GanetiException m, MonadState TempResState m, Functor m) => ClientId -> NetworkUUID -> ConfigData -> m Ip4Address
commitIp :: (MonadError GanetiException m, Functor m) => IPv4Reservation -> ConfigData -> m ConfigData

-- | Immediately release an IP address, without using the reservations
--   pool.
commitReleaseIp :: (MonadError GanetiException m, Functor m) => NetworkUUID -> Ip4Address -> ConfigData -> m ConfigData

-- | Commit all reserved/released IP address to an IP pool. The IP
--   addresses are taken from the network's IP pool and marked as
--   reserved/free for instances.
--   
--   Note that the reservations are kept, they are supposed to be cleaned
--   when a job finishes.
commitReservedIps :: (MonadError GanetiException m, Functor m, MonadLog m) => ClientId -> TempResState -> ConfigData -> m ConfigData
listReservedIps :: ClientId -> TempResState -> Set IPv4Reservation
instance Show TempResState
instance Eq TempResState
instance JSON TempResState
instance ArrayObject TempResState
instance DictObject TempResState
instance Eq IPv4ResAction
instance Ord IPv4ResAction
instance Show IPv4ResAction
instance Bounded IPv4ResAction
instance Enum IPv4ResAction
instance Eq IPv4Reservation
instance Ord IPv4Reservation
instance Show IPv4Reservation
instance (Eq j, Eq a) => Eq (TempRes j a)
instance (Ord j, Ord a) => Ord (TempRes j a)
instance (Show j, Show a) => Show (TempRes j a)
instance (JSON j, Ord j, JSON a, Ord a) => JSON (TempRes j a)
instance (Ord j, Ord a) => Monoid (TempRes j a)
instance JSON IPv4Reservation
instance JSON IPv4ResAction


-- | All RPC calls are run within this monad.
--   
--   It encapsulates:
--   
--   <ul>
--   <li>IO operations, * failures, * working with the daemon state.</li>
--   </ul>
--   
--   Code that is specific either to the configuration or the lock
--   management, should go into their corresponding dedicated modules.
module Ganeti.WConfd.Monad
data DaemonState
DaemonState :: ConfigState -> GanetiLockWaiting -> TempResState -> DaemonState
dsConfigState :: DaemonState -> ConfigState
dsLockWaiting :: DaemonState -> GanetiLockWaiting
dsTempRes :: DaemonState -> TempResState
dsTempResL :: Lens' DaemonState TempResState
dsLockWaitingL :: Lens' DaemonState GanetiLockWaiting
dsConfigStateL :: Lens' DaemonState ConfigState
data DaemonHandle
DaemonHandle :: IORef DaemonState -> FilePath -> AsyncWorker Any () -> AsyncWorker () () -> AsyncWorker () () -> Livelock -> DaemonHandle
dhDaemonState :: DaemonHandle -> IORef DaemonState

-- | The configuration file path all static information that doesn't change
--   during the life-time of the daemon should go here; all IDs of threads
--   that do asynchronous work should probably also go here
dhConfigPath :: DaemonHandle -> FilePath
dhSaveConfigWorker :: DaemonHandle -> AsyncWorker Any ()
dhSaveLocksWorker :: DaemonHandle -> AsyncWorker () ()
dhSaveTempResWorker :: DaemonHandle -> AsyncWorker () ()
dhLivelock :: DaemonHandle -> Livelock
mkDaemonHandle :: FilePath -> ConfigState -> GanetiLockWaiting -> TempResState -> (IO ConfigState -> [AsyncWorker () ()] -> ResultG (AsyncWorker Any ())) -> (IO ConfigState -> ResultG (AsyncWorker () ())) -> (IO ConfigState -> ResultG (AsyncWorker () ())) -> (IO GanetiLockWaiting -> ResultG (AsyncWorker () ())) -> (IO TempResState -> ResultG (AsyncWorker () ())) -> Livelock -> ResultG DaemonHandle
type WConfdMonadIntType = ReaderT DaemonHandle IO

-- | The internal part of the monad without error handling.
newtype WConfdMonadInt a
WConfdMonadInt :: WConfdMonadIntType a -> WConfdMonadInt a
getWConfdMonadInt :: WConfdMonadInt a -> WConfdMonadIntType a

-- | Runs the internal part of the WConfdMonad monad on a given daemon
--   handle.
runWConfdMonadInt :: WConfdMonadInt a -> DaemonHandle -> IO a

-- | The complete monad with error handling.
type WConfdMonad = ResultT GanetiException WConfdMonadInt
type AtomicModifyMonad a = ResultT GanetiException WriterLog a

-- | Returns the daemon handle.
daemonHandle :: WConfdMonad DaemonHandle

-- | Returns the current configuration, given a handle
readConfigState :: WConfdMonad ConfigState
unpackConfigResult :: ClockTime -> ConfigState -> (a, ConfigState) -> ((a, Bool, Bool), ConfigState)
modifyConfigStateErrWithImmediate :: (TempResState -> ConfigState -> AtomicModifyMonad (a, ConfigState)) -> WConfdMonad () -> WConfdMonad a
modifyConfigStateErr :: (TempResState -> ConfigState -> AtomicModifyMonad (a, ConfigState)) -> WConfdMonad a
modifyConfigStateErr_ :: (TempResState -> ConfigState -> AtomicModifyMonad ConfigState) -> WConfdMonad ()

-- | Atomically modifies the configuration state in the WConfdMonad.
modifyConfigState :: (ConfigState -> (a, ConfigState)) -> WConfdMonad a

-- | Atomically modifies the configuration state in WConfdMonad;
--   immediately afterwards (while the config write-out is not necessarily
--   finished) do another acation.
modifyConfigStateWithImmediate :: (ConfigState -> (a, ConfigState)) -> WConfdMonad () -> WConfdMonad a

-- | Force the distribution of configuration without actually modifying it.
--   
--   We need a separate call for this operation, because
--   <a>modifyConfigState</a> only triggers the distribution when the
--   configuration changes.
forceConfigStateDistribution :: WConfdMonad ()

-- | Atomically modifies the configuration data in the WConfdMonad with a
--   computation that can possibly fail.
modifyConfigDataErr_ :: (TempResState -> ConfigData -> AtomicModifyMonad ConfigData) -> WConfdMonad ()

-- | Atomically modifies the state of temporary reservations in WConfdMonad
--   in the presence of possible errors.
modifyTempResStateErr :: (ConfigData -> StateT TempResState ErrorResult a) -> WConfdMonad a

-- | Atomically modifies the state of temporary reservations in
--   WConfdMonad.
modifyTempResState :: (ConfigData -> State TempResState a) -> WConfdMonad a

-- | Reads the state of of the configuration and temporary reservations in
--   WConfdMonad.
readTempResState :: WConfdMonad (ConfigData, TempResState)

-- | Atomically modifies the lock waiting state in WConfdMonad.
modifyLockWaiting :: (GanetiLockWaiting -> (GanetiLockWaiting, (a, Set ClientId))) -> WConfdMonad a

-- | Atomically modifies the lock allocation state in WConfdMonad, not
--   producing any result
modifyLockWaiting_ :: (GanetiLockWaiting -> (GanetiLockWaiting, Set ClientId)) -> WConfdMonad ()

-- | Read the lock waiting state in WConfdMonad.
readLockWaiting :: WConfdMonad GanetiLockWaiting

-- | Read the underlying lock allocation.
readLockAllocation :: WConfdMonad (LockAllocation GanetiLocks ClientId)

-- | Modify the configuration while temporarily acquiring the configuration
--   lock. If the configuration lock is held by someone else, nothing is
--   changed and Nothing is returned.
modifyConfigWithLock :: (TempResState -> ConfigState -> AtomicModifyMonad ConfigState) -> State TempResState () -> WConfdMonad (Maybe ())
instance Functor WConfdMonadInt
instance Applicative WConfdMonadInt
instance Monad WConfdMonadInt
instance MonadIO WConfdMonadInt
instance MonadBase IO WConfdMonadInt
instance MonadLog WConfdMonadInt
instance MonadBaseControl IO WConfdMonadInt


-- | The WConfd functions for direct configuration manipulation
--   
--   This module contains the client functions exported by WConfD for
--   specific configuration manipulation.
module Ganeti.WConfd.ConfigModifications

-- | Add a new instance to the configuration, release DRBD minors, and
--   commit temporary IPs, all while temporarily holding the config lock.
--   Return True upon success and False if the config lock was not
--   available and the client should retry.
--   
--   TODO: add verifications to this call; the client should have a lock on
--   the name of the instance, and no instance with the given uuid should
--   exist.
addInstance :: Instance -> ClientId -> WConfdMonad Bool
exportedFunctions :: [Name]


-- | Converts a configuration state into a Ssconf map.
--   
--   As TemplateHaskell require that splices be defined in a separate
--   module, we combine all the TemplateHaskell functionality that HTools
--   needs in this module (except the one for unittests).
module Ganeti.WConfd.Ssconf
eqPair :: (String, String) -> String
mkSSConfHvparams :: Cluster -> [(Hypervisor, [String])]
mkSSConf :: ConfigData -> SSConf


-- | Implementation of functions specific to configuration management.
module Ganeti.WConfd.ConfigWriter

-- | Loads the configuration from the file, if it hasn't been loaded yet.
--   The function is internal and isn't thread safe.
loadConfigFromFile :: FilePath -> ResultG (ConfigData, FStat)
writeConfigToFile :: (MonadBase IO m, MonadError GanetiException m, MonadLog m) => ConfigData -> FilePath -> FStat -> m FStat
readConfig :: WConfdMonad ConfigData
writeConfig :: ConfigData -> WConfdMonad ()
finishOrLog :: (Show e, MonadLog m) => Priority -> String -> (a -> m ()) -> GenericResult e a -> m ()
mkStatelessAsyncTask :: (MonadBaseControl IO m, MonadLog m, Show e, Monoid i) => Priority -> String -> (i -> ResultT e m ()) -> m (AsyncWorker i ())
mkStatefulAsyncTask :: (MonadBaseControl IO m, MonadLog m, Show e, Monoid i) => Priority -> String -> s -> (s -> i -> ResultT e m s) -> m (AsyncWorker i ())

-- | Construct an asynchronous worker whose action is to save the
--   configuration to the master file. The worker's action reads the
--   configuration using the given <tt>IO</tt> action and uses <a>FStat</a>
--   to check if the configuration hasn't been modified by another process.
--   
--   If <a>Any</a> of the input requests is true, given additional worker
--   will be executed synchronously after sucessfully writing the
--   configuration file. Otherwise, they'll be just triggered
--   asynchronously.
saveConfigAsyncTask :: FilePath -> FStat -> IO ConfigState -> [AsyncWorker () ()] -> ResultG (AsyncWorker Any ())
execRpcCallAndLog :: Rpc a b => [Node] -> a -> ResultG ()

-- | Construct an asynchronous worker whose action is to distribute the
--   configuration to master candidates.
distMCsAsyncTask :: RuntimeEnts -> FilePath -> IO ConfigState -> ResultG (AsyncWorker () ())

-- | Construct an asynchronous worker whose action is to construct SSConf
--   and distribute it to master candidates. The worker's action reads the
--   configuration using the given <tt>IO</tt> action, computes the current
--   SSConf, compares it to the previous version, and if different,
--   distributes it.
distSSConfAsyncTask :: IO ConfigState -> ResultG (AsyncWorker () ())


-- | Common types and functions for persistent resources
--   
--   In particular: - locks - temporary reservations
module Ganeti.WConfd.Persistent

-- | A collection of operations needed for persisting a resource.
data Persistent a
Persistent :: String -> IO FilePath -> a -> (ClientId -> WConfdMonad ()) -> Persistent a
persName :: Persistent a -> String
persPath :: Persistent a -> IO FilePath
persEmpty :: Persistent a -> a

-- | The clean-up action needs to be a full <a>WConfdMonad</a> action as it
--   might need to do some complex processing, such as notifying clients
--   that some locks are available.
persCleanup :: Persistent a -> ClientId -> WConfdMonad ()

-- | Construct an asynchronous worker whose action is to save the current
--   state of the persistent state. The worker's action reads the state
--   using the given <tt>IO</tt> action. Any inbetween changes to the file
--   are tacitly ignored.
writePersistentAsyncTask :: JSON a => Persistent a -> IO a -> ResultG (AsyncWorker () ())

-- | Load a persistent data structure from disk.
readPersistent :: JSON a => Persistent a -> ResultG a
persistentLocks :: Persistent GanetiLockWaiting
persistentTempRes :: Persistent TempResState


-- | Utility function for detecting the death of a job holding resources
--   
--   To clean up resources owned by jobs that die for some reason, we need
--   to detect whether a job is still alive. As we have no control over PID
--   reuse, our approach is that each requester for a resource has to
--   provide a file where it owns an exclusive lock on. The kernel will
--   make sure the lock is removed if the process dies. We can probe for
--   such a lock by requesting a shared lock on the file.
module Ganeti.WConfd.DeathDetection
cleanupInterval :: Int

-- | Go through all owners once and clean them up, if they're dead.
cleanupLocks :: WConfdMonad ()

-- | Thread periodically cleaning up locks of lock owners that died.
cleanupLocksTask :: WConfdMonadInt ()


-- | The Ganeti WConfd core functions.
--   
--   This module defines all the functions that WConfD exports for RPC
--   calls. They are in a separate module so that in a later stage,
--   TemplateHaskell can generate, e.g., the python interface for those.
module Ganeti.WConfd.Core
echo :: String -> WConfdMonad String
checkConfigLock :: ClientId -> OwnerState -> WConfdMonad ()

-- | Read the configuration.
readConfig :: WConfdMonad ConfigData

-- | Write the configuration, checking that an exclusive lock is held. If
--   not, the call fails.
writeConfig :: ClientId -> ConfigData -> WConfdMonad ()

-- | Explicitly run verification of the configuration. The caller doesn't
--   need to hold the configuration lock.
verifyConfig :: WConfdMonad ()

-- | Tries to acquire <a>ConfigLock</a> for the client. If the second
--   parameter is set to <a>True</a>, the lock is acquired in shared mode.
--   
--   If the lock was successfully acquired, returns the current
--   configuration state.
lockConfig :: ClientId -> Bool -> WConfdMonad (MaybeForJSON ConfigData)

-- | Release the config lock, if the client currently holds it.
unlockConfig :: ClientId -> WConfdMonad ()

-- | Write the configuration, if the config lock is held exclusively, and
--   release the config lock. It the caller does not have the config lock,
--   return False.
writeConfigAndUnlock :: ClientId -> ConfigData -> WConfdMonad Bool

-- | Force the distribution of configuration without actually modifying it.
--   It is not necessary to hold a lock for this operation.
flushConfig :: WConfdMonad ()
dropAllReservations :: ClientId -> WConfdMonad ()
computeDRBDMap :: WConfdMonad DRBDMap
allocateDRBDMinor :: DiskUUID -> [NodeUUID] -> WConfdMonad [DRBDMinor]
releaseDRBDMinors :: DiskUUID -> WConfdMonad ()
generateMAC :: ClientId -> MaybeForJSON NetworkUUID -> WConfdMonad MAC
reserveMAC :: ClientId -> MAC -> WConfdMonad ()
generateDRBDSecret :: ClientId -> WConfdMonad DRBDSecret
reserveLV :: ClientId -> LogicalVolume -> WConfdMonad ()

-- | Reserve a given IPv4 address for use by an instance.
reserveIp :: ClientId -> NetworkUUID -> Ip4Address -> Bool -> WConfdMonad ()

-- | Give a specific IP address back to an IP pool. The IP address is
--   returned to the IP pool designated by network id and marked as
--   reserved.
releaseIp :: ClientId -> NetworkUUID -> Ip4Address -> WConfdMonad ()
generateIp :: ClientId -> NetworkUUID -> WConfdMonad Ip4Address

-- | Commit all reserved/released IP address to an IP pool. The IP
--   addresses are taken from the network's IP pool and marked as
--   reserved/free for instances.
--   
--   Note that the reservations are kept, they are supposed to be cleaned
--   when a job finishes.
commitTemporaryIps :: ClientId -> WConfdMonad ()

-- | Immediately release an IP address, without using the reservations
--   pool.
commitReleaseTemporaryIp :: NetworkUUID -> Ip4Address -> WConfdMonad ()

-- | List all IP reservations for the current client.
--   
--   This function won't be needed once the corresponding calls are moved
--   to WConfd.
listReservedIps :: ClientId -> WConfdMonad [IPv4Reservation]

-- | List the locks of a given owner (i.e., a job-id lockfile pair).
listLocks :: ClientId -> WConfdMonad [(GanetiLocks, OwnerState)]

-- | List all active locks.
listAllLocks :: WConfdMonad [GanetiLocks]

-- | List all active locks with their owners.
listAllLocksOwners :: WConfdMonad [(GanetiLocks, [(ClientId, OwnerState)])]

-- | Get full information of the lock waiting status, i.e., provide the
--   information about all locks owners and all pending requests.
listLocksWaitingStatus :: WConfdMonad ([(GanetiLocks, [(ClientId, OwnerState)])], [(Integer, ClientId, [LockRequest GanetiLocks])])

-- | Try to update the locks of a given owner (i.e., a job-id lockfile
--   pair). This function always returns immediately. If the lock update
--   was possible, the empty list is returned; otherwise, the lock status
--   is left completly unchanged, and the return value is the list of jobs
--   which need to release some locks before this request can succeed.
tryUpdateLocks :: ClientId -> GanetiLockRequest -> WConfdMonad [ClientId]

-- | Try to update the locks of a given owner and make that a pending
--   request if not immediately possible.
updateLocksWaiting :: ClientId -> Integer -> GanetiLockRequest -> WConfdMonad [ClientId]

-- | Tell whether a given owner has pending requests.
hasPendingRequest :: ClientId -> WConfdMonad Bool

-- | Free all locks of a given owner (i.e., a job-id lockfile pair).
freeLocks :: ClientId -> WConfdMonad ()

-- | Free all locks of a given owner (i.e., a job-id lockfile pair) of a
--   given level in the Ganeti sense (e.g., <a>cluster</a>, <a>node</a>).
freeLocksLevel :: ClientId -> LockLevel -> WConfdMonad ()

-- | Downgrade all locks of the given level to shared.
downGradeLocksLevel :: ClientId -> LockLevel -> WConfdMonad ()

-- | Intersect the possesed locks of an owner with a given set.
intersectLocks :: ClientId -> [GanetiLocks] -> WConfdMonad ()

-- | Opportunistically allocate locks for a given owner.
opportunisticLockUnion :: ClientId -> [(GanetiLocks, OwnerState)] -> WConfdMonad [GanetiLocks]

-- | Opprtunistially allocate locks for a given owner, requesting a certain
--   minimum of success.
guardedOpportunisticLockUnion :: Int -> ClientId -> [(GanetiLocks, OwnerState)] -> WConfdMonad [GanetiLocks]

-- | Prepare daemon for cluster destruction. This consists of verifying
--   that the requester owns the BGL exclusively, transfering the BGL to
--   WConfD itself, and modifying the configuration so that no node is the
--   master any more. Note that, since we own the BGL exclusively, we can
--   safely modify the configuration, as no other process can request
--   changes.
prepareClusterDestruction :: ClientId -> WConfdMonad ()
exportedFunctions :: [Name]


-- | The Ganeti WConfd client functions.
--   
--   The client functions are automatically generated from
--   Ganeti.WConfd.Core
module Ganeti.WConfd.Client
addInstance :: Instance -> ClientId -> RpcClientMonad Bool
hasPendingRequest :: ClientId -> RpcClientMonad Bool
guardedOpportunisticLockUnion :: Int -> ClientId -> [(GanetiLocks, OwnerState)] -> RpcClientMonad [GanetiLocks]
opportunisticLockUnion :: ClientId -> [(GanetiLocks, OwnerState)] -> RpcClientMonad [GanetiLocks]
intersectLocks :: ClientId -> [GanetiLocks] -> RpcClientMonad ()
downGradeLocksLevel :: ClientId -> LockLevel -> RpcClientMonad ()
freeLocksLevel :: ClientId -> LockLevel -> RpcClientMonad ()
freeLocks :: ClientId -> RpcClientMonad ()
updateLocksWaiting :: ClientId -> Integer -> GanetiLockRequest -> RpcClientMonad [ClientId]
tryUpdateLocks :: ClientId -> GanetiLockRequest -> RpcClientMonad [ClientId]
listLocksWaitingStatus :: RpcClientMonad ([(GanetiLocks, [(ClientId, OwnerState)])], [(Integer, ClientId, [LockRequest GanetiLocks])])
listAllLocksOwners :: RpcClientMonad [(GanetiLocks, [(ClientId, OwnerState)])]
listAllLocks :: RpcClientMonad [GanetiLocks]
listLocks :: ClientId -> RpcClientMonad [(GanetiLocks, OwnerState)]
listReservedIps :: ClientId -> RpcClientMonad [IPv4Reservation]
commitReleaseTemporaryIp :: NetworkUUID -> Ip4Address -> RpcClientMonad ()
commitTemporaryIps :: ClientId -> RpcClientMonad ()
generateIp :: ClientId -> NetworkUUID -> RpcClientMonad Ip4Address
releaseIp :: ClientId -> NetworkUUID -> Ip4Address -> RpcClientMonad ()
reserveIp :: ClientId -> NetworkUUID -> Ip4Address -> Bool -> RpcClientMonad ()
reserveLV :: ClientId -> LogicalVolume -> RpcClientMonad ()
generateDRBDSecret :: ClientId -> RpcClientMonad DRBDSecret
generateMAC :: ClientId -> MaybeForJSON NetworkUUID -> RpcClientMonad MAC
reserveMAC :: ClientId -> MAC -> RpcClientMonad ()
releaseDRBDMinors :: DiskUUID -> RpcClientMonad ()
allocateDRBDMinor :: DiskUUID -> [NodeUUID] -> RpcClientMonad [DRBDMinor]
computeDRBDMap :: RpcClientMonad DRBDMap
dropAllReservations :: ClientId -> RpcClientMonad ()
flushConfig :: RpcClientMonad ()
writeConfigAndUnlock :: ClientId -> ConfigData -> RpcClientMonad Bool
unlockConfig :: ClientId -> RpcClientMonad ()
lockConfig :: ClientId -> Bool -> RpcClientMonad (MaybeForJSON ConfigData)
verifyConfig :: RpcClientMonad ()
writeConfig :: ClientId -> ConfigData -> RpcClientMonad ()
readConfig :: RpcClientMonad ConfigData
prepareClusterDestruction :: ClientId -> RpcClientMonad ()
cleanupLocks :: RpcClientMonad ()
echo :: String -> RpcClientMonad String

-- | The default WConfd client configuration
wconfdConnectConfig :: ConnectConfig

-- | Given a socket path, creates a WConfd client with the default
--   configuration and timeout.
getWConfdClient :: FilePath -> IO Client

-- | Calls the <a>lockConfig</a> RPC until the lock is obtained.
waitLockConfig :: ClientId -> Bool -> RpcClientMonad ConfigData

-- | Calls the <a>lockConfig</a> RPC until the lock is obtained, runs a
--   function on the obtained config, and calls <a>unlockConfig</a>.
withLockedConfig :: ClientId -> Bool -> (ConfigData -> RpcClientMonad a) -> RpcClientMonad a


-- | Implementation of the Ganeti Query2 functionality.
module Ganeti.Query.Query
data CollectorType a b
CollectorSimple :: (Bool -> ConfigData -> [a] -> IO [(a, b)]) -> CollectorType a b
CollectorFieldAware :: (Bool -> ConfigData -> [String] -> [a] -> IO [(a, b)]) -> CollectorType a b
mkUnknownFDef :: String -> FieldData a b
execGetter :: ConfigData -> b -> a -> FieldGetter a b -> ResultEntry
getSelectedFields :: FieldMap a b -> [String] -> FieldList a b
needsLiveData :: [FieldGetter a b] -> Bool
needsNames :: Query -> Maybe [FilterValue]

-- | Computes the name field for different query types.
nameField :: ItemType -> FilterField

-- | Computes the uuid field, or the best possible substitute, for
--   different query types.
uuidField :: ItemType -> FilterField
getAllQuotedStrings :: [FilterValue] -> [String]

-- | Checks that we have either requested a valid set of names, or we have
--   a more complex filter.
getRequestedNames :: Query -> [String]
getRequestedJobIDs :: Filter FilterField -> Result [JobId]
genericQuery :: FieldMap a b -> CollectorType a b -> (a -> String) -> (ConfigData -> Container a) -> (ConfigData -> String -> ErrorResult a) -> ConfigData -> Bool -> [String] -> Filter FilterField -> [String] -> IO (ErrorResult QueryResult)
recollectLocksData :: ([(GanetiLocks, [(ClientId, OwnerState)])], [(Integer, ClientId, [LockRequest GanetiLocks])]) -> Bool -> ConfigData -> [String] -> IO [(String, RuntimeData)]

-- | Main query execution function.
query :: ConfigData -> Bool -> Query -> IO (ErrorResult QueryResult)
dummyCollectLiveData :: Bool -> ConfigData -> [a] -> IO [(a, NoDataRuntime)]
queryInner :: ConfigData -> Bool -> Query -> [String] -> IO (ErrorResult QueryResult)
queryJobs :: ConfigData -> Bool -> [FilterField] -> Filter FilterField -> IO (ErrorResult QueryResult)
fieldsExtractor :: FieldMap a b -> [FilterField] -> QueryFieldsResult

-- | Query fields call.
queryFields :: QueryFields -> ErrorResult QueryFieldsResult

-- | Classic query converter. It gets a standard query result on input and
--   computes the classic style results.
queryCompat :: QueryResult -> ErrorResult [[JSValue]]


-- | Implementation of the Ganeti Query2 server.
module Ganeti.Query.Server
makeLuxidClientId :: JQStatus -> IO ClientId
withLockedWconfdConfig :: (MonadBase IO m, MonadError GanetiException m) => ClientId -> (ConfigData -> RpcClientMonad a) -> m a
handleQuery :: [ItemType -> FilterField] -> ConfigData -> ItemType -> [Either String Integer] -> [String] -> Bool -> IO (GenericResult GanetiException JSValue)
handleClassicQuery :: ConfigData -> ItemType -> [Either String Integer] -> [String] -> Bool -> IO (GenericResult GanetiException JSValue)
handleUuidQuery :: ConfigData -> ItemType -> [Either String Integer] -> [String] -> Bool -> IO (GenericResult GanetiException JSValue)
handleCallWrapper :: Lock -> JQStatus -> Result ConfigData -> LuxiOp -> IO (ErrorResult JSValue)
handleCall :: Lock -> JQStatus -> ConfigData -> LuxiOp -> IO (ErrorResult JSValue)
computeJobUpdate :: ConfigData -> JobId -> [String] -> JSValue -> IO (JSValue, JSValue)
type LuxiConfig = (Lock, JQStatus, ConfigReader)
luxiExec :: LuxiConfig -> LuxiOp -> IO (Bool, GenericResult GanetiException JSValue)
luxiHandler :: LuxiConfig -> Handler LuxiOp IO JSValue
type PrepResult = (Server, IORef (Result ConfigData), JQStatus)
activateMasterIP :: IO (Result ())

-- | Check function for luxid.
checkMain :: CheckFn ()

-- | Prepare function for luxid.
prepMain :: PrepFn () PrepResult

-- | Main function.
main :: MainFn () PrepResult


-- | The implementation of Ganeti WConfd daemon server.
--   
--   As TemplateHaskell require that splices be defined in a separate
--   module, we combine all the TemplateHaskell functionality that HTools
--   needs in this module (except the one for unittests).
module Ganeti.WConfd.Server
handler :: DaemonHandle -> RpcServer WConfdMonadInt

-- | Type alias for prepMain results
type PrepResult = (Server, DaemonHandle)

-- | Check function for luxid.
checkMain :: CheckFn ()

-- | Prepare function for luxid.
prepMain :: PrepFn () PrepResult
serverConfig :: ServerConfig

-- | Main function.
main :: MainFn () PrepResult

-- | Options list and functions.
options :: [OptType]


-- | Implementation of the Ganeti confd server functionality.
module Ganeti.Monitoring.Server
type ConfigAccess = String -> DataCollectorConfig
type CheckResult = ()
type PrepResult = Config Snap ()
latestAPIVersion :: Int
defaultHttpConf :: FilePath -> FilePath -> Config Snap ()

-- | Check function for the monitoring agent.
checkMain :: CheckFn CheckResult

-- | Prepare function for monitoring agent.
prepMain :: PrepFn CheckResult PrepResult
versionQ :: Snap ()
version1Api :: MVar CollectorMap -> MVar ConfigAccess -> Snap ()
collectorConfigs :: ConfdClient -> IO ConfigAccess
activeCollectors :: MVar ConfigAccess -> IO [DataCollector]
dcListItem :: DataCollector -> JSValue
listHandler :: MVar ConfigAccess -> Snap ()
reportHandler :: MVar CollectorMap -> MVar ConfigAccess -> Snap ()
allReports :: MVar CollectorMap -> MVar ConfigAccess -> Snap ()
getReport :: MVar CollectorMap -> DataCollector -> IO DCReport
getColData :: String -> MVar CollectorMap -> IO (Maybe CollectorData)
catFromName :: String -> Result (Maybe DCCategory)
errorReport :: Snap ()
error404 :: Snap ()
oneReport :: MVar CollectorMap -> MVar ConfigAccess -> Snap ()
monitoringApi :: MVar CollectorMap -> MVar ConfigAccess -> Snap ()
collect :: CollectorMap -> DataCollector -> IO CollectorMap
collection :: CollectorMap -> MVar ConfigAccess -> IO CollectorMap
seconds :: Int -> Integer
collectord :: MVar CollectorMap -> MVar ConfigAccess -> IO ()

-- | Main function.
main :: MainFn CheckResult PrepResult


-- | Common helper functions and instances for all Ganeti tests.
module Test.Ganeti.TestCommon

-- | Maximum memory (1TiB, somewhat random value).
maxMem :: Int

-- | Maximum disk (8TiB, somewhat random value).
maxDsk :: Int

-- | Max CPUs (1024, somewhat random value).
maxCpu :: Int

-- | Max spindles (1024, somewhat random value).
maxSpindles :: Int

-- | Max vcpu ratio (random value).
maxVcpuRatio :: Double

-- | Max spindle ratio (random value).
maxSpindleRatio :: Double

-- | Max nodes, used just to limit arbitrary instances for smaller opcode
--   definitions (e.g. list of nodes in OpTestDelay).
maxNodes :: Int

-- | Max opcodes or jobs in a submit job and submit many jobs.
maxOpCodes :: Int

-- | Checks for equality with proper annotation. The first argument is the
--   computed value, the second one the expected value.
(==?) :: (Show a, Eq a) => a -> a -> Property

-- | Checks for inequality with proper annotation. The first argument is
--   the computed value, the second one the expected (not equal) value.
(/=?) :: (Show a, Eq a) => a -> a -> Property

-- | Show a message and fail the test.
failTest :: String -> Property

-- | A <a>True</a> property.
passTest :: Property

-- | A stable version of QuickCheck's <a>cover</a>. In its current
--   implementation, cover will not detect insufficient coverage if the
--   actual coverage in the sample is 0. Work around this by lifting the
--   probability to at least 10 percent. The underlying issue is tracked at
--   https:<i></i>github.com<i>nick8325</i>quickcheck<i>issues</i>26
stableCover :: Testable prop => Bool -> Int -> String -> prop -> Property

-- | Return the python binary to use. If the PYTHON environment variable is
--   defined, use its value, otherwise use just "python".
pythonCmd :: IO String

-- | Run Python with an expression, returning the exit code, standard
--   output and error.
runPython :: String -> String -> IO (ExitCode, String, String)

-- | Check python exit code, and fail via HUnit assertions if non-zero.
--   Otherwise, return the standard output.
checkPythonResult :: (ExitCode, String, String) -> IO String

-- | Defines a DNS name.
newtype DNSChar
DNSChar :: Char -> DNSChar
dnsGetChar :: DNSChar -> Char

-- | Generates printable ASCII characters (from ' ' to '~').
genPrintableAsciiChar :: Gen Char

-- | Generates a short string (0 &lt;= n &lt;= 40 chars) from printable
--   ASCII.
genPrintableAsciiString :: Gen String

-- | Generates a short string (1 &lt;= n &lt;= 40 chars) from printable
--   ASCII.
genPrintableAsciiStringNE :: Gen NonEmptyString

-- | Generates a single name component.
genName :: Gen String

-- | Generates an entire FQDN.
genFQDN :: Gen String

-- | Generates a UUID-like string.
--   
--   Only to be used for QuickCheck testing. For obtaining actual UUIDs use
--   the newUUID function in Ganeti.Utils
genUUID :: Gen String

-- | Combinator that generates a <a>Maybe</a> using a sub-combinator.
genMaybe :: Gen a -> Gen (Maybe a)

-- | Generates a sublist of a given list, keeping the ordering. The
--   generated elements are always a subset of the list.
--   
--   In order to better support corner cases, the size of the sublist is
--   chosen to have the uniform distribution.
genSublist :: [a] -> Gen [a]

-- | Generates a map given generators for keys and values.
genMap :: (Ord k, Ord v) => Gen k -> Gen v -> Gen (Map k v)
newtype TagChar
TagChar :: Char -> TagChar
tagGetChar :: TagChar -> Char
tagChar :: String
genTag :: Gen [TagChar]

-- | Generates a list of tags (correctly upper bounded).
genTags :: Gen [String]

-- | Generates a fields list. This uses the same character set as a DNS
--   name (just for simplicity).
genFields :: Gen [String]

-- | Generates a list of a given size with non-duplicate elements.
genUniquesList :: (Eq a, Arbitrary a, Ord a) => Int -> Gen a -> Gen [a]
newtype SmallRatio
SmallRatio :: Double -> SmallRatio

-- | Helper for <a>genSet</a>, declared separately due to type constraints.
genSetHelper :: Ord a => [a] -> Maybe Int -> Gen (Set a)

-- | Generates a <tt>Set</tt> of arbitrary elements.
genSet :: (Ord a, Bounded a, Enum a) => Maybe Int -> Gen (Set a)

-- | Generates a <tt>Set</tt> of arbitrary elements wrapped in a
--   <tt>ListSet</tt>
genListSet :: (Ord a, Bounded a, Enum a) => Maybe Int -> Gen (ListSet a)

-- | Generate an arbitrary element of and AndRestArguments field.
genAndRestArguments :: Gen (Map String JSValue)
genIPv4 :: Gen String
genIPv4Address :: Gen IPv4Address
genIPv4AddrRange :: Gen String
genIPv4Network :: Gen IPv4Network

-- | Helper function to compute the number of hosts in a network given the
--   netmask. (For IPv4 only.)
netmask2NumHosts :: Word8 -> Int

-- | Generates an arbitrary IPv6 network address in textual form. The
--   generated address is not simpflified, e. g. an address like
--   <a>2607:f0d0:1002:0051:0000:0000:0000:0004</a> does not become
--   <a>2607:f0d0:1002:51::4</a>
genIp6Addr :: Gen String

-- | Generates an arbitrary IPv6 network in textual form.
genIp6Net :: Gen String

-- | Generates a valid, arbitrary tag name with respect to the given
--   <a>TagKind</a> for opcodes.
genOpCodesTagName :: TagKind -> Gen (Maybe String)

-- | Generates a valid, arbitrary tag name with respect to the given
--   <a>TagKind</a> for Luxi.
genLuxiTagName :: TagKind -> Gen String

-- | Checks for serialisation idempotence.
testSerialisation :: (Eq a, Show a, JSON a) => a -> Property

-- | Checks for array serialisation idempotence.
testArraySerialisation :: (Eq a, Show a, ArrayObject a) => a -> Property

-- | Checks if the deserializer doesn't accept forbidden values. The first
--   argument is ignored, it just enforces the correct type.
testDeserialisationFail :: (Eq a, Show a, JSON a) => a -> JSValue -> Property

-- | Result to PropertyM IO.
resultProp :: Show a => GenericResult a b -> PropertyM IO b
getSourceDir :: IO FilePath
testDataFilename :: String -> String -> IO FilePath

-- | Returns the content of the specified haskell test data file.
readTestData :: String -> IO String

-- | Generate arbitrary values in the IO monad. This is a simple wrapper
--   over <a>sample'</a>.
genSample :: Gen a -> IO a

-- | Function for testing whether a file is parsed correctly.
testParser :: (Show a, Eq a) => Parser a -> String -> a -> Assertion

-- | Generate a property test for parsers.
genPropParser :: (Show a, Eq a) => Parser a -> String -> a -> Property

-- | Generate an arbitrary non negative integer number
genNonNegative :: Gen Int

-- | Computes the relative error of two <a>Double</a> numbers.
--   
--   This is the "relative error" algorithm in
--   http://randomascii.wordpress.com/2012/02/25/
--   comparing-floating-point-numbers-2012-edition (URL split due to too
--   long line).
relativeError :: Double -> Double -> Double

-- | Helper to a get a temporary file name.
getTempFileName :: String -> IO FilePath

-- | <tt>listOfUniqueBy gen keyFun forbidden</tt>: Generates a list of
--   random length, where all generated elements will be unique by the
--   keying function <tt>keyFun</tt>. They will also be distinct from all
--   elements in <tt>forbidden</tt> by the keying function.
--   
--   As for <a>listOf</a>, the maximum output length depends on the size
--   parameter.
--   
--   Example:
--   
--   <pre>
--   listOfUniqueBy (arbitrary :: Gen String) (length) ["hey"]
--   -- Generates a list of strings of different length, but not of length 3.
--   </pre>
--   
--   The passed <tt>gen</tt> should not make key collisions too likely,
--   since the implementation uses <a>suchThat</a>, looping until enough
--   unique elements have been generated. If the <tt>gen</tt> makes
--   collisions likely, this function will consequently be slow, or not
--   terminate if it is not possible to generate enough elements, like in:
--   
--   <pre>
--   listOfUniqueBy (arbitrary :: Gen Int) (`mod` 2) []
--   -- May not terminate depending on the size parameter of the Gen,
--   -- since there are only 2 unique keys (0 and 1).
--   </pre>
listOfUniqueBy :: Ord b => Gen a -> (a -> b) -> [a] -> Gen [a]
counterexample :: Testable prop => String -> prop -> Property
instance Show SmallRatio
instance Arbitrary SmallRatio
instance Arbitrary TagChar
instance Show DNSChar
instance Arbitrary DNSChar
instance (Ord k, Arbitrary k, Arbitrary a) => Arbitrary (Map k a)


-- | Unittests for ganeti-htools.
module Test.Ganeti.BasicTypes
prop_functor_id :: Result Int -> Property
prop_functor_composition :: Result Int -> Fun Int Int -> Fun Int Int -> Property
prop_applicative_identity :: Result Int -> Property
prop_applicative_composition :: Result (Fun Int Int) -> Result (Fun Int Int) -> Result Int -> Property
prop_applicative_homomorphism :: Fun Int Int -> Int -> Property
prop_applicative_interchange :: Result (Fun Int Int) -> Int -> Property
prop_applicative_functor :: Fun Int Int -> Result Int -> Property
prop_applicative_monad :: Int -> Result (Fun Int Int) -> Property
prop_monad_laws :: Int -> Result Int -> Fun Int (Result Int) -> Fun Int (Result Int) -> Property
prop_monadplus_mzero :: Result Int -> Fun Int (Result Int) -> Property
testBasicTypes :: Test
instance Arbitrary a => Arbitrary (Result a)


-- | Unittests for ganeti-htools.
module Test.Ganeti.Confd.Types
prop_ConfdQuery_serialisation :: ConfdQuery -> Property
case_ConfdQuery_BadTypes :: Assertion
prop_ConfdReplyStatus_serialisation :: ConfdReplyStatus -> Property
prop_ConfdReply_serialisation :: ConfdReply -> Property
prop_ConfdErrorType_serialisation :: ConfdErrorType -> Property
prop_ConfdNodeRole_serialisation :: ConfdNodeRole -> Property
testConfd_Types :: Test
instance Arbitrary ConfdNodeRole
instance Arbitrary ConfdErrorType
instance Arbitrary ConfdReply
instance Arbitrary ConfdReplyStatus
instance Arbitrary ConfdRequest
instance Arbitrary ConfdQuery
instance Arbitrary ConfdReqQ
instance Arbitrary ConfdReqField
instance Arbitrary ConfdRequestType


-- | Unittests for <a>Ganeti.Errors</a>.
module Test.Ganeti.Errors
prop_GenericError_serialisation :: GanetiException -> Property
testErrors :: Test
instance Arbitrary GanetiException
instance Arbitrary ErrorCode


-- | Common functionality for htools-related unittests.
module Test.Ganeti.TestHTools

-- | An ISpec with 0 resources.
nullISpec :: ISpec

-- | Null iPolicy, and by null we mean very liberal.
nullIPolicy :: IPolicy

-- | Default group definition.
defGroup :: Group

-- | Default group, as a (singleton) <a>List</a>.
defGroupList :: List

-- | Default group, as a string map.
defGroupAssoc :: Map String Gdx

-- | Create an instance given its spec.
createInstance :: Int -> Int -> Int -> Instance

-- | Create a small cluster by repeating a node spec.
makeSmallCluster :: Node -> Int -> List

-- | Update an instance to be smaller than a node.
setInstanceSmallerThanNode :: Node -> Instance -> Instance


-- | Unittests for Ganeti.Htools.Graph
module Test.Ganeti.HTools.Graph
data TestableGraph
TestableGraph :: Graph -> TestableGraph
data TestableClique
TestableClique :: Graph -> TestableClique
undirEdges :: Gen (Bounds, [Edge])
cliqueEdges :: Gen (Bounds, [Edge])
case_emptyVertColorMapNull :: Assertion
case_emptyVertColorMapEmpty :: Assertion
anyTwo :: (a -> a -> Bool) -> [a] -> Bool
prop_verticesByDegreeAscAsc :: TestableGraph -> Bool
prop_verticesByDegreeDescDesc :: TestableGraph -> Bool
prop_isColorableTestableGraph :: TestableGraph -> Bool
prop_isColorableTestableClique :: TestableClique -> Bool
prop_colorClique :: (Graph -> VertColorMap) -> TestableClique -> Property
prop_colorLFClique :: TestableClique -> Property
prop_colorDsaturClique :: TestableClique -> Property
prop_colorDcolorClique :: TestableClique -> Property
prop_colorAllNodes :: (Graph -> VertColorMap) -> TestableGraph -> Property
prop_colorLFAllNodes :: TestableGraph -> Property
prop_colorDsaturAllNodes :: TestableGraph -> Property
prop_colorDcolorAllNodes :: TestableGraph -> Property
prop_colorProper :: (Graph -> VertColorMap) -> TestableGraph -> Bool
prop_colorLFProper :: TestableGraph -> Bool
prop_colorDsaturProper :: TestableGraph -> Bool
prop_colorDcolorProper :: TestableGraph -> Bool

-- | List of tests for the Graph module.
testHTools_Graph :: Test
instance Show TestableGraph
instance Show TestableClique
instance Arbitrary TestableClique
instance Arbitrary TestableGraph


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.PeerMap
prop_addIdempotent :: PeerMap -> Key -> Elem -> Property
prop_removeIdempotent :: PeerMap -> Key -> Property
prop_findMissing :: PeerMap -> Key -> Property
prop_addFind :: PeerMap -> Key -> Elem -> Property
prop_maxElem :: PeerMap -> Property

-- | List of tests for the PeerMap module.
testHTools_PeerMap :: Test


-- | Unittests for <tt>xm list --long</tt> parser
module Test.Ganeti.Hypervisor.Xen.XmParser
genConfig :: Int -> Gen LispConfig
canBeNumber :: String -> Bool
canBeNumberChar :: Char -> Bool
testDomain :: String -> Map String Domain -> Assertion
testUptimeInfo :: String -> Map Int UptimeInfo -> Assertion
isAlmostEqual :: LispConfig -> LispConfig -> Property
serializeConf :: LispConfig -> String
serializeUptime :: UptimeInfo -> String
prop_config :: LispConfig -> Property
prop_uptimeInfo :: UptimeInfo -> Property
case_xen401list :: Assertion
case_xen401uptime :: Assertion
testHypervisor_Xen_XmParser :: Test
instance Arbitrary UptimeInfo
instance Arbitrary LispConfig


-- | Unittests for the KVM daemon.
module Test.Ganeti.Kvmd
startKvmd :: FilePath -> IO ThreadId
stopKvmd :: ThreadId -> IO ()
delayKvmd :: IO ()
detectShutdown :: (Handle -> IO ()) -> IO Bool
case_DetectAdminShutdown :: Assertion
case_DetectUserShutdown :: Assertion
testKvmd :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Query.Language

-- | Custom <a>Filter</a> generator (top-level), which enforces a (sane)
--   limit on the depth of the generated filters.
genFilter :: Gen (Filter FilterField)
genFilter' :: Int -> Gen (Filter FilterField)

-- | Generates an arbitrary JSValue. We do this via a function a not via
--   arbitrary instance since that would require us to define an arbitrary
--   for JSValue, which can be recursive, entering the usual problems with
--   that; so we only generate the base types, not the recursive ones, and
--   not <a>JSNull</a>, which we can't use in a <a>RSNormal</a>
--   <a>ResultEntry</a>.
genJSValue :: Gen JSValue
genResultEntry :: Gen ResultEntry
prop_filter_serialisation :: Property
prop_filterregex_instances :: FilterRegex -> Property
prop_resultstatus_serialisation :: ResultStatus -> Property
prop_fieldtype_serialisation :: FieldType -> Property
prop_fielddef_serialisation :: FieldDefinition -> Property
prop_resultentry_serialisation :: Property
prop_fieldsresult_serialisation :: Property
prop_itemtype_serialisation :: ItemType -> Property
case_filterParsing :: Assertion
testQuery_Language :: Test
instance Arbitrary QueryFieldsResult
instance Arbitrary FieldDefinition
instance Arbitrary FieldType
instance Arbitrary ResultStatus
instance Arbitrary FilterRegex
instance Arbitrary ItemType
instance Arbitrary QueryTypeLuxi
instance Arbitrary QueryTypeOp
instance Arbitrary (Filter FilterField)


-- | Common tests for PartialParams instances
module Test.Ganeti.PartialParams

-- | Checks for serialisation idempotence.
testFillParamsLaw1 :: (PartialParams f p, Show f, Eq f) => f -> p -> Property

-- | Tests that filling partial parameters satisfies the law.
testToParamsLaw2 :: (PartialParams f p, Show f, Eq f) => f -> f -> Property

-- | Tests that converting partial to filled parameters satisfies the law.
testToFilledLaw3 :: (PartialParams f p, Show f, Eq f) => f -> Property

-- | Tests that the partial params behave correctly as a monoid action.
testToFilledMonoidLaw1 :: (PartialParams f p, Show f, Eq f, Monoid p) => f -> Property

-- | Tests that the partial params behave correctly as a monoid action.
testToFilledMonoidLaw2 :: (PartialParams f p, Show f, Eq f, Monoid p) => f -> p -> p -> Property


-- | Unittests for bit arrays
module Test.Ganeti.Objects.BitArray
genBitArray :: Int -> Gen BitArray
prop_BitArray_serialisation :: BitArray -> Property
prop_BitArray_foldr :: [Bool] -> Property
prop_BitArray_fromToList :: BitArray -> Property
prop_BitArray_and :: [Bool] -> [Bool] -> Property
prop_BitArray_or :: [Bool] -> [Bool] -> Property
prop_BitArray_counts :: Property
prop_BitArray_countsSum :: BitArray -> Property
testObjects_BitArray :: Test
instance Arbitrary BitArray


-- | Unittests for <a>Ganeti.Runtime</a>.
module Test.Ganeti.Runtime
case_LogFiles :: Assertion
case_UsersGroups :: Assertion
testRuntime :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Ssconf
prop_filename :: SSKey -> Property
caseParseNodesVmCapable :: Assertion
caseParseHypervisorList :: Assertion
caseParseEnabledUserShutdown :: Assertion
prop_ReadShow :: SSConf -> Property
testSsconf :: Test
instance Arbitrary SSConf
instance Arbitrary SSKey


-- | Unittests for the <tt><i>proc</i>diskstats</tt> parser
module Test.Ganeti.Storage.Diskstats.Parser
case_diskstats :: Assertion
serializeDiskstatsList :: [Diskstats] -> String
serializeDiskstats :: Diskstats -> String
prop_diskstats :: [Diskstats] -> Property
testBlock_Diskstats_Parser :: Test
instance Arbitrary Diskstats


-- | Unittests for the DRBD Parser
module Test.Ganeti.Storage.Drbd.Parser
case_drbd80_emptyline :: Assertion
case_drbd80_emptyversion :: Assertion
case_drbd84_sync :: Assertion
case_drbd84 :: Assertion
case_drbd84_emptyfirst :: Assertion
case_drbd83_sync_krnl2_6_39 :: Assertion
case_drbd83_sync :: Assertion
case_drbd83_sync_want :: Assertion
case_drbd83 :: Assertion
case_drbd8 :: Assertion
splitEvery :: Int -> [e] -> [[e]]
testCommaInt :: String -> Int -> Assertion
gen_prop_CommaInt :: Int -> Int -> Property
prop_commaInt_noCommas :: Property
prop_commaInt_1Comma :: Property
prop_commaInt_multipleCommas :: Property
prop_commaInt_max3WithoutComma :: Property
case_commaInt_non_triplet :: Assertion
testBlock_Drbd_Parser :: Test


-- | Unittests for the types representing DRBD status
module Test.Ganeti.Storage.Drbd.Types
natural :: Gen Int
percent :: Gen Double
wOrderFlag :: Gen Char
prop_DeviceInfo :: Property
prop_PerfIndicators :: Property
prop_SyncStatus :: Property
testBlock_Drbd_Types :: Test
instance Arbitrary TimeUnit
instance Arbitrary SizeUnit
instance Arbitrary DiskState
instance Arbitrary Role
instance Arbitrary ConnState


-- | Unittests for the LV Parser
module Test.Ganeti.Storage.Lvm.LVParser
case_lvs_lv :: Assertion
serializeLVInfo :: LVInfo -> String
serializeLVInfos :: [LVInfo] -> String
prop_parse_lvs_lv :: [LVInfo] -> Property
testStorage_Lvm_LVParser :: Test
instance Arbitrary LVInfo


-- | Unittests for our template-haskell generated code.
module Test.Ganeti.THH
data TestObj
TestObj :: Maybe Int -> Maybe Int -> TestObj
tobjA :: TestObj -> Maybe Int
tobjB :: TestObj -> Maybe Int
loadTestObj :: JSValue -> Result TestObj
saveTestObj :: TestObj -> JSValue
prop_OptFields :: TestObj -> Property
prop_TestObj_serialization :: TestObj -> Property
prop_TestObj_deserialisationFail :: Property
data UnitObj
UnitObj :: UnitObj
loadUnitObj :: JSValue -> Result UnitObj
saveUnitObj :: UnitObj -> JSValue
prop_UnitObj_serialization :: UnitObj -> Property
prop_UnitObj_deserialisationFail :: Property
data FilledTestParams
FilledTestParams :: Int -> String -> FilledTestParams
tparamC :: FilledTestParams -> Int
tparamD :: FilledTestParams -> String
data PartialTestParams
PartialTestParams :: Maybe Int -> Maybe String -> PartialTestParams
tparamCP :: PartialTestParams -> Maybe Int
tparamDP :: PartialTestParams -> Maybe String
allTestParamFields :: [String]
loadPartialTestParams :: JSValue -> Result PartialTestParams
savePartialTestParams :: PartialTestParams -> JSValue
loadFilledTestParams :: JSValue -> Result FilledTestParams
saveFilledTestParams :: FilledTestParams -> JSValue
prop_fillWithPartialParams :: Property
prop_fillPartialLaw1 :: FilledTestParams -> PartialTestParams -> Property
prop_toParams :: Property
prop_fillPartialLaw2 :: FilledTestParams -> FilledTestParams -> Property
prop_fillPartialLaw3 :: FilledTestParams -> Property
prop_fillPartialMonoidLaw1 :: FilledTestParams -> Property
prop_fillPartialMonoidLaw2 :: FilledTestParams -> PartialTestParams -> PartialTestParams -> Property
testTHH :: Test
instance Arbitrary PartialTestParams
instance Arbitrary FilledTestParams
instance Show FilledTestParams
instance Eq FilledTestParams
instance Show PartialTestParams
instance Eq PartialTestParams
instance Monoid PartialTestParams
instance PartialParams FilledTestParams PartialTestParams
instance JSON PartialTestParams
instance ArrayObject PartialTestParams
instance DictObject PartialTestParams
instance JSON FilledTestParams
instance ArrayObject FilledTestParams
instance DictObject FilledTestParams
instance Arbitrary UnitObj
instance Show UnitObj
instance Eq UnitObj
instance JSON UnitObj
instance ArrayObject UnitObj
instance DictObject UnitObj
instance Arbitrary TestObj
instance Show TestObj
instance Eq TestObj
instance JSON TestObj
instance ArrayObject TestObj
instance DictObject TestObj


-- | Unittests for <a>Types</a>.
module Test.Ganeti.THH.Types
prop_OneTuple_serialisation :: OneTuple String -> Property
prop_OneTuple_deserialisationFail :: Property
testTHH_Types :: Test
instance Arbitrary a => Arbitrary (OneTuple a)


-- | Unittests for mutli-maps
module Test.Ganeti.Utils.MultiMap
data Three
One :: Three
Two :: Three
Three :: Three
prop_MultiMap_equality :: MultiMap Three Three -> MultiMap Three Three -> Property
prop_MultiMap_serialisation :: MultiMap Int Int -> Property
testUtils_MultiMap :: Test
instance Eq Three
instance Ord Three
instance Show Three
instance Enum Three
instance Bounded Three
instance Arbitrary Three
instance (Arbitrary k, Ord k, Arbitrary v, Ord v) => Arbitrary (MultiMap k v)


-- | Unit tests for Ganeti statistics utils.
module Test.Ganeti.Utils.Statistics
prop_stddev_update :: Property
testUtils_Statistics :: Test


-- | Unittests for the <a>Common</a> module.
module Test.Ganeti.Common

-- | Helper to check for correct parsing of an option.
checkOpt :: StandardOptions b => (a -> Maybe String) -> b -> (String -> c) -> (String -> d -> d -> c) -> (a -> d) -> (a, GenericOptType b, b -> d) -> c

-- | Helper to check for correct and incorrect parsing of an option.
passFailOpt :: StandardOptions b => b -> (String -> c) -> c -> (GenericOptType b, String, String) -> c

-- | Helper to test that a given option is accepted OK with quick exit.
checkEarlyExit :: StandardOptions a => a -> String -> [GenericOptType a] -> [ArgCompletion] -> Assertion
prop_parse_yes_no :: Bool -> Bool -> String -> Property
case_formatCommands :: Assertion
testCommon :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Daemon
prop_string_arg :: String -> Property
prop_numeric_arg :: Int -> Property
case_bool_arg :: Assertion
case_wrong_arg :: Assertion
case_stdopts :: Assertion
testDaemon :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Confd.Utils
prop_req_sign :: HashKey -> NonNegative Integer -> Positive Integer -> Bool -> ConfdRequest -> Property
prop_rep_salt :: HashKey -> ConfdReply -> Property
prop_bad_key :: String -> ConfdRequest -> Property
testConfd_Utils :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Backend.Simu
genSimuSpec :: Gen (String, Int, Int, Int, Int)
prop_Load :: Property
testHTools_Backend_Simu :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.CLI
prop_parseISpec :: String -> Int -> Int -> Int -> Maybe Int -> Property
prop_parseISpecFail :: String -> Property
prop_string_arg :: String -> Property
prop_numeric_arg :: Positive Double -> Property
case_bool_arg :: Assertion
case_wrong_arg :: Assertion
case_stdopts :: Assertion
testHTools_CLI :: Test


-- | Unittests for the MonD data parse function
module Test.Ganeti.HTools.ExtLoader
case_parseMonDData :: Assertion
isAlEqual :: [(String, [DCReport])] -> [(String, [DCReport])] -> Bool
tupleIsAlEqual :: (String, [DCReport]) -> (String, [DCReport]) -> Bool
dcReportIsAlmostEqual :: DCReport -> DCReport -> Bool
cpuavgloadDataIsAlmostEq :: JSValue -> JSValue -> Bool
compareCPUavgload :: CPUavgload -> CPUavgload -> Bool
testHTools_ExtLoader :: Test


-- | Unittests for <a>Types</a>.
module Test.Ganeti.Types

-- | Valid disk templates (depending on configure options).
allDiskTemplates :: [DiskTemplate]
allStorageTypes :: [StorageType]
genReasonElem :: Gen ReasonElem

-- | Generates a reason trail
genReasonTrail :: Gen ReasonTrail
prop_AllocPolicy_serialisation :: AllocPolicy -> Property
case_AllocPolicy_order :: Assertion
prop_DiskTemplate_serialisation :: DiskTemplate -> Property
prop_InstanceStatus_serialisation :: InstanceStatus -> Property
prop_NonNeg_pass :: NonNegative Int -> Property
prop_NonNeg_fail :: Positive Int -> Property
prop_Positive_pass :: Positive Int -> Property
prop_Positive_fail :: NonNegative Int -> Property
prop_Neg_pass :: Positive Int -> Property
prop_Neg_fail :: NonNegative Int -> Property
prop_NonEmpty_pass :: NonEmptyList String -> Property
case_NonEmpty_fail :: Assertion
prop_MigrationMode_serialisation :: MigrationMode -> Property
prop_VerifyOptionalChecks_serialisation :: VerifyOptionalChecks -> Property
prop_DdmSimple_serialisation :: DdmSimple -> Property
prop_DdmFull_serialisation :: DdmFull -> Property
prop_CVErrorCode_serialisation :: CVErrorCode -> Property
case_CVErrorCode_pyequiv :: Assertion
prop_Hypervisor_serialisation :: Hypervisor -> Property
prop_OobCommand_serialisation :: OobCommand -> Property
prop_StorageType_serialisation :: StorageType -> Property
prop_NodeEvacMode_serialisation :: EvacMode -> Property
prop_FileDriver_serialisation :: FileDriver -> Property
prop_InstCreateMode_serialisation :: InstCreateMode -> Property
prop_RebootType_serialisation :: RebootType -> Property
prop_ExportMode_serialisation :: ExportMode -> Property
prop_IAllocatorTestDir_serialisation :: IAllocatorTestDir -> Property
prop_IAllocatorMode_serialisation :: IAllocatorMode -> Property
case_IAllocatorMode_pyequiv :: Assertion
prop_NICMode_serialisation :: NICMode -> Property
prop_OpStatus_serialization :: OpStatus -> Property
prop_JobStatus_serialization :: JobStatus -> Property
case_JobStatus_order :: Assertion
case_NICMode_pyequiv :: Assertion
prop_FinalizedJobStatus_serialisation :: FinalizedJobStatus -> Property
case_FinalizedJobStatus_pyequiv :: Assertion
prop_JobId_serialisation :: JobId -> Property
prop_JobId_fractional :: Property
case_JobId_BadTypes :: Assertion
prop_JobDependency_serialisation :: JobDependency -> Property
prop_OpSubmitPriority_serialisation :: OpSubmitPriority -> Property
prop_OpSubmitPriority_string :: OpSubmitPriority -> Property
prop_ELogType_serialisation :: ELogType -> Property
testTypes :: Test
instance Arbitrary ELogType
instance Arbitrary OpStatus
instance Arbitrary OpSubmitPriority
instance Arbitrary JobDependency
instance Arbitrary JobIdDep
instance Arbitrary JobId
instance Arbitrary FinalizedJobStatus
instance Arbitrary JobStatus
instance Arbitrary NICMode
instance Arbitrary IAllocatorMode
instance Arbitrary IAllocatorTestDir
instance Arbitrary ExportMode
instance Arbitrary RebootType
instance Arbitrary InstCreateMode
instance Arbitrary FileDriver
instance Arbitrary EvacMode
instance Arbitrary StorageType
instance Arbitrary OobCommand
instance Arbitrary TagKind
instance Arbitrary Hypervisor
instance Arbitrary CVErrorCode
instance Arbitrary DdmFull
instance Arbitrary DdmSimple
instance Arbitrary VerifyOptionalChecks
instance Arbitrary MigrationMode
instance Arbitrary InstanceStatus
instance Arbitrary DiskTemplate
instance Arbitrary AllocPolicy
instance Arbitrary a => Arbitrary (NonEmpty a)
instance (Arbitrary a, Ord a, Num a, Show a) => Arbitrary (Negative a)
instance (Arbitrary a, Ord a, Num a, Show a) => Arbitrary (NonNegative a)
instance (Arbitrary a, Ord a, Num a, Show a) => Arbitrary (Positive a)
instance Arbitrary ClockTime


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Types
genBiggerISpec :: ISpec -> Gen ISpec
genMinMaxISpecs :: Gen MinMaxISpecs
genMinMaxStdISpecs :: Gen (MinMaxISpecs, ISpec)
genIPolicySpecs :: Gen ([MinMaxISpecs], ISpec)
prop_ISpec_serialisation :: ISpec -> Property
prop_IPolicy_serialisation :: IPolicy -> Property
prop_opToResult :: OpResult Int -> Property
prop_eitherToResult :: Either String Int -> Bool
case_AutoRepairType_sort :: Assertion
case_AutoRepairResult_pyequiv :: Assertion
testHTools_Types :: Test
instance Arbitrary IPolicy
instance Arbitrary MinMaxISpecs
instance Arbitrary ISpec
instance Arbitrary a => Arbitrary (OpResult a)
instance Arbitrary FailMode


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Instance
genInstanceWithin :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Maybe Int -> Gen Instance
genInstanceSmallerThan :: Int -> Int -> Int -> Maybe Int -> Gen Instance

-- | Generates an instance smaller than a node.
genInstanceSmallerThanNode :: Node -> Gen Instance

-- | Generates an instance possibly bigger than a node. In any case, that
--   instance will be bigger than the node's ipolicy's lower bound.
genInstanceMaybeBiggerThanNode :: Node -> Gen Instance

-- | Generates an instance with nodes on a node list. The following rules
--   are respected: 1. The instance is never bigger than its primary node
--   2. If possible the instance has different pnode and snode 3. Else disk
--   templates which require secondary nodes are disabled
genInstanceOnNodeList :: List -> Gen Instance

-- | Generates an instance list given an instance generator.
genInstanceList :: Gen Instance -> Gen List
prop_creat :: Instance -> Property
prop_setIdx :: Instance -> Idx -> Property
prop_setName :: Instance -> String -> Bool
prop_setAlias :: Instance -> String -> Bool
prop_setPri :: Instance -> Ndx -> Property
prop_setSec :: Instance -> Ndx -> Property
prop_setBoth :: Instance -> Ndx -> Ndx -> Bool
prop_shrinkMG :: Instance -> Property
prop_shrinkMF :: Instance -> Property
prop_shrinkCG :: Instance -> Property
prop_shrinkCF :: Instance -> Property
prop_shrinkDG :: Instance -> Property
prop_shrinkDF :: Instance -> Property
prop_setMovable :: Instance -> Bool -> Property
testHTools_Instance :: Test
instance Arbitrary Instance


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Node

-- | Generates an arbitrary node based on sizing information.
genNode :: Maybe Int -> Maybe Int -> Gen Node

-- | Helper function to generate a sane node.
genOnlineNode :: Gen Node

-- | Helper function to generate a sane empty node with consistent internal
--   data.
genEmptyOnlineNode :: Gen Node
genExclStorNode :: Gen Node
genMaybeExclStorNode :: Gen Node

-- | Node list generator. Given a node generator, create a random length
--   node list. Note that <a>real</a> clusters always have at least one
--   node, so we don't generate empty node lists here.
genNodeList :: Gen Node -> Gen List

-- | Node list generator where node names are unique
genUniqueNodeList :: Gen Node -> Gen (List, NameAssoc)
genNodeGraph :: Gen (Maybe Graph, List, List)
prop_setAlias :: Node -> String -> Bool
prop_setOffline :: Node -> Bool -> Property
prop_setXmem :: Node -> Int -> Property
prop_setMcpu :: Node -> Double -> Property
prop_addPri_NoN1Fail :: Property
prop_addPriFM :: Node -> Instance -> Property
prop_addPriFD :: Instance -> Property
hasInstTooManySpindles :: Instance -> Int -> Bool
prop_addPriFS :: Instance -> Property
prop_addPriFC :: Property
prop_addSec :: Node -> Instance -> Int -> Property
prop_addOfflinePri :: NonNegative Int -> NonNegative Int -> Property
prop_addOfflineSec :: NonNegative Int -> NonNegative Int -> Ndx -> Property
prop_rMem :: Instance -> Property
prop_setMdsk :: Node -> SmallRatio -> Bool
prop_tagMaps_idempotent :: Property
prop_tagMaps_reject :: Property
prop_showField :: Node -> Property
prop_computeGroups :: [Node] -> Bool
prop_addPri_idempotent :: Property
prop_addSec_idempotent :: Property
case_emptyNodeList :: Assertion
prop_numVertices :: Property
prop_numEdges :: Property
prop_nodeGraphIsColorable :: Property
prop_instanceIsEdge :: Property
prop_edgeIsInstance :: Property

-- | List of tests for the Node module.
testHTools_Node :: Test
instance Arbitrary Node


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Backend.Text
prop_Load_Instance :: String -> Int -> Int -> Int -> InstanceStatus -> NonEmptyList Char -> String -> NonNegative Int -> NonNegative Int -> Bool -> DiskTemplate -> Int -> Property
prop_Load_InstanceFail :: [(String, Int)] -> [String] -> Property
genInstanceNodes :: Gen (Instance, List, NameAssoc)
prop_InstanceLSIdempotent :: Property
prop_Load_Node :: String -> Int -> Int -> Int -> Int -> Int -> Int -> Bool -> Bool
prop_Load_NodeFail :: [String] -> Property
prop_NodeLSIdempotent :: Property
prop_ISpecIdempotent :: ISpec -> Property
prop_MultipleMinMaxISpecsIdempotent :: [MinMaxISpecs] -> Property
prop_IPolicyIdempotent :: IPolicy -> Property
prop_CreateSerialise :: Property
testHTools_Backend_Text :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Container
prop_addTwo :: [Key] -> Int -> Int -> Bool
prop_nameOf :: Node -> Property
prop_findByName :: Property
testHTools_Container :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Loader
prop_lookupNode :: [(String, Int)] -> String -> String -> Property
prop_lookupInstance :: [(String, Int)] -> String -> Property
prop_assignIndices :: Property
prop_mergeData :: [Node] -> Bool
prop_compareNameComponent_equal :: String -> Bool
prop_compareNameComponent_prefix :: NonEmptyList Char -> String -> Bool
testHTools_Loader :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.HTools.Cluster
makeSmallEmptyCluster :: Node -> Int -> Instance -> (List, List, Instance)
isNodeBig :: Int -> Node -> Bool
canBalance :: Table -> Bool -> Bool -> Bool -> Bool
assignInstance :: List -> List -> Instance -> Idx -> Idx -> (List, List)
isMirrored :: Instance -> Bool
evacModeOptions :: MirrorType -> [EvacMode]
prop_Score_Zero :: Node -> Property
prop_CStats_sane :: Property
prop_Alloc_sane :: Instance -> Property
prop_CanTieredAlloc :: Property
genClusterAlloc :: Int -> Node -> Instance -> Result (List, List, Instance)
prop_AllocRelocate :: Property
check_EvacMode :: Group -> Instance -> Result (List, List, EvacSolution) -> Property
prop_AllocEvacuate :: Property
prop_AllocChangeGroup :: Property
prop_AllocBalance :: Property
prop_CheckConsistency :: Node -> Instance -> Bool
prop_SplitCluster :: Node -> Instance -> Property
canAllocOn :: List -> Int -> Instance -> Maybe String
prop_AllocPolicy :: Property
testHTools_Cluster :: Test


-- | Unittests for the SlotMap.
module Test.Ganeti.SlotMap

-- | Generates a number typical for the limit of a <a>Slot</a>. Useful for
--   constructing resource bounds when not directly constructing the
--   relevant <a>Slot</a>s.
genSlotLimit :: Gen Int
genSlotCount :: Gen Int
resampleFittingSlot :: Slot -> Gen Slot
type TestKey = String

-- | Generates short strings used as <a>SlotMap</a> keys.
--   
--   We limit ourselves to a small set of key strings with high probability
--   to increase the chance that <a>SlotMap</a>s actually have more than
--   one slot taken.
genTestKey :: Gen TestKey
listSizeGen :: Gen Int
genSlotMap :: Ord a => Gen a -> Gen (SlotMap a)
genCountMap :: Ord a => Gen a -> Gen (CountMap a)

-- | Tells which keys of a <a>SlotMap</a> are overfull.
overfullKeys :: Ord a => SlotMap a -> Set a
genFittingSlotMap :: Ord a => Gen a -> Gen (SlotMap a)
case_isOverfull :: Assertion
case_occupySlots_examples :: Assertion
keyUnion :: Ord a => Map a b -> Map a c -> Set a
prop_occupySlots :: Property
case_hasSlotsFor_examples :: Assertion
prop_hasSlotsFor_fitting :: Property
prop_hasSlotsFor :: Property
testSlotMap :: Test
instance Arbitrary Slot


-- | Tests for the lock data structure
module Test.Ganeti.Locking.Locks
prop_ReadShow :: Property
prop_ImpliedOrder :: Property
prop_ImpliedIntervall :: Property
prop_ReadShowLevel :: Property
prop_ReadShow_ClientType :: Property
prop_ReadShow_ClientId :: Property
testLocking_Locks :: Test
instance Arbitrary ClientId
instance Arbitrary CPid
instance Arbitrary ClientType
instance Arbitrary LockLevel
instance Arbitrary GanetiLocks


-- | Unittests for ganeti-htools.
module Test.Ganeti.Objects

-- | Generates an instance that is connected to the given networks and
--   possibly some other networks
genInstWithNets :: [String] -> Gen Instance

-- | Generates an instance that is connected to some networks
genInst :: Gen Instance
enhanceInstWithNets :: Instance -> [String] -> Gen Instance
genDiskWithChildren :: Int -> Gen Disk
genDisk :: Gen Disk

-- | Generates a network instance with minimum netmasks of /24. Generating
--   bigger networks slows down the tests, because long bit strings are
--   generated for the reservations.
genValidNetwork :: Gen Network
genBitString :: Int -> Gen AddressPool

-- | Generate an arbitrary string consisting of '0' and '1' of the maximum
--   given length.
genBitStringMaxLen :: Int -> Gen AddressPool

-- | Generator for config data with an empty cluster (no instances), with N
--   defined nodes.
genEmptyCluster :: Int -> Gen ConfigData

-- | FIXME: make an even simpler base version of creating a cluster.
--   
--   Generates config data with a couple of networks.
genConfigDataWithNetworks :: ConfigData -> Gen ConfigData
prop_fillDict :: [(Int, Int)] -> [(Int, Int)] -> Property
prop_LogicalVolume_serialisation :: LogicalVolume -> Property
prop_LogicalVolume_deserialisationFail :: Property
prop_Disk_serialisation :: Disk -> Property
prop_Disk_array_serialisation :: Disk -> Property
prop_Node_serialisation :: Node -> Property
prop_Inst_serialisation :: Instance -> Property
prop_AddressPool_serialisation :: AddressPool -> Property
prop_Network_serialisation :: Network -> Property
prop_FilterAction_serialisation :: FilterAction -> Property
prop_FilterPredicate_serialisation :: FilterPredicate -> Property
prop_Config_serialisation :: Property
casePyCompatNetworks :: Assertion
getNetworkProperties :: Network -> (Int, Int, Network)
casePyCompatNodegroups :: Assertion
genNodeGroup :: Gen NodeGroup
prop_ip4AddressAsNum :: Ip4Address -> Property
prop_ip4AddressToNumber :: Word32 -> Property
caseNextIp4Address :: Assertion
casePyCompatInstances :: Assertion
mkLIDPlain :: String -> String -> DiskLogicalId
caseIncludeLogicalIdPlain :: Assertion
caseIncludeLogicalIdDrbd :: Assertion
caseNotIncludeLogicalIdPlain :: Assertion
testObjects :: Test
instance IsString Ip4Address
instance Arbitrary Ip4Network
instance Arbitrary Ip4Address
instance Arbitrary NodeGroup
instance Arbitrary FilterRule
instance Arbitrary FilterPredicate
instance Arbitrary FilterAction
instance Arbitrary Network
instance Arbitrary AddressPool
instance Arbitrary Cluster
instance Arbitrary IAllocatorParams
instance Arbitrary TagSet
instance Arbitrary ClusterBeParams
instance Arbitrary ClusterOsParams
instance Arbitrary a => Arbitrary (Private a)
instance Arbitrary ClusterOsParamsPrivate
instance Arbitrary OsParams
instance Arbitrary ClusterNicParams
instance Arbitrary GroupDiskParams
instance Arbitrary OsHvParams
instance Arbitrary ClusterHvParams
instance Arbitrary FilledBeParams
instance Arbitrary FilledNicParams
instance Arbitrary FilledNDParams
instance Arbitrary IpFamily
instance Arbitrary FilledIPolicy
instance Arbitrary MinMaxISpecs
instance Arbitrary FilledISpecParams
instance Arbitrary PartialIPolicy
instance Arbitrary PartialISpecParams
instance Arbitrary Instance
instance Arbitrary RealInstanceData
instance Arbitrary ForthcomingInstanceData
instance Arbitrary PartialNic
instance Arbitrary PartialNicParams
instance Arbitrary AdminStateSource
instance Arbitrary AdminState
instance Arbitrary PartialBeParams
instance Arbitrary Disk
instance Arbitrary DiskLogicalId
instance Arbitrary LogicalVolume
instance Arbitrary DiskMode
instance Arbitrary BlockDriver
instance Arbitrary Node
instance Arbitrary PartialNDParams
instance Arbitrary (Container DataCollectorConfig)

module Test.Ganeti.Network
prop_addressPoolProperties :: Network -> Property
subsetMaybe :: Maybe BitArray -> Maybe BitArray -> Bool
allReservationsSubsumesInternal :: Network -> Bool
allReservationsSubsumesExternal :: Network -> Bool
checkCounts :: Network -> Property
checkIsFull :: Network -> Property
checkGetMap :: Network -> Property
testNetwork :: Test


-- | Unittests for Network Queries.
module Test.Ganeti.Query.Network
prop_getGroupConnection :: NodeGroup -> Property
prop_getGroupConnection_notFound :: NodeGroup -> String -> Property
prop_instIsConnected :: ConfigData -> Property
prop_instIsConnected_notFound :: ConfigData -> String -> Property
testQuery_Network :: Test
instance Arbitrary ConfigData


-- | Unittests for ganeti-htools.
module Test.Ganeti.Rpc
genStorageUnit :: Gen StorageUnit
genStorageUnits :: Gen [StorageUnit]
genStorageUnitMap :: Gen (Map String [StorageUnit])
genHvParams :: Gen HvParams
genHvSpecs :: Gen [(Hypervisor, HvParams)]
genConsoleInfoCallParams :: Gen [(String, InstanceConsoleInfoParams)]
genInstanceConsoleInfoParams :: Gen InstanceConsoleInfoParams
runOfflineTest :: (Rpc a b, Eq b, Show b) => a -> Property
prop_noffl_request_allinstinfo :: RpcCallAllInstancesInfo -> Property
prop_noffl_request_instconsinfo :: RpcCallInstanceConsoleInfo -> Property
prop_noffl_request_instlist :: RpcCallInstanceList -> Property
prop_noffl_request_nodeinfo :: RpcCallNodeInfo -> Property
prop_Compressed_serialisation :: Compressed -> Property
testRpc :: Test
instance Arbitrary RpcCallNodeInfo
instance Arbitrary RpcCallInstanceList
instance Arbitrary RpcCallAllInstancesInfo
instance Arbitrary Compressed
instance Arbitrary RpcCallInstanceConsoleInfo


-- | Tests for temporary configuration resources allocation
module Test.Ganeti.WConfd.TempRes
prop_IPv4Reservation_serialisation :: IPv4Reservation -> Property
prop_TempRes_serialisation :: TempRes Int Int -> Property
testWConfd_TempRes :: Test
instance Arbitrary TempResState
instance (Arbitrary k, Ord k, Arbitrary v, Ord v) => Arbitrary (TempRes k v)
instance Arbitrary IPv4Reservation
instance Arbitrary IPv4ResAction


-- | Unittests for ganeti-htools.
module Test.Ganeti.JSON
prop_toArray :: [Int] -> Property
prop_toArrayFail :: Int -> String -> Bool -> Property
arrayMaybeToJson :: JSON a => [Maybe a] -> String -> JSRecord
prop_arrayMaybeFromObj :: String -> [Maybe Int] -> String -> Property
prop_arrayMaybeFromObjFail :: String -> String -> Property
prop_MaybeForJSON_serialisation :: MaybeForJSON String -> Property
prop_TimeAsDoubleJSON_serialisation :: TimeAsDoubleJSON -> Property
isJError :: Result a -> Bool
case_nestedAccessByKey :: Assertion
case_nestedAccessByKeyDotted :: Assertion
testJSON :: Test
instance Arbitrary TimeAsDoubleJSON
instance Arbitrary a => Arbitrary (MaybeForJSON a)


-- | Unittests for ganeti-htools.
module Test.Ganeti.OpCodes
arbitraryOpTagsGet :: Gen OpCode
arbitraryOpTagsSet :: Gen OpCode
arbitraryOpTagsDel :: Gen OpCode
arbitraryDataCollector :: Gen (Container Bool)
arbitraryDataCollectorInterval :: Gen (Maybe (Container Int))
emptyJSObject :: JSObject JSValue
emptyMUD :: Gen (Maybe (JSObject JSValue))
genEmptyContainer :: Ord a => Gen (GenericContainer a b)
genDiskIndices :: Gen [DiskIndex]
genNodeNames :: Gen [String]
genNodeNamesNE :: Gen [NonEmptyString]
genNodeNameNE :: Gen NonEmptyString
genNameNE :: Gen NonEmptyString
genNamesNE :: Gen [NonEmptyString]
genFieldsNE :: Gen [NonEmptyString]
genMacPrefix :: Gen NonEmptyString
arbitraryPrivateJSObj :: Gen (JSObject (Private JSValue))
isJsonError :: Result a -> Bool
prop_serialization :: OpCode -> Property
case_AllDefined :: Assertion
case_py_compat_types :: Assertion
case_py_compat_fields :: Assertion
prop_setOpComment :: MetaOpCode -> String -> Property
prop_mkDiskIndex_fail :: Positive Int -> Property
case_readRecreateDisks_fail :: Assertion
case_readDdmOldChanges_fail :: Assertion
case_readExportTarget_fail :: Assertion
testOpCodes :: Test
instance Arbitrary MetaOpCode
instance Arbitrary CommonOpParams
instance Arbitrary OpCode
instance Arbitrary ExportTarget
instance Arbitrary a => Arbitrary (SetParamsMods a)
instance Arbitrary DdmOldChanges
instance Arbitrary RecreateDisksInfo
instance Arbitrary IDiskParams
instance Arbitrary INicParams
instance Arbitrary DiskIndex
instance Arbitrary DiskAccess
instance Arbitrary ReplaceDisksMode


-- | Unittests for <a>Objects</a>.
module Test.Ganeti.JQueue.Objects

-- | noTimestamp in Just form.
justNoTs :: Maybe Timestamp

-- | Generates a simple queued opcode.
genQueuedOpCode :: Gen QueuedOpCode

-- | Generates an static, empty job.
emptyJob :: Monad m => m QueuedJob

-- | Generates a job ID.
genJobId :: Gen JobId


-- | Unittests for the job scheduler.
module Test.Ganeti.JQScheduler
genRateLimitReason :: Gen String
case_parseReasonRateLimit :: Assertion
prop_slotMapFromJob_conflicting_buckets :: Property
case_reasonRateLimit :: Assertion
prop_reasonRateLimit :: Property
prop_filterRuleOrder :: Property
case_matchPredicate :: Assertion
prop_applyingFilter :: Property
case_jobFiltering :: Assertion
prop_jobFiltering :: Property
testJQScheduler :: Test
instance Arbitrary Queue
instance Arbitrary JobWithStat
instance Arbitrary QueuedJob


-- | Unittests for the job queue functionality.
module Test.Ganeti.JQueue
case_JobPriorityDef :: Assertion
prop_JobPriority :: Property
case_JobStatusDef :: Assertion
prop_JobStatus :: Property
case_JobStatusPri_py_equiv :: Assertion
prop_ListJobIDs :: Property
prop_LoadJobs :: Property
prop_DetermineDirs :: Property
prop_InputOpCode :: MetaOpCode -> Int -> Property
prop_extractOpSummary :: MetaOpCode -> Int -> Property
testJQueue :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Luxi
prop_CallEncoding :: LuxiOp -> Property
luxiServerPong :: Client -> IO ()
luxiClientPong :: Client -> [String] -> IO [String]
prop_ClientServer :: [[DNSChar]] -> Property
case_AllDefined :: Assertion
testLuxi :: Test
instance Arbitrary LuxiOp
instance Arbitrary LuxiReq


-- | Tests for lock allocation.
module Test.Ganeti.Locking.Allocation
data TestOwner
TestOwner :: Int -> TestOwner
data TestLock
TestBigLock :: TestLock
TestCollectionLockA :: TestLock
TestLockA :: Int -> TestLock
TestCollectionLockB :: TestLock
TestLockB :: Int -> TestLock
data UpdateRequest b a
UpdateRequest :: b -> [LockRequest a] -> UpdateRequest b a
FreeLockRequest :: b -> UpdateRequest b a
asAllocTrans :: (Lock a, Ord b, Show b) => LockAllocation a b -> UpdateRequest b a -> LockAllocation a b
foldUpdates :: (Lock a, Ord b, Show b) => [UpdateRequest b a] -> LockAllocation a b
prop_LocksDisjoint :: Property
prop_LockslistComplete :: Property
prop_LocksAllOwnersSubsetLockslist :: Property
prop_LocksAllOwnersComplete :: Property
prop_LocksAllOwnersSound :: Property
prop_LockImplicationX :: Property
prop_LockImplicationS :: Property
prop_LocksStable :: Property

-- | Verify that a given request is statisfied in list of owned locks
requestSucceeded :: Ord a => Map a OwnerState -> LockRequest a -> Bool
prop_LockupdateAtomic :: Property
prop_LockReleaseSucceeds :: Property
prop_BlockSufficient :: Property
prop_BlockNecessary :: Property
prop_ReadShow :: Property
prop_OwnerComplete :: Property
prop_OwnerSound :: Property
prop_ReadShowRequest :: Property
testLocking_Allocation :: Test
instance Ord TestOwner
instance Eq TestOwner
instance Show TestOwner
instance Ord TestLock
instance Eq TestLock
instance Show TestLock
instance Read TestLock
instance (Show b, Show a) => Show (UpdateRequest b a)
instance JSON TestLock
instance JSON TestOwner
instance (Arbitrary a, Lock a, Arbitrary b, Ord b, Show b) => Arbitrary (LockAllocation a b)
instance (Arbitrary a, Arbitrary b) => Arbitrary (UpdateRequest a b)
instance Arbitrary a => Arbitrary (LockRequest a)
instance Arbitrary OwnerState
instance Lock TestLock
instance Arbitrary TestLock
instance Arbitrary TestOwner


-- | Tests for lock waiting structure.
module Test.Ganeti.Locking.Waiting
data UpdateRequest a b c
Update :: b -> [LockRequest a] -> UpdateRequest a b c
UpdateWaiting :: c -> b -> [LockRequest a] -> UpdateRequest a b c
RemovePending :: b -> UpdateRequest a b c
IntersectRequest :: b -> [a] -> UpdateRequest a b c
OpportunisticUnion :: b -> [(a, OwnerState)] -> UpdateRequest a b c
asWaitingTrans :: (Lock a, Ord b, Ord c) => LockWaiting a b c -> UpdateRequest a b c -> LockWaiting a b c
foldUpdates :: (Lock a, Ord b, Ord c) => [UpdateRequest a b c] -> LockWaiting a b c
prop_NoActionWithPendingRequests :: Property
forAllBlocked :: Testable prop => (LockWaiting TestLock TestOwner Integer -> TestOwner -> Integer -> [LockRequest TestLock] -> prop) -> Property
prop_WaitingRequestsGetPending :: Property
prop_PendingGetFulfilledEventually :: Property
prop_PendingGetNotifiedEventually :: Property
prop_Progress :: Property
prop_ProgressSound :: Property
prop_PendingJustified :: Property
prop_UpdateIdempotent :: Property
prop_extReprPreserved :: Property
prop_SimulateUpdateLocks :: Property
prop_SimulateUpdateLocksWaiting :: Property
prop_SafeUpdateWaitingCorrect :: Property
prop_SafeUpdateWaitingIdempotent :: Property
prop_ReadShow :: Property
prop_OpportunisticMonotone :: Property
prop_OpportunisticAnswer :: Property
testLocking_Waiting :: Test
instance (Show a, Show b, Show c) => Show (UpdateRequest a b c)
instance (Arbitrary a, Lock a, Arbitrary b, Ord b, Arbitrary c, Ord c) => Arbitrary (LockWaiting a b c)
instance (Arbitrary a, Arbitrary b, Arbitrary c) => Arbitrary (UpdateRequest a b c)


-- | Unittests for ganeti-htools.
module Test.Ganeti.Query.Filter
checkQueryResults :: ConfigData -> Query -> String -> [[ResultEntry]] -> Property
makeNodeQuery :: Filter FilterField -> Query
expectBadQuery :: ConfigData -> Query -> String -> Property
namesToResult :: [String] -> [[ResultEntry]]
genClusterNames :: Int -> Int -> Gen (ConfigData, [String])
prop_node_single_filter :: Property
prop_node_many_filter :: Property
prop_node_name_ordering :: Property
prop_node_regex_filter :: Property
prop_node_bad_filter :: String -> Int -> Property
prop_makeSimpleFilter :: Property
testQuery_Filter :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Query.Query
hasUnknownFields :: [FieldDefinition] -> Bool
prop_queryNode_noUnknown :: Property
prop_queryNode_Unknown :: Property
checkResultType :: FieldDefinition -> ResultEntry -> Property
prop_queryNode_types :: Property
case_queryNode_allfields :: Assertion
areNodeNamesSane :: ConfigData -> Bool
prop_queryNode_filter :: Property
prop_queryGroup_noUnknown :: Property
prop_queryGroup_Unknown :: Property
prop_queryGroup_types :: Property
case_queryGroup_allfields :: Assertion
prop_queryGroup_nodeCount :: Property
prop_queryJob_noUnknown :: Property
prop_queryJob_Unknown :: Property
prop_getRequestedNames :: Property
testQuery_Query :: Test


-- | Unittests for ganeti-htools.
module Test.Ganeti.Utils
genNonCommaString :: Gen String
prop_commaJoinSplit :: Property
prop_commaSplitJoin :: String -> Property
prop_findFirst :: Property
prop_fromObjWithDefault :: Integer -> String -> Bool
prop_if'if :: Bool -> Int -> Int -> Property
prop_select :: Int -> [Int] -> [Int] -> Property
prop_select_undefd :: [Int] -> NonEmptyList Int -> Property
prop_select_undefv :: [Int] -> NonEmptyList Int -> Property
prop_parseUnit :: NonNegative Int -> Property
case_niceSort_static :: Assertion
prop_niceSort_single :: Property
prop_niceSort_generic :: Property
prop_niceSort_numbers :: Property
prop_niceSortKey_equiv :: Property
prop_rStripSpace :: NonEmptyList Char -> Property
case_new_uuid :: Assertion
case_new_uuid_regex :: Assertion
prop_clockTimeToString :: Integer -> Integer -> Property
prop_chompPrefix_normal :: String -> Property
prop_chompPrefix_last :: Property
prop_chompPrefix_empty_string :: Property
prop_chompPrefix_nothing :: Property
prop_trim :: NonEmptyList Char -> Property
prop_splitRecombineEithers :: [Either Int Int] -> Property
prop_isSubsequenceOf :: Property
testUtils :: Test


-- | Auto-generated file importing all production modules.
module Test.Ganeti.TestImports
