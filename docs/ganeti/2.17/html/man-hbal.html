

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>hbal &mdash; Ganeti 2.17.0~beta1 documentation</title>
    
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.17.0~beta1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Ganeti 2.17.0~beta1 documentation" href="index.html" />
    <link rel="up" title="Man pages" href="manpages.html" />
    <link rel="next" title="hcheck" href="man-hcheck.html" />
    <link rel="prev" title="harep" href="man-harep.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="man-hcheck.html" title="hcheck"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="man-harep.html" title="harep"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Ganeti 2.17.0~beta1 documentation</a> &raquo;</li>
          <li><a href="manpages.html" accesskey="U">Man pages</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="hbal">
<h1>hbal<a class="headerlink" href="#hbal" title="Permalink to this headline">¶</a></h1>
<div class="section" id="name">
<h2>NAME<a class="headerlink" href="#name" title="Permalink to this headline">¶</a></h2>
<p>hbal - Cluster balancer for Ganeti</p>
</div>
<div class="section" id="synopsis">
<h2>SYNOPSIS<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<p><strong>hbal</strong> {backend options...} [algorithm options...] [reporting options...]</p>
<p><strong>hbal</strong> &#8211;version</p>
<p>Backend options:</p>
<p>{ <strong>-m</strong> <em>cluster</em> | <strong>-L[</strong> <em>path</em> <strong>] [-X]</strong> | <strong>-t</strong> <em>data-file</em> |
<strong>-I</strong> <em>path</em> }</p>
<p>Algorithm options:</p>
<p><strong>[ &#8211;max-cpu *cpu-ratio* ]</strong>
<strong>[ &#8211;min-disk *disk-ratio* ]</strong>
<strong>[ -l *limit* ]</strong>
<strong>[ -e *score* ]</strong>
<strong>[ -g *delta* ]</strong> <strong>[ &#8211;min-gain-limit *threshold* ]</strong>
<strong>[ -O *name...* ]</strong>
<strong>[ &#8211;no-disk-moves ]</strong>
<strong>[ &#8211;avoid-disk-moves *factor* ]</strong>
<strong>[ &#8211;no-instance-moves ]</strong>
<strong>[ -U *util-file* ]</strong>
<strong>[ &#8211;idle-default ]</strong>
<strong>[ &#8211;ignore-dynu ]</strong>
<strong>[ &#8211;ignore-soft-errors ]</strong>
<strong>[ &#8211;mond *yes|no* ]</strong>
<strong>[ &#8211;mond-xen ]</strong>
<strong>[ &#8211;mond-kvm-rss ]</strong>
<strong>[ &#8211;exit-on-missing-mond-data ]</strong>
<strong>[ &#8211;evac-mode ]</strong>
<strong>[ &#8211;restricted-migration ]</strong>
<strong>[ &#8211;select-instances *inst...* ]</strong>
<strong>[ &#8211;exclude-instances *inst...* ]</strong></p>
<p>Reporting options:</p>
<p><strong>[ -C[ *file* ] ]</strong>
<strong>[ -p[ *fields* ] ]</strong>
<strong>[ &#8211;print-instances ]</strong>
<strong>[ -S *file* ]</strong>
<strong>[ -v... | -q ]</strong></p>
</div>
<div class="section" id="description">
<h2>DESCRIPTION<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>hbal is a cluster balancer that looks at the current state of the
cluster (nodes with their total and free disk, memory, etc.) and
instance placement and computes a series of steps designed to bring
the cluster into a better state.</p>
<p>The algorithm used is designed to be stable (i.e. it will give you the
same results when restarting it from the middle of the solution) and
reasonably fast. It is not, however, designed to be a perfect algorithm:
it is possible to make it go into a corner from which it can find no
improvement, because it looks only one &#8220;step&#8221; ahead.</p>
<p>The program accesses the cluster state via Rapi or Luxi. It also
requests data over the network from all MonDs with the &#8211;mond option.
Currently it uses only data produced by CPUload collector.</p>
<p>By default, the program will show the solution incrementally as it is
computed, in a somewhat cryptic format; for getting the actual Ganeti
command list, use the <strong>-C</strong> option.</p>
<div class="section" id="algorithm">
<h3>ALGORITHM<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h3>
<p>The program works in independent steps; at each step, we compute the
best instance move that lowers the cluster score.</p>
<p>The possible move type for an instance are combinations of
failover/migrate and replace-disks such that we change one of the
instance nodes, and the other one remains (but possibly with changed
role, e.g. from primary it becomes secondary). The list is:</p>
<ul class="simple">
<li>failover (f)</li>
<li>replace secondary (r)</li>
<li>replace primary, a composite move (f, r, f)</li>
<li>failover and replace secondary, also composite (f, r)</li>
<li>replace secondary and failover, also composite (r, f)</li>
</ul>
<p>We don&#8217;t do the only remaining possibility of replacing both nodes
(r,f,r,f or the equivalent f,r,f,r) since these move needs an
exhaustive search over both candidate primary and secondary nodes, and
is O(n*n) in the number of nodes. Furthermore, it doesn&#8217;t seems to
give better scores but will result in more disk replacements.</p>
</div>
<div class="section" id="placement-restrictions">
<h3>PLACEMENT RESTRICTIONS<a class="headerlink" href="#placement-restrictions" title="Permalink to this headline">¶</a></h3>
<p>At each step, we prevent an instance move if it would cause:</p>
<ul class="simple">
<li>a node to go into N+1 failure state</li>
<li>an instance to move onto an offline node (offline nodes are either
read from the cluster or declared with <em>-O</em>; drained nodes are
considered offline)</li>
<li>an exclusion-tag based conflict (exclusion tags are read from the
cluster and/or defined via the <em>&#8211;exclusion-tags</em> option)</li>
<li>a max vcpu/pcpu ratio to be exceeded (configured via <em>&#8211;max-cpu</em>)</li>
<li>min disk free percentage to go below the configured limit
(configured via <em>&#8211;min-disk</em>)</li>
</ul>
</div>
<div class="section" id="cluster-scoring">
<h3>CLUSTER SCORING<a class="headerlink" href="#cluster-scoring" title="Permalink to this headline">¶</a></h3>
<p>As said before, the algorithm tries to minimise the cluster score at
each step. Currently this score is computed as a weighted sum of the
following components:</p>
<ul class="simple">
<li>standard deviation of the percent of free memory</li>
<li>standard deviation of the percent of reserved memory</li>
<li>the sum of the percentages of reserved memory</li>
<li>standard deviation of the percent of free disk</li>
<li>count of nodes failing N+1 check</li>
<li>count of instances living (either as primary or secondary) on
offline nodes; in the sense of hbal (and the other htools) drained
nodes are considered offline</li>
<li>count of instances living (as primary) on offline nodes; this
differs from the above metric by helping failover of such instances
in 2-node clusters</li>
<li>standard deviation of the ratio of virtual-to-physical cpus (for
primary instances of the node)</li>
<li>standard deviation of the fraction of the available spindles
(in dedicated mode, spindles represent physical spindles; otherwise
this oversubscribable measure for IO load, and the oversubscription
factor is taken into account when computing the number of available
spindles)</li>
<li>standard deviation of the dynamic load on the nodes, for cpus,
memory, disk and network</li>
<li>standard deviation of the CPU load provided by MonD</li>
<li>the count of instances with primary and secondary in the same failure
domain</li>
<li>the count of instances sharing the same exclusion tags which primary
instances placed in the same failure domain</li>
<li>the overall sum of dissatisfied desired locations among all cluster
instances</li>
</ul>
<p>The free memory and free disk values help ensure that all nodes are
somewhat balanced in their resource usage. The reserved memory helps
to ensure that nodes are somewhat balanced in holding secondary
instances, and that no node keeps too much memory reserved for
N+1. And finally, the N+1 percentage helps guide the algorithm towards
eliminating N+1 failures, if possible.</p>
<p>Except for the N+1 failures, offline instances counts, failure
domain violation counts and desired locations count, we use the
standard deviation since when used with values within a fixed range
(we use percents expressed as values between zero and one) it gives
consistent results across all metrics (there are some small issues
related to different means, but it works generally well). The &#8216;count&#8217;
type values will have higher score and thus will matter more for
balancing; thus these are better for hard constraints (like evacuating
nodes and fixing N+1 failures). For example, the offline instances
count (i.e. the number of instances living on offline nodes) will
cause the algorithm to actively move instances away from offline
nodes. This, coupled with the restriction on placement given by
offline nodes, will cause evacuation of such nodes.</p>
<p>The dynamic load values need to be read from an external file (Ganeti
doesn&#8217;t supply them), and are computed for each node as: sum of
primary instance cpu load, sum of primary instance memory load, sum of
primary and secondary instance disk load (as DRBD generates write load
on secondary nodes too in normal case and in degraded scenarios also
read load), and sum of primary instance network load. An example of
how to generate these values for input to hbal would be to track <tt class="docutils literal"><span class="pre">xm</span>
<span class="pre">list</span></tt> for instances over a day and by computing the delta of the cpu
values, and feed that via the <em>-U</em> option for all instances (and keep
the other metrics as one). For the algorithm to work, all that is
needed is that the values are consistent for a metric across all
instances (e.g. all instances use cpu% to report cpu usage, and not
something related to number of CPU seconds used if the CPUs are
different), and that they are normalised to between zero and one. Note
that it&#8217;s recommended to not have zero as the load value for any
instance metric since then secondary instances are not well balanced.</p>
<p>The CPUload from MonD&#8217;s data collector will be used only if all MonDs
are running, otherwise it won&#8217;t affect the cluster score. Since we can&#8217;t
find the CPU load of each instance, we can assume that the CPU load of
an instance is proportional to the number of its vcpus. With this
heuristic, instances from nodes with high CPU load will tend to move to
nodes with less CPU load.</p>
<p>On a perfectly balanced cluster (all nodes the same size, all
instances the same size and spread across the nodes equally,
all desired locations satisfied), the values for all metrics
would be zero, with the exception of the total percentage of
reserved memory. This doesn&#8217;t happen too often in practice :)</p>
</div>
<div class="section" id="offline-instances">
<h3>OFFLINE INSTANCES<a class="headerlink" href="#offline-instances" title="Permalink to this headline">¶</a></h3>
<p>Since current Ganeti versions do not report the memory used by offline
(down) instances, ignoring the run status of instances will cause
wrong calculations. For this reason, the algorithm subtracts the
memory size of down instances from the free node memory of their
primary node, in effect simulating the startup of such instances.</p>
</div>
<div class="section" id="desired-location-tags">
<h3>DESIRED LOCATION TAGS<a class="headerlink" href="#desired-location-tags" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, administrators want specific instances located in a particular,
typically geographic, location. To suppoer this desired location tags are
introduced.</p>
<p>If the cluster is tagged <em>htools:desiredlocation:x</em> then tags starting with
<em>x</em> are desired location tags. Instances can be assigned tags of the form <em>x</em>
that means that instance wants to be placed on a node tagged with a location
tag <em>x</em>. (That means that cluster should be tagged <em>htools:nlocation:x</em> too).</p>
<p>Instance pinning is just heuristics, not a hard enforced requirement;
it will only be achieved by the cluster metrics favouring such placements.</p>
</div>
<div class="section" id="exclusion-tags">
<h3>EXCLUSION TAGS<a class="headerlink" href="#exclusion-tags" title="Permalink to this headline">¶</a></h3>
<p>The exclusion tags mechanism is designed to prevent instances which
run the same workload (e.g. two DNS servers) to land on the same node,
which would make the respective node a SPOF for the given service.</p>
<p>It works by tagging instances with certain tags and then building
exclusion maps based on these. Which tags are actually used is
configured either via the command line (option <em>&#8211;exclusion-tags</em>)
or via adding them to the cluster tags:</p>
<dl class="docutils">
<dt>&#8211;exclusion-tags=a,b</dt>
<dd>This will make all instance tags of the form <em>a:*</em>, <em>b:*</em> be
considered for the exclusion map</dd>
<dt>cluster tags <em>htools:iextags:a</em>, <em>htools:iextags:b</em></dt>
<dd>This will make instance tags <em>a:*</em>, <em>b:*</em> be considered for the
exclusion map. More precisely, the suffix of cluster tags starting
with <em>htools:iextags:</em> will become the prefix of the exclusion tags.</dd>
</dl>
<p>Both the above forms mean that two instances both having (e.g.) the
tag <em>a:foo</em> or <em>b:bar</em> won&#8217;t end on the same node.</p>
</div>
<div class="section" id="migration-tags">
<h3>MIGRATION TAGS<a class="headerlink" href="#migration-tags" title="Permalink to this headline">¶</a></h3>
<p>If Ganeti is deployed on a heterogeneous cluster, migration might
not be possible between all nodes of a node group. One example of
such a situation is upgrading the hypervisor node by node. To make
hbal aware of those restrictions, the following cluster tags are used.</p>
<dl class="docutils">
<dt>cluster tags <em>htools:migration:a</em>, <em>htools:migration:b</em>, etc</dt>
<dd>This make make node tags of the form <em>a:*</em>, <em>b:*</em>, etc be considered
migration restriction. More precisely, the suffix of cluster tags starting
with <em>htools:migration:</em> will become the prefix of the migration tags.
Only those migrations will be taken into consideration where all migration
tags of the source node are also present on the target node.</dd>
<dt>cluster tags <em>htools:allowmigration:x::y</em> for migration tags <em>x</em> and <em>y</em></dt>
<dd>This asserts that a node taged <em>y</em> is able to receive instances in
the same way as if they had an <em>x</em> tag.</dd>
</dl>
<p>So in the simple case of a hypervisor upgrade, tagging all the nodes
that have been upgraded with a migration tag suffices. In more complicated
situations, it is always possible to use a different migration tag for
each hypervisor used and explictly state the allowed migration directions
by means of <em>htools:allowmigration:</em> tags.</p>
</div>
<div class="section" id="location-tags">
<h3>LOCATION TAGS<a class="headerlink" href="#location-tags" title="Permalink to this headline">¶</a></h3>
<p>Within a node group, certain nodes might be more likely to fail simultaneously
due to a common cause of error (e.g., if they share the same power supply unit).
Ganeti can be made aware of thos common causes of failure by means of tags.</p>
<dl class="docutils">
<dt>cluster tags <em>htools:nlocation:a</em>, <em>htools:nlocation:b</em>, etc</dt>
<dd>This make make node tags of the form <em>a:*</em>, <em>b:*</em>, etc be considered
to have a common cause of failure.</dd>
</dl>
<p>Instances with primary and secondary node having a common cause of failure and
instances sharing the same exclusion tag with primary nodes having a common
failure are considered badly placed. While such placements are always allowed,
they count heavily towards the cluster score.</p>
</div>
</div>
<div class="section" id="options">
<h2>OPTIONS<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h2>
<p>The options that can be passed to the program are as follows:</p>
<dl class="docutils">
<dt>-C, &#8211;print-commands</dt>
<dd><p class="first">Print the command list at the end of the run. Without this, the
program will only show a shorter, but cryptic output.</p>
<p>Note that the moves list will be split into independent steps,
called &#8220;jobsets&#8221;, but only for visual inspection, not for actually
parallelisation. It is not possible to parallelise these directly
when executed via &#8220;gnt-instance&#8221; commands, since a compound command
(e.g. failover and replace-disks) must be executed
serially. Parallel execution is only possible when using the Luxi
backend and the <em>-L</em> option.</p>
<p class="last">The algorithm for splitting the moves into jobsets is by
accumulating moves until the next move is touching nodes already
touched by the current moves; this means we can&#8217;t execute in
parallel (due to resource allocation in Ganeti) and thus we start a
new jobset.</p>
</dd>
<dt>-p, &#8211;print-nodes</dt>
<dd>Prints the before and after node status, in a format designed to allow
the user to understand the node&#8217;s most important parameters. See the
man page <strong>htools</strong>(1) for more details about this option.</dd>
<dt>&#8211;print-instances</dt>
<dd>Prints the before and after instance map. This is less useful as the
node status, but it can help in understanding instance moves.</dd>
<dt>-O <em>name</em></dt>
<dd><p class="first">This option (which can be given multiple times) will mark nodes as
being <em>offline</em>. This means a couple of things:</p>
<ul class="simple">
<li>instances won&#8217;t be placed on these nodes, not even temporarily;
e.g. the <em>replace primary</em> move is not available if the secondary
node is offline, since this move requires a failover.</li>
<li>these nodes will not be included in the score calculation (except
for the percentage of instances on offline nodes)</li>
</ul>
<p class="last">Note that algorithm will also mark as offline any nodes which are
reported by RAPI as such, or that have &#8221;?&#8221; in file-based input in
any numeric fields.</p>
</dd>
<dt>-e <em>score</em>, &#8211;min-score=*score*</dt>
<dd><p class="first">This parameter denotes how much above the N+1 bound the cluster score
can for us to be happy with and alters the computation in two ways:</p>
<ul class="simple">
<li>if the cluster has the initial score lower than this value, then we
don&#8217;t enter the algorithm at all, and exit with success</li>
<li>during the iterative process, if we reach a score lower than this
value, we exit the algorithm</li>
</ul>
<p class="last">The default value of the parameter is currently <tt class="docutils literal"><span class="pre">1e-9</span></tt> (chosen
empirically).</p>
</dd>
<dt>-g <em>delta</em>, &#8211;min-gain=*delta*</dt>
<dd>Since the balancing algorithm can sometimes result in just very tiny
improvements, that bring less gain that they cost in relocation
time, this parameter (defaulting to 0.01) represents the minimum
gain we require during a step, to continue balancing.</dd>
<dt>&#8211;min-gain-limit=*threshold*</dt>
<dd>The above min-gain option will only take effect if the cluster score
is already below <em>threshold</em> (defaults to 0.1). The rationale behind
this setting is that at high cluster scores (badly balanced
clusters), we don&#8217;t want to abort the rebalance too quickly, as
later gains might still be significant. However, under the
threshold, the total gain is only the threshold value, so we can
exit early.</dd>
<dt>&#8211;no-disk-moves</dt>
<dd>This parameter prevents hbal from using disk move
(i.e. &#8220;gnt-instance replace-disks&#8221;) operations. This will result in
a much quicker balancing, but of course the improvements are
limited. It is up to the user to decide when to use one or another.</dd>
<dt>&#8211;avoid-disk-moves=*factor*</dt>
<dd>This parameter prevents hbal from not profitable enough disk moves.
During each balancing step it will admit disk move only if the gain
in the cluster metrics is <em>factor</em> times higher than the gain
achievable without disk moves.</dd>
<dt>&#8211;no-instance-moves</dt>
<dd>This parameter prevents hbal from using instance moves
(i.e. &#8220;gnt-instance migrate/failover&#8221;) operations. This will only use
the slow disk-replacement operations, and will also provide a worse
balance, but can be useful if moving instances around is deemed unsafe
or not preferred.</dd>
<dt>&#8211;evac-mode</dt>
<dd>This parameter restricts the list of instances considered for moving
to the ones living on offline/drained nodes. It can be used as a
(bulk) replacement for Ganeti&#8217;s own <em>gnt-node evacuate</em>, with the
note that it doesn&#8217;t guarantee full evacuation.</dd>
<dt>&#8211;restricted-migration</dt>
<dd>This parameter disallows any replace-primary moves (frf), as well as
those replace-and-failover moves (rf) where the primary node of the
instance is not drained. If used together with the <tt class="docutils literal"><span class="pre">--evac-mode</span></tt>
option, the only migrations that hbal will do are migrations of
instances off a drained node. This can be useful if during a reinstall
of the base operating system migration is only possible from the old
OS to the new OS. Note, however, that usually the use of migration
tags is the better choice.</dd>
<dt>&#8211;select-instances=*instances*</dt>
<dd>This parameter marks the given instances (as a comma-separated list)
as the only ones being moved during the rebalance.</dd>
<dt>&#8211;exclude-instances=*instances*</dt>
<dd>This parameter marks the given instances (as a comma-separated list)
from being moved during the rebalance.</dd>
<dt>-U <em>util-file</em></dt>
<dd><p class="first">This parameter specifies a file holding instance dynamic utilisation
information that will be used to tweak the balancing algorithm to
equalise load on the nodes (as opposed to static resource
usage). The file is in the format &#8220;instance_name cpu_util mem_util
disk_util net_util&#8221; where the &#8220;_util&#8221; parameters are interpreted as
numbers and the instance name must match exactly the instance as
read from Ganeti. In case of unknown instance names, the program
will abort.</p>
<p class="last">If not given, the default values are one for all metrics and thus
dynamic utilisation has only one effect on the algorithm: the
equalisation of the secondary instances across nodes (this is the
only metric that is not tracked by another, dedicated value, and
thus the disk load of instances will cause secondary instance
equalisation). Note that value of one will also influence slightly
the primary instance count, but that is already tracked via other
metrics and thus the influence of the dynamic utilisation will be
practically insignificant.</p>
</dd>
<dt>&#8211;idle-default</dt>
<dd>If given, all dynamic utilisation information not provided explicitly
by the <tt class="docutils literal"><span class="pre">-U</span></tt> option or by the MonDs, if <tt class="docutils literal"><span class="pre">--mond</span></tt> is given, will be
assumed to be 0. Note that without this option the default assumption
about utilization will apply for the unspecified resources, which is 1.0,
i.e., full load, for every instance.</dd>
<dt>&#8211;ignore-dynu</dt>
<dd>If given, all dynamic utilisation information will be ignored by
assuming it to be 0. This option will take precedence over any data
passed by the <tt class="docutils literal"><span class="pre">-U</span></tt> option or by the MonDs with the <tt class="docutils literal"><span class="pre">--mond</span></tt> and
the <tt class="docutils literal"><span class="pre">--mond-data</span></tt> option.</dd>
<dt>&#8211;ignore-soft-errors</dt>
<dd>If given, all checks for soft errors will be ommitted when considering
balancing moves. In this way, progress can be made in a cluster where
all nodes are in a policy-wise bad state, like exceeding oversubscription
ratios on CPU or spindles.</dd>
<dt>-S <em>filename</em>, &#8211;save-cluster=*filename*</dt>
<dd>If given, the state of the cluster before the balancing is saved to
the given file plus the extension &#8220;original&#8221;
(i.e. <em>filename</em>.original), and the state at the end of the
balancing is saved to the given file plus the extension &#8220;balanced&#8221;
(i.e. <em>filename</em>.balanced). This allows re-feeding the cluster state
to either hbal itself or for example hspace via the <tt class="docutils literal"><span class="pre">-t</span></tt> option.</dd>
<dt>-t <em>datafile</em>, &#8211;text-data=*datafile*</dt>
<dd>Backend specification: the name of the file holding node and instance
information (if not collecting via RAPI or LUXI). This or one of the
other backends must be selected. The option is described in the man
page <strong>htools</strong>(1).</dd>
<dt>&#8211;mond=*yes|no*</dt>
<dd>If given the program will query all MonDs to fetch data from the
supported data collectors over the network.</dd>
<dt>&#8211;mond-xen</dt>
<dd>If given, also query Xen-specific collectors from MonD, provided
that monitoring daemons are queried at all.</dd>
<dt>&#8211;mond-kvm-rss</dt>
<dd>If given, also query the residual set size for kvm instances, provided
that monitoring daemons are queried at all.</dd>
<dt>&#8211;mem-weight=*factor*</dt>
<dd>Scale the weight of the dynamic memory utilization in the cluster metrics
by the given factor.</dd>
<dt>&#8211;exit-on-missing-mond-data</dt>
<dd>If given, abort if the data obtainable from querying MonDs is incomplete.
The default behavior is to continue with a best guess based on the static
information.</dd>
<dt>&#8211;mond-data <em>datafile</em></dt>
<dd>The name of the file holding the data provided by MonD, to override
quering MonDs over the network. This is mostly used for debugging. The
file must be in JSON format and present an array of JSON objects ,
one for every node, with two members. The first member named <tt class="docutils literal"><span class="pre">node</span></tt>
is the name of the node and the second member named <tt class="docutils literal"><span class="pre">reports</span></tt> is an
array of report objects. The report objects must be in the same format
as produced by the monitoring agent.</dd>
<dt>-m <em>cluster</em></dt>
<dd>Backend specification: collect data directly from the <em>cluster</em> given
as an argument via RAPI. The option is described in the man page
<strong>htools</strong>(1).</dd>
<dt>-L [<em>path</em>]</dt>
<dd>Backend specification: collect data directly from the master daemon,
which is to be contacted via LUXI (an internal Ganeti protocol). The
option is described in the man page <strong>htools</strong>(1).</dd>
</dl>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-X</span></kbd></td>
<td><p class="first">When using the Luxi backend, hbal can also execute the given
commands. The execution method is to execute the individual jobsets
(see the <em>-C</em> option for details) in separate stages, aborting if at
any time a jobset doesn&#8217;t have all jobs successful. Each step in the
balancing solution will be translated into exactly one Ganeti job
(having between one and three OpCodes), and all the steps in a
jobset will be executed in parallel. The jobsets themselves are
executed serially.</p>
<p class="last">The execution of the job series can be interrupted, see below for
signal handling.</p>
</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>-l <em>N</em>, &#8211;max-length=*N*</dt>
<dd>Restrict the solution to this length. This can be used for example
to automate the execution of the balancing.</dd>
<dt>&#8211;max-cpu=*cpu-ratio*</dt>
<dd>The maximum virtual to physical cpu ratio, as a floating point number
greater than or equal to one. For example, specifying <em>cpu-ratio</em> as
<strong>2.5</strong> means that, for a 4-cpu machine, a maximum of 10 virtual cpus
should be allowed to be in use for primary instances. A value of
exactly one means there will be no over-subscription of CPU (except
for the CPU time used by the node itself), and values below one do not
make sense, as that means other resources (e.g. disk) won&#8217;t be fully
utilised due to CPU restrictions.</dd>
<dt>&#8211;min-disk=*disk-ratio*</dt>
<dd>The minimum amount of free disk space remaining, as a floating point
number. For example, specifying <em>disk-ratio</em> as <strong>0.25</strong> means that
at least one quarter of disk space should be left free on nodes.</dd>
<dt>-G <em>uuid</em>, &#8211;group=*uuid*</dt>
<dd>On an multi-group cluster, select this group for
processing. Otherwise hbal will abort, since it cannot balance
multiple groups at the same time.</dd>
<dt>-v, &#8211;verbose</dt>
<dd>Increase the output verbosity. Each usage of this option will
increase the verbosity (currently more than 2 doesn&#8217;t make sense)
from the default of one.</dd>
<dt>-q, &#8211;quiet</dt>
<dd>Decrease the output verbosity. Each usage of this option will
decrease the verbosity (less than zero doesn&#8217;t make sense) from the
default of one.</dd>
<dt>-V, &#8211;version</dt>
<dd>Just show the program version and exit.</dd>
</dl>
</div>
<div class="section" id="signal-handling">
<h2>SIGNAL HANDLING<a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h2>
<p>When executing jobs via LUXI (using the <tt class="docutils literal"><span class="pre">-X</span></tt> option), normally hbal
will execute all jobs until either one errors out or all the jobs finish
successfully.</p>
<p>Since balancing can take a long time, it is possible to stop hbal early
in two ways:</p>
<ul class="simple">
<li>by sending a <tt class="docutils literal"><span class="pre">SIGINT</span></tt> (<tt class="docutils literal"><span class="pre">^C</span></tt>), hbal will register the termination
request, and will wait until the currently submitted jobs finish, at
which point it will exit (with exit code 0 if all jobs finished
correctly, otherwise with exit code 1 as usual)</li>
<li>by sending a <tt class="docutils literal"><span class="pre">SIGTERM</span></tt>, hbal will immediately exit (with exit code
2); it is the responsibility of the user to follow up with Ganeti
and check the result of the currently-executing jobs</li>
</ul>
<p>Note that in any situation, it&#8217;s perfectly safe to kill hbal, either via
the above signals or via any other signal (e.g. <tt class="docutils literal"><span class="pre">SIGQUIT</span></tt>,
<tt class="docutils literal"><span class="pre">SIGKILL</span></tt>), since the jobs themselves are processed by Ganeti whereas
hbal (after submission) only watches their progression. In this case,
the user will have to query Ganeti for job results.</p>
</div>
<div class="section" id="exit-status">
<h2>EXIT STATUS<a class="headerlink" href="#exit-status" title="Permalink to this headline">¶</a></h2>
<p>The exit status of the command will be zero, unless for some reason the
algorithm failed (e.g. wrong node or instance data), invalid command
line options, or (in case of job execution) one of the jobs has failed.</p>
<p>Once job execution via Luxi has started (<tt class="docutils literal"><span class="pre">-X</span></tt>), if the balancing was
interrupted early (via <em>SIGINT</em>, or via <tt class="docutils literal"><span class="pre">--max-length</span></tt>) but all jobs
executed successfully, then the exit status is zero; a non-zero exit
code means that the cluster state should be investigated, since a job
failed or we couldn&#8217;t compute its status and this can also point to a
problem on the Ganeti side.</p>
</div>
<div class="section" id="bugs">
<h2>BUGS<a class="headerlink" href="#bugs" title="Permalink to this headline">¶</a></h2>
<p>The program does not check all its input data for consistency, and
sometime aborts with cryptic errors messages with invalid data.</p>
<p>The algorithm is not perfect.</p>
</div>
<div class="section" id="example">
<h2>EXAMPLE<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Note that these examples are not for the latest version (they don&#8217;t
have full node data).</p>
<div class="section" id="default-output">
<h3>Default output<a class="headerlink" href="#default-output" title="Permalink to this headline">¶</a></h3>
<p>With the default options, the program shows each individual step and
the improvements it brings in cluster score:</p>
<div class="highlight-python"><pre>$ hbal
Loaded 20 nodes, 80 instances
Cluster is not N+1 happy, continuing but no guarantee that the cluster will end N+1 happy.
Initial score: 0.52329131
Trying to minimize the CV...
    1. instance14  node1:node10  =&gt; node16:node10 0.42109120 a=f r:node16 f
    2. instance54  node4:node15  =&gt; node16:node15 0.31904594 a=f r:node16 f
    3. instance4   node5:node2   =&gt; node2:node16  0.26611015 a=f r:node16
    4. instance48  node18:node20 =&gt; node2:node18  0.21361717 a=r:node2 f
    5. instance93  node19:node18 =&gt; node16:node19 0.16166425 a=r:node16 f
    6. instance89  node3:node20  =&gt; node2:node3   0.11005629 a=r:node2 f
    7. instance5   node6:node2   =&gt; node16:node6  0.05841589 a=r:node16 f
    8. instance94  node7:node20  =&gt; node20:node16 0.00658759 a=f r:node16
    9. instance44  node20:node2  =&gt; node2:node15  0.00438740 a=f r:node15
   10. instance62  node14:node18 =&gt; node14:node16 0.00390087 a=r:node16
   11. instance13  node11:node14 =&gt; node11:node16 0.00361787 a=r:node16
   12. instance19  node10:node11 =&gt; node10:node7  0.00336636 a=r:node7
   13. instance43  node12:node13 =&gt; node12:node1  0.00305681 a=r:node1
   14. instance1   node1:node2   =&gt; node1:node4   0.00263124 a=r:node4
   15. instance58  node19:node20 =&gt; node19:node17 0.00252594 a=r:node17
Cluster score improved from 0.52329131 to 0.00252594</pre>
</div>
<p>In the above output, we can see:</p>
<ul class="simple">
<li>the input data (here from files) shows a cluster with 20 nodes and
80 instances</li>
<li>the cluster is not initially N+1 compliant</li>
<li>the initial score is 0.52329131</li>
</ul>
<p>The step list follows, showing the instance, its initial
primary/secondary nodes, the new primary secondary, the cluster list,
and the actions taken in this step (with &#8216;f&#8217; denoting failover/migrate
and &#8216;r&#8217; denoting replace secondary).</p>
<p>Finally, the program shows the improvement in cluster score.</p>
<p>A more detailed output is obtained via the <em>-C</em> and <em>-p</em> options:</p>
<div class="highlight-python"><pre>$ hbal
Loaded 20 nodes, 80 instances
Cluster is not N+1 happy, continuing but no guarantee that the cluster will end N+1 happy.
Initial cluster status:
N1 Name   t_mem f_mem r_mem t_dsk f_dsk pri sec  p_fmem  p_fdsk
 * node1  32762  1280  6000  1861  1026   5   3 0.03907 0.55179
   node2  32762 31280 12000  1861  1026   0   8 0.95476 0.55179
 * node3  32762  1280  6000  1861  1026   5   3 0.03907 0.55179
 * node4  32762  1280  6000  1861  1026   5   3 0.03907 0.55179
 * node5  32762  1280  6000  1861   978   5   5 0.03907 0.52573
 * node6  32762  1280  6000  1861  1026   5   3 0.03907 0.55179
 * node7  32762  1280  6000  1861  1026   5   3 0.03907 0.55179
   node8  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node9  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
 * node10 32762  7280 12000  1861  1026   4   4 0.22221 0.55179
   node11 32762  7280  6000  1861   922   4   5 0.22221 0.49577
   node12 32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node13 32762  7280  6000  1861   922   4   5 0.22221 0.49577
   node14 32762  7280  6000  1861   922   4   5 0.22221 0.49577
 * node15 32762  7280 12000  1861  1131   4   3 0.22221 0.60782
   node16 32762 31280     0  1861  1860   0   0 0.95476 1.00000
   node17 32762  7280  6000  1861  1106   5   3 0.22221 0.59479
 * node18 32762  1280  6000  1396   561   5   3 0.03907 0.40239
 * node19 32762  1280  6000  1861  1026   5   3 0.03907 0.55179
   node20 32762 13280 12000  1861   689   3   9 0.40535 0.37068

Initial score: 0.52329131
Trying to minimize the CV...
    1. instance14  node1:node10  =&gt; node16:node10 0.42109120 a=f r:node16 f
    2. instance54  node4:node15  =&gt; node16:node15 0.31904594 a=f r:node16 f
    3. instance4   node5:node2   =&gt; node2:node16  0.26611015 a=f r:node16
    4. instance48  node18:node20 =&gt; node2:node18  0.21361717 a=r:node2 f
    5. instance93  node19:node18 =&gt; node16:node19 0.16166425 a=r:node16 f
    6. instance89  node3:node20  =&gt; node2:node3   0.11005629 a=r:node2 f
    7. instance5   node6:node2   =&gt; node16:node6  0.05841589 a=r:node16 f
    8. instance94  node7:node20  =&gt; node20:node16 0.00658759 a=f r:node16
    9. instance44  node20:node2  =&gt; node2:node15  0.00438740 a=f r:node15
   10. instance62  node14:node18 =&gt; node14:node16 0.00390087 a=r:node16
   11. instance13  node11:node14 =&gt; node11:node16 0.00361787 a=r:node16
   12. instance19  node10:node11 =&gt; node10:node7  0.00336636 a=r:node7
   13. instance43  node12:node13 =&gt; node12:node1  0.00305681 a=r:node1
   14. instance1   node1:node2   =&gt; node1:node4   0.00263124 a=r:node4
   15. instance58  node19:node20 =&gt; node19:node17 0.00252594 a=r:node17
Cluster score improved from 0.52329131 to 0.00252594

Commands to run to reach the above solution:
  echo step 1
  echo gnt-instance migrate instance14
  echo gnt-instance replace-disks -n node16 instance14
  echo gnt-instance migrate instance14
  echo step 2
  echo gnt-instance migrate instance54
  echo gnt-instance replace-disks -n node16 instance54
  echo gnt-instance migrate instance54
  echo step 3
  echo gnt-instance migrate instance4
  echo gnt-instance replace-disks -n node16 instance4
  echo step 4
  echo gnt-instance replace-disks -n node2 instance48
  echo gnt-instance migrate instance48
  echo step 5
  echo gnt-instance replace-disks -n node16 instance93
  echo gnt-instance migrate instance93
  echo step 6
  echo gnt-instance replace-disks -n node2 instance89
  echo gnt-instance migrate instance89
  echo step 7
  echo gnt-instance replace-disks -n node16 instance5
  echo gnt-instance migrate instance5
  echo step 8
  echo gnt-instance migrate instance94
  echo gnt-instance replace-disks -n node16 instance94
  echo step 9
  echo gnt-instance migrate instance44
  echo gnt-instance replace-disks -n node15 instance44
  echo step 10
  echo gnt-instance replace-disks -n node16 instance62
  echo step 11
  echo gnt-instance replace-disks -n node16 instance13
  echo step 12
  echo gnt-instance replace-disks -n node7 instance19
  echo step 13
  echo gnt-instance replace-disks -n node1 instance43
  echo step 14
  echo gnt-instance replace-disks -n node4 instance1
  echo step 15
  echo gnt-instance replace-disks -n node17 instance58

Final cluster status:
N1 Name   t_mem f_mem r_mem t_dsk f_dsk pri sec  p_fmem  p_fdsk
   node1  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node2  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node3  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node4  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node5  32762  7280  6000  1861  1078   4   5 0.22221 0.57947
   node6  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node7  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node8  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node9  32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node10 32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node11 32762  7280  6000  1861  1022   4   4 0.22221 0.54951
   node12 32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node13 32762  7280  6000  1861  1022   4   4 0.22221 0.54951
   node14 32762  7280  6000  1861  1022   4   4 0.22221 0.54951
   node15 32762  7280  6000  1861  1031   4   4 0.22221 0.55408
   node16 32762  7280  6000  1861  1060   4   4 0.22221 0.57007
   node17 32762  7280  6000  1861  1006   5   4 0.22221 0.54105
   node18 32762  7280  6000  1396   761   4   2 0.22221 0.54570
   node19 32762  7280  6000  1861  1026   4   4 0.22221 0.55179
   node20 32762 13280  6000  1861  1089   3   5 0.40535 0.58565</pre>
</div>
<p>Here we see, beside the step list, the initial and final cluster
status, with the final one showing all nodes being N+1 compliant, and
the command list to reach the final solution. In the initial listing,
we see which nodes are not N+1 compliant.</p>
<p>The algorithm is stable as long as each step above is fully completed,
e.g. in step 8, both the migrate and the replace-disks are
done. Otherwise, if only the migrate is done, the input data is
changed in a way that the program will output a different solution
list (but hopefully will end in the same state).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">hbal</a><ul>
<li><a class="reference internal" href="#name">NAME</a></li>
<li><a class="reference internal" href="#synopsis">SYNOPSIS</a></li>
<li><a class="reference internal" href="#description">DESCRIPTION</a><ul>
<li><a class="reference internal" href="#algorithm">ALGORITHM</a></li>
<li><a class="reference internal" href="#placement-restrictions">PLACEMENT RESTRICTIONS</a></li>
<li><a class="reference internal" href="#cluster-scoring">CLUSTER SCORING</a></li>
<li><a class="reference internal" href="#offline-instances">OFFLINE INSTANCES</a></li>
<li><a class="reference internal" href="#desired-location-tags">DESIRED LOCATION TAGS</a></li>
<li><a class="reference internal" href="#exclusion-tags">EXCLUSION TAGS</a></li>
<li><a class="reference internal" href="#migration-tags">MIGRATION TAGS</a></li>
<li><a class="reference internal" href="#location-tags">LOCATION TAGS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#options">OPTIONS</a></li>
<li><a class="reference internal" href="#signal-handling">SIGNAL HANDLING</a></li>
<li><a class="reference internal" href="#exit-status">EXIT STATUS</a></li>
<li><a class="reference internal" href="#bugs">BUGS</a></li>
<li><a class="reference internal" href="#example">EXAMPLE</a><ul>
<li><a class="reference internal" href="#default-output">Default output</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="man-harep.html"
                        title="previous chapter">harep</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="man-hcheck.html"
                        title="next chapter">hcheck</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/man-hbal.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="man-hcheck.html" title="hcheck"
             >next</a></li>
        <li class="right" >
          <a href="man-harep.html" title="harep"
             >previous</a> |</li>
        <li><a href="index.html">Ganeti 2.17.0~beta1 documentation</a> &raquo;</li>
          <li><a href="manpages.html" >Man pages</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Google Inc..
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>